SCRIPT  /home/pawelztef/.local/share/nvim/plugged/fzf.vim/autoload/fzf/vim.vim
Sourced 1 time
Total time:   0.006246
 Self time:   0.006246

count  total (s)   self (s)
                            " Copyright (c) 2017 Junegunn Choi
                            "
                            " MIT License
                            "
                            " Permission is hereby granted, free of charge, to any person obtaining
                            " a copy of this software and associated documentation files (the
                            " "Software"), to deal in the Software without restriction, including
                            " without limitation the rights to use, copy, modify, merge, publish,
                            " distribute, sublicense, and/or sell copies of the Software, and to
                            " permit persons to whom the Software is furnished to do so, subject to
                            " the following conditions:
                            "
                            " The above copyright notice and this permission notice shall be
                            " included in all copies or substantial portions of the Software.
                            "
                            " THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
                            " EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
                            " MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
                            " NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
                            " LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
                            " OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
                            " WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
                            
    1              0.000041 let s:cpo_save = &cpo
    1              0.000038 set cpo&vim
                            
                            " ------------------------------------------------------------------
                            " Common
                            " ------------------------------------------------------------------
                            
    1              0.000040 let s:is_win = has('win32') || has('win64')
    1              0.000015 let s:layout_keys = ['window', 'up', 'down', 'left', 'right']
    1              0.000023 let s:bin_dir = expand('<sfile>:h:h:h').'/bin/'
    1              0.000090 let s:bin = {
                            \ 'preview': s:bin_dir.(executable('ruby') ? 'preview.rb' : 'preview.sh'),
                            \ 'tags':    s:bin_dir.'tags.pl' }
    1              0.000039 let s:TYPE = {'dict': type({}), 'funcref': type(function('call')), 'string': type(''), 'list': type([])}
    1              0.000008 if s:is_win
                              if has('nvim')
                                let s:bin.preview = split(system('for %A in ("'.s:bin.preview.'") do @echo %~sA'), "\n")[0]
                              else
                                let s:bin.preview = fnamemodify(s:bin.preview, ':8')
                              endif
                              let s:bin.preview = (executable('ruby') ? 'ruby' : 'bash').' '.escape(s:bin.preview, '\')
                            endif
                            
    1              0.000008 let s:wide = 120
                            
    1              0.000014 function! s:extend_opts(dict, eopts, prepend)
                              if empty(a:eopts)
                                return
                              endif
                              if has_key(a:dict, 'options')
                                if type(a:dict.options) == s:TYPE.list && type(a:eopts) == s:TYPE.list
                                  if a:prepend
                                    let a:dict.options = extend(copy(a:eopts), a:dict.options)
                                  else
                                    call extend(a:dict.options, a:eopts)
                                  endif
                                else
                                  let all_opts = a:prepend ? [a:eopts, a:dict.options] : [a:dict.options, a:eopts]
                                  let a:dict.options = join(map(all_opts, 'type(v:val) == s:TYPE.list ? join(map(copy(v:val), "fzf#shellescape(v:val)")) : v:val'))
                                endif
                              else
                                let a:dict.options = a:eopts
                              endif
                            endfunction
                            
    1              0.000011 function! s:merge_opts(dict, eopts)
                              return s:extend_opts(a:dict, a:eopts, 0)
                            endfunction
                            
    1              0.000011 function! s:prepend_opts(dict, eopts)
                              return s:extend_opts(a:dict, a:eopts, 1)
                            endfunction
                            
                            " [[options to wrap], preview window expression, [toggle-preview keys...]]
    1              0.000011 function! fzf#vim#with_preview(...)
                              " Default options
                              let options = {}
                              let window = 'right'
                            
                              let args = copy(a:000)
                            
                              " Options to wrap
                              if len(args) && type(args[0]) == s:TYPE.dict
                                let options = copy(args[0])
                                call remove(args, 0)
                              endif
                            
                              " Preview window
                              if len(args) && type(args[0]) == s:TYPE.string
                                if args[0] !~# '^\(up\|down\|left\|right\)'
                                  throw 'invalid preview window: '.args[0]
                                endif
                                let window = args[0]
                                call remove(args, 0)
                              endif
                            
                              let preview = ['--preview-window', window, '--preview', (s:is_win ? s:bin.preview : fzf#shellescape(s:bin.preview)).' {}']
                            
                              if len(args)
                                call extend(preview, ['--bind', join(map(args, 'v:val.":toggle-preview"'), ',')])
                              endif
                              call s:merge_opts(options, preview)
                              return options
                            endfunction
                            
    1              0.000011 function! s:remove_layout(opts)
                              for key in s:layout_keys
                                if has_key(a:opts, key)
                                  call remove(a:opts, key)
                                endif
                              endfor
                              return a:opts
                            endfunction
                            
    1              0.000009 function! s:wrap(name, opts, bang)
                              " fzf#wrap does not append --expect if sink or sink* is found
                              let opts = copy(a:opts)
                              let options = ''
                              if has_key(opts, 'options')
                                let options = type(opts.options) == s:TYPE.list ? join(opts.options) : opts.options
                              endif
                              if options !~ '--expect' && has_key(opts, 'sink*')
                                let Sink = remove(opts, 'sink*')
                                let wrapped = fzf#wrap(a:name, opts, a:bang)
                                let wrapped['sink*'] = Sink
                              else
                                let wrapped = fzf#wrap(a:name, opts, a:bang)
                              endif
                              return wrapped
                            endfunction
                            
    1              0.000010 function! s:strip(str)
                              return substitute(a:str, '^\s*\|\s*$', '', 'g')
                            endfunction
                            
    1              0.000010 function! s:chomp(str)
                              return substitute(a:str, '\n*$', '', 'g')
                            endfunction
                            
    1              0.000008 function! s:escape(path)
                              let path = fnameescape(a:path)
                              return s:is_win ? escape(path, '$') : path
                            endfunction
                            
    1              0.000010 if v:version >= 704
    1              0.000009   function! s:function(name)
                                return function(a:name)
                              endfunction
    1              0.000005 else
                              function! s:function(name)
                                " By Ingo Karkat
                                return function(substitute(a:name, '^s:', matchstr(expand('<sfile>'), '<SNR>\d\+_\zefunction$'), ''))
                              endfunction
                            endif
                            
    1              0.000010 function! s:get_color(attr, ...)
                              let gui = has('termguicolors') && &termguicolors
                              let fam = gui ? 'gui' : 'cterm'
                              let pat = gui ? '^#[a-f0-9]\+' : '^[0-9]\+$'
                              for group in a:000
                                let code = synIDattr(synIDtrans(hlID(group)), a:attr, fam)
                                if code =~? pat
                                  return code
                                endif
                              endfor
                              return ''
                            endfunction
                            
    1              0.000022 let s:ansi = {'black': 30, 'red': 31, 'green': 32, 'yellow': 33, 'blue': 34, 'magenta': 35, 'cyan': 36}
                            
    1              0.000010 function! s:csi(color, fg)
                              let prefix = a:fg ? '38;' : '48;'
                              if a:color[0] == '#'
                                return prefix.'2;'.join(map([a:color[1:2], a:color[3:4], a:color[5:6]], 'str2nr(v:val, 16)'), ';')
                              endif
                              return prefix.'5;'.a:color
                            endfunction
                            
    1              0.000010 function! s:ansi(str, group, default, ...)
                              let fg = s:get_color('fg', a:group)
                              let bg = s:get_color('bg', a:group)
                              let color = s:csi(empty(fg) ? s:ansi[a:default] : fg, 1) .
                                    \ (empty(bg) ? '' : s:csi(bg, 0))
                              return printf("\x1b[%s%sm%s\x1b[m", color, a:0 ? ';1' : '', a:str)
                            endfunction
                            
    8              0.000062 for s:color_name in keys(s:ansi)
    1              0.000050   execute "function! s:".s:color_name."(str, ...)\n"
                                    \ "  return s:ansi(a:str, get(a:, 1, ''), '".s:color_name."')\n"
    6              0.000180         \ "endfunction"
    7              0.000030 endfor
                            
    1              0.000009 function! s:buflisted()
                              return filter(range(1, bufnr('$')), 'buflisted(v:val) && getbufvar(v:val, "&filetype") != "qf"')
                            endfunction
                            
    1              0.000011 function! s:fzf(name, opts, extra)
                              let [extra, bang] = [{}, 0]
                              if len(a:extra) <= 1
                                let first = get(a:extra, 0, 0)
                                if type(first) == s:TYPE.dict
                                  let extra = first
                                else
                                  let bang = first
                                endif
                              elseif len(a:extra) == 2
                                let [extra, bang] = a:extra
                              else
                                throw 'invalid number of arguments'
                              endif
                            
                              let eopts  = has_key(extra, 'options') ? remove(extra, 'options') : ''
                              let merged = extend(copy(a:opts), extra)
                              call s:merge_opts(merged, eopts)
                              return fzf#run(s:wrap(a:name, merged, bang))
                            endfunction
                            
    1              0.000022 let s:default_action = {
                              \ 'ctrl-t': 'tab split',
                              \ 'ctrl-x': 'split',
                              \ 'ctrl-v': 'vsplit' }
                            
    1              0.000010 function! s:action_for(key, ...)
                              let default = a:0 ? a:1 : ''
                              let Cmd = get(get(g:, 'fzf_action', s:default_action), a:key, default)
                              return type(Cmd) == s:TYPE.string ? Cmd : default
                            endfunction
                            
    1              0.000009 function! s:open(cmd, target)
                              if stridx('edit', a:cmd) == 0 && fnamemodify(a:target, ':p') ==# expand('%:p')
                                return
                              endif
                              execute a:cmd s:escape(a:target)
                            endfunction
                            
    1              0.000009 function! s:align_lists(lists)
                              let maxes = {}
                              for list in a:lists
                                let i = 0
                                while i < len(list)
                                  let maxes[i] = max([get(maxes, i, 0), len(list[i])])
                                  let i += 1
                                endwhile
                              endfor
                              for list in a:lists
                                call map(list, "printf('%-'.maxes[v:key].'s', v:val)")
                              endfor
                              return a:lists
                            endfunction
                            
    1              0.000009 function! s:warn(message)
                              echohl WarningMsg
                              echom a:message
                              echohl None
                              return 0
                            endfunction
                            
    1              0.000010 function! fzf#vim#_uniq(list)
                              let visited = {}
                              let ret = []
                              for l in a:list
                                if !empty(l) && !has_key(visited, l)
                                  call add(ret, l)
                                  let visited[l] = 1
                                endif
                              endfor
                              return ret
                            endfunction
                            
                            " ------------------------------------------------------------------
                            " Files
                            " ------------------------------------------------------------------
    1              0.000016 function! s:shortpath()
                              let short = fnamemodify(getcwd(), ':~:.')
                              if !has('win32unix')
                                let short = pathshorten(short)
                              endif
                              let slash = (s:is_win && !&shellslash) ? '\' : '/'
                              return empty(short) ? '~'.slash : short . (short =~ escape(slash, '\').'$' ? '' : slash)
                            endfunction
                            
    1              0.000010 function! fzf#vim#files(dir, ...)
                              let args = {}
                              if !empty(a:dir)
                                if !isdirectory(expand(a:dir))
                                  return s:warn('Invalid directory')
                                endif
                                let slash = (s:is_win && !&shellslash) ? '\\' : '/'
                                let dir = substitute(a:dir, '[/\\]*$', slash, '')
                                let args.dir = dir
                              else
                                let dir = s:shortpath()
                              endif
                            
                              let args.options = ['-m', '--prompt', strwidth(dir) < &columns / 2 - 20 ? dir : '> ']
                              call s:merge_opts(args, get(g:, 'fzf_files_options', []))
                              return s:fzf('files', args, a:000)
                            endfunction
                            
                            " ------------------------------------------------------------------
                            " Lines
                            " ------------------------------------------------------------------
    1              0.000011 function! s:line_handler(lines)
                              if len(a:lines) < 2
                                return
                              endif
                              normal! m'
                              let cmd = s:action_for(a:lines[0])
                              if !empty(cmd) && stridx('edit', cmd) < 0
                                execute 'silent' cmd
                              endif
                            
                              let keys = split(a:lines[1], '\t')
                              execute 'buffer' keys[0]
                              execute keys[2]
                              normal! ^zz
                            endfunction
                            
    1              0.000011 function! fzf#vim#_lines(all)
                              let cur = []
                              let rest = []
                              let buf = bufnr('')
                              let longest_name = 0
                              let display_bufnames = &columns > s:wide
                              if display_bufnames
                                let bufnames = {}
                                for b in s:buflisted()
                                  let bufnames[b] = pathshorten(fnamemodify(bufname(b), ":~:."))
                                  let longest_name = max([longest_name, len(bufnames[b])])
                                endfor
                              endif
                              let len_bufnames = min([15, longest_name])
                              for b in s:buflisted()
                                let lines = getbufline(b, 1, "$")
                                if empty(lines)
                                  let path = fnamemodify(bufname(b), ':p')
                                  let lines = filereadable(path) ? readfile(path) : []
                                endif
                                if display_bufnames
                                  let bufname = bufnames[b]
                                  if len(bufname) > len_bufnames + 1
                                    let bufname = 'â€¦' . bufname[-(len_bufnames+1):]
                                  endif
                                  let bufname = printf(s:green("%".len_bufnames."s", "Directory"), bufname)
                                else
                                  let bufname = ''
                                endif
                                call extend(b == buf ? cur : rest,
                                \ filter(
                                \   map(lines,
                                \       '(!a:all && empty(v:val)) ? "" : printf(s:blue("%2d\t", "TabLine")."%s".s:yellow("\t%4d ", "LineNr")."\t%s", b, bufname, v:key + 1, v:val)'),
                                \   'a:all || !empty(v:val)'))
                              endfor
                              return [display_bufnames, extend(cur, rest)]
                            endfunction
                            
    1              0.000010 function! fzf#vim#lines(...)
                              let [display_bufnames, lines] = fzf#vim#_lines(1)
                              let nth = display_bufnames ? 3 : 2
                              let [query, args] = (a:0 && type(a:1) == type('')) ?
                                    \ [a:1, a:000[1:]] : ['', a:000]
                              return s:fzf('lines', {
                              \ 'source':  lines,
                              \ 'sink*':   s:function('s:line_handler'),
                              \ 'options': '+m --tiebreak=index --prompt "Lines> " --ansi --extended --nth='.nth.'.. --reverse --tabstop=1'.s:q(query)
                              \}, args)
                            endfunction
                            
                            " ------------------------------------------------------------------
                            " BLines
                            " ------------------------------------------------------------------
    1              0.000012 function! s:buffer_line_handler(lines)
                              if len(a:lines) < 2
                                return
                              endif
                              normal! m'
                              let cmd = s:action_for(a:lines[0])
                              if !empty(cmd)
                                execute 'silent' cmd
                              endif
                            
                              execute split(a:lines[1], '\t')[0]
                              normal! ^zz
                            endfunction
                            
    1              0.000009 function! s:buffer_lines()
                              return map(getline(1, "$"),
                                \ 'printf(s:yellow(" %4d ", "LineNr")."\t%s", v:key + 1, v:val)')
                            endfunction
                            
    1              0.000009 function! fzf#vim#buffer_lines(...)
                              let [query, args] = (a:0 && type(a:1) == type('')) ?
                                    \ [a:1, a:000[1:]] : ['', a:000]
                              return s:fzf('blines', {
                              \ 'source':  s:buffer_lines(),
                              \ 'sink*':   s:function('s:buffer_line_handler'),
                              \ 'options': '+m --tiebreak=index --prompt "BLines> " --ansi --extended --nth=2.. --reverse --tabstop=1'.s:q(query)
                              \}, args)
                            endfunction
                            
                            " ------------------------------------------------------------------
                            " Colors
                            " ------------------------------------------------------------------
    1              0.000011 function! fzf#vim#colors(...)
                              let colors = split(globpath(&rtp, "colors/*.vim"), "\n")
                              if has('packages')
                                let colors += split(globpath(&packpath, "pack/*/opt/*/colors/*.vim"), "\n")
                              endif
                              return s:fzf('colors', {
                              \ 'source':  fzf#vim#_uniq(map(colors, "substitute(fnamemodify(v:val, ':t'), '\\..\\{-}$', '', '')")),
                              \ 'sink':    'colo',
                              \ 'options': '+m --prompt="Colors> "'
                              \}, a:000)
                            endfunction
                            
                            " ------------------------------------------------------------------
                            " Locate
                            " ------------------------------------------------------------------
    1              0.000010 function! fzf#vim#locate(query, ...)
                              return s:fzf('locate', {
                              \ 'source':  'locate '.a:query,
                              \ 'options': '-m --prompt "Locate> "'
                              \}, a:000)
                            endfunction
                            
                            " ------------------------------------------------------------------
                            " History[:/]
                            " ------------------------------------------------------------------
    1              0.000009 function! s:all_files()
                              return fzf#vim#_uniq(map(
                                \ filter([expand('%')], 'len(v:val)')
                                \   + filter(map(s:buflisted_sorted(), 'bufname(v:val)'), 'len(v:val)')
                                \   + filter(copy(v:oldfiles), "filereadable(expand(v:val))"),
                                \ 'fnamemodify(v:val, ":~:.")'))
                            endfunction
                            
    1              0.000010 function! s:history_source(type)
                              let max  = histnr(a:type)
                              let fmt  = ' %'.len(string(max)).'d '
                              let list = filter(map(range(1, max), 'histget(a:type, - v:val)'), '!empty(v:val)')
                              return extend([' :: Press '.s:magenta('CTRL-E', 'Special').' to edit'],
                                \ map(list, 's:yellow(printf(fmt, len(list) - v:key), "Number")." ".v:val'))
                            endfunction
                            
    1              0.000051 nnoremap <plug>(-fzf-vim-do) :execute g:__fzf_command<cr>
                            
    1              0.000011 function! s:history_sink(type, lines)
                              if len(a:lines) < 2
                                return
                              endif
                            
                              let key  = a:lines[0]
                              let item = matchstr(a:lines[1], ' *[0-9]\+ *\zs.*')
                              if key == 'ctrl-e'
                                call histadd(a:type, item)
                                redraw
                                call feedkeys(a:type."\<up>")
                              else
                                let g:__fzf_command = "normal ".a:type.item."\<cr>"
                                call feedkeys("\<plug>(-fzf-vim-do)")
                              endif
                            endfunction
                            
    1              0.000009 function! s:cmd_history_sink(lines)
                              call s:history_sink(':', a:lines)
                            endfunction
                            
    1              0.000010 function! fzf#vim#command_history(...)
                              return s:fzf('history-command', {
                              \ 'source':  s:history_source(':'),
                              \ 'sink*':   s:function('s:cmd_history_sink'),
                              \ 'options': '+m --ansi --prompt="Hist:> " --header-lines=1 --expect=ctrl-e --tiebreak=index'}, a:000)
                            endfunction
                            
    1              0.000009 function! s:search_history_sink(lines)
                              call s:history_sink('/', a:lines)
                            endfunction
                            
    1              0.000010 function! fzf#vim#search_history(...)
                              return s:fzf('history-search', {
                              \ 'source':  s:history_source('/'),
                              \ 'sink*':   s:function('s:search_history_sink'),
                              \ 'options': '+m --ansi --prompt="Hist/> " --header-lines=1 --expect=ctrl-e --tiebreak=index'}, a:000)
                            endfunction
                            
    1              0.000008 function! fzf#vim#history(...)
                              return s:fzf('history-files', {
                              \ 'source':  s:all_files(),
                              \ 'options': ['-m', '--header-lines', !empty(expand('%')), '--prompt', 'Hist> ']
                              \}, a:000)
                            endfunction
                            
                            " ------------------------------------------------------------------
                            " GFiles[?]
                            " ------------------------------------------------------------------
                            
    1              0.000018 function! s:get_git_root()
                              let root = split(system('git rev-parse --show-toplevel'), '\n')[0]
                              return v:shell_error ? '' : root
                            endfunction
                            
    1              0.000010 function! fzf#vim#gitfiles(args, ...)
                              let root = s:get_git_root()
                              if empty(root)
                                return s:warn('Not in git repo')
                              endif
                              if a:args != '?'
                                return s:fzf('gfiles', {
                                \ 'source':  'git ls-files '.a:args.(s:is_win ? '' : ' | uniq'),
                                \ 'dir':     root,
                                \ 'options': '-m --prompt "GitFiles> "'
                                \}, a:000)
                              endif
                            
                              " Here be dragons!
                              " We're trying to access the common sink function that fzf#wrap injects to
                              " the options dictionary.
                              let wrapped = fzf#wrap({
                              \ 'source':  'git -c color.status=always status --short --untracked-files=all',
                              \ 'dir':     root,
                              \ 'options': ['--ansi', '--multi', '--nth', '2..,..', '--tiebreak=index', '--prompt', 'GitFiles?> ', '--preview', 'sh -c "(git diff --color=always -- {-1} | sed 1,4d; cat {-1}) | head -500"']
                              \})
                              call s:remove_layout(wrapped)
                              let wrapped.common_sink = remove(wrapped, 'sink*')
                              function! wrapped.newsink(lines)
                                let lines = extend(a:lines[0:0], map(a:lines[1:], 'substitute(v:val[3:], ".* -> ", "", "")'))
                                return self.common_sink(lines)
                              endfunction
                              let wrapped['sink*'] = remove(wrapped, 'newsink')
                              return s:fzf('gfiles-diff', wrapped, a:000)
                            endfunction
                            
                            " ------------------------------------------------------------------
                            " Buffers
                            " ------------------------------------------------------------------
    1              0.000012 function! s:find_open_window(b)
                              let [tcur, tcnt] = [tabpagenr() - 1, tabpagenr('$')]
                              for toff in range(0, tabpagenr('$') - 1)
                                let t = (tcur + toff) % tcnt + 1
                                let buffers = tabpagebuflist(t)
                                for w in range(1, len(buffers))
                                  let b = buffers[w - 1]
                                  if b == a:b
                                    return [t, w]
                                  endif
                                endfor
                              endfor
                              return [0, 0]
                            endfunction
                            
    1              0.000009 function! s:jump(t, w)
                              execute 'normal!' a:t.'gt'
                              execute a:w.'wincmd w'
                            endfunction
                            
    1              0.000013 function! s:bufopen(lines)
                              if len(a:lines) < 2
                                return
                              endif
                              let b = matchstr(a:lines[1], '\[\zs[0-9]*\ze\]')
                              if empty(a:lines[0]) && get(g:, 'fzf_buffers_jump')
                                let [t, w] = s:find_open_window(b)
                                if t
                                  call s:jump(t, w)
                                  return
                                endif
                              endif
                              let cmd = s:action_for(a:lines[0])
                              if !empty(cmd)
                                execute 'silent' cmd
                              endif
                              execute 'buffer' b
                            endfunction
                            
    1              0.000011 function! s:format_buffer(b)
                              let name = bufname(a:b)
                              let name = empty(name) ? '[No Name]' : fnamemodify(name, ":~:.")
                              let flag = a:b == bufnr('')  ? s:blue('%', 'Conditional') :
                                      \ (a:b == bufnr('#') ? s:magenta('#', 'Special') : ' ')
                              let modified = getbufvar(a:b, '&modified') ? s:red(' [+]', 'Exception') : ''
                              let readonly = getbufvar(a:b, '&modifiable') ? '' : s:green(' [RO]', 'Constant')
                              let extra = join(filter([modified, readonly], '!empty(v:val)'), '')
                              return s:strip(printf("[%s] %s\t%s\t%s", s:yellow(a:b, 'Number'), flag, name, extra))
                            endfunction
                            
    1              0.000009 function! s:sort_buffers(...)
                              let [b1, b2] = map(copy(a:000), 'get(g:fzf#vim#buffers, v:val, v:val)')
                              " Using minus between a float and a number in a sort function causes an error
                              return b1 < b2 ? 1 : -1
                            endfunction
                            
    1              0.000009 function! s:buflisted_sorted()
                              return sort(s:buflisted(), 's:sort_buffers')
                            endfunction
                            
    1              0.000009 function! fzf#vim#buffers(...)
                              let [query, args] = (a:0 && type(a:1) == type('')) ?
                                    \ [a:1, a:000[1:]] : ['', a:000]
                              return s:fzf('buffers', {
                              \ 'source':  map(s:buflisted_sorted(), 's:format_buffer(v:val)'),
                              \ 'sink*':   s:function('s:bufopen'),
                              \ 'options': '+m -x --tiebreak=index --header-lines=1 --ansi -d "\t" -n 2,1..2 --prompt="Buf> "'.s:q(query)
                              \}, args)
                            endfunction
                            
                            " ------------------------------------------------------------------
                            " Ag
                            " ------------------------------------------------------------------
    1              0.000010 function! s:ag_to_qf(line, with_column)
                              let parts = split(a:line, ':')
                              let text = join(parts[(a:with_column ? 3 : 2):], ':')
                              let dict = {'filename': &acd ? fnamemodify(parts[0], ':p') : parts[0], 'lnum': parts[1], 'text': text}
                              if a:with_column
                                let dict.col = parts[2]
                              endif
                              return dict
                            endfunction
                            
    1              0.000010 function! s:ag_handler(lines, with_column)
                              if len(a:lines) < 2
                                return
                              endif
                            
                              let cmd = s:action_for(a:lines[0], 'e')
                              let list = map(filter(a:lines[1:], 'len(v:val)'), 's:ag_to_qf(v:val, a:with_column)')
                              if empty(list)
                                return
                              endif
                            
                              let first = list[0]
                              try
                                call s:open(cmd, first.filename)
                                execute first.lnum
                                if a:with_column
                                  execute 'normal!' first.col.'|'
                                endif
                                normal! zz
                              catch
                              endtry
                            
                              if len(list) > 1
                                call setqflist(list)
                                copen
                                wincmd p
                              endif
                            endfunction
                            
                            " query, [[ag options], options]
    1              0.000010 function! fzf#vim#ag(query, ...)
                              if type(a:query) != s:TYPE.string
                                return s:warn('Invalid query argument')
                              endif
                              let query = empty(a:query) ? '^(?=.)' : a:query
                              let args = copy(a:000)
                              let ag_opts = len(args) > 1 && type(args[0]) == s:TYPE.string ? remove(args, 0) : ''
                              let command = ag_opts . ' ' . fzf#shellescape(query)
                              return call('fzf#vim#ag_raw', insert(args, command, 0))
                            endfunction
                            
                            " ag command suffix, [options]
    1              0.000010 function! fzf#vim#ag_raw(command_suffix, ...)
                              if !executable('ag')
                                return s:warn('ag is not found')
                              endif
                              return call('fzf#vim#grep', extend(['ag --nogroup --column --color '.a:command_suffix, 1], a:000))
                            endfunction
                            
                            " command, with_column, [options]
    1              0.000011 function! fzf#vim#grep(grep_command, with_column, ...)
                              let words = []
                              for word in split(a:grep_command)
                                if word !~# '^[a-z]'
                                  break
                                endif
                                call add(words, word)
                              endfor
                              let words   = empty(words) ? ['grep'] : words
                              let name    = join(words, '-')
                              let capname = join(map(words, 'toupper(v:val[0]).v:val[1:]'), '')
                              let opts = {
                              \ 'source':  a:grep_command,
                              \ 'column':  a:with_column,
                              \ 'options': ['--ansi', '--prompt', capname.'> ',
                              \             '--multi', '--bind', 'alt-a:select-all,alt-d:deselect-all',
                              \             '--color', 'hl:68,hl+:110']
                              \}
                              function! opts.sink(lines)
                                return s:ag_handler(a:lines, self.column)
                              endfunction
                              let opts['sink*'] = remove(opts, 'sink')
                              return s:fzf(name, opts, a:000)
                            endfunction
                            
                            " ------------------------------------------------------------------
                            " BTags
                            " ------------------------------------------------------------------
    1              0.000011 function! s:btags_source(tag_cmds)
                              if !filereadable(expand('%'))
                                throw 'Save the file first'
                              endif
                            
                              for cmd in a:tag_cmds
                                let lines = split(system(cmd), "\n")
                                if !v:shell_error && len(lines)
                                  break
                                endif
                              endfor
                              if v:shell_error
                                throw get(lines, 0, 'Failed to extract tags')
                              elseif empty(lines)
                                throw 'No tags found'
                              endif
                              return map(s:align_lists(map(lines, 'split(v:val, "\t")')), 'join(v:val, "\t")')
                            endfunction
                            
    1              0.000009 function! s:btags_sink(lines)
                              if len(a:lines) < 2
                                return
                              endif
                              normal! m'
                              let cmd = s:action_for(a:lines[0])
                              if !empty(cmd)
                                execute 'silent' cmd '%'
                              endif
                              let qfl = []
                              for line in a:lines[1:]
                                execute split(line, "\t")[2]
                                call add(qfl, {'filename': expand('%'), 'lnum': line('.'), 'text': getline('.')})
                              endfor
                              if len(qfl) > 1
                                call setqflist(qfl)
                                copen
                                wincmd p
                                cfirst
                              endif
                              normal! zz
                            endfunction
                            
    1              0.000009 function! s:q(query)
                              return ' --query '.fzf#shellescape(a:query)
                            endfunction
                            
                            " query, [[tag commands], options]
    1              0.000010 function! fzf#vim#buffer_tags(query, ...)
                              let args = copy(a:000)
                              let escaped = fzf#shellescape(expand('%'))
                              let null = s:is_win ? 'nul' : '/dev/null'
                              let tag_cmds = (len(args) > 1 && type(args[0]) != type({})) ? remove(args, 0) : [
                                \ printf('ctags -f - --sort=no --excmd=number --language-force=%s %s 2> %s', &filetype, escaped, null),
                                \ printf('ctags -f - --sort=no --excmd=number %s 2> %s', escaped, null)]
                              if type(tag_cmds) != type([])
                                let tag_cmds = [tag_cmds]
                              endif
                              try
                                return s:fzf('btags', {
                                \ 'source':  s:btags_source(tag_cmds),
                                \ 'sink*':   s:function('s:btags_sink'),
                                \ 'options': '--reverse -m -d "\t" --with-nth 1,4.. -n 1 --prompt "BTags> "'.s:q(a:query)}, args)
                              catch
                                return s:warn(v:exception)
                              endtry
                            endfunction
                            
                            " ------------------------------------------------------------------
                            " Tags
                            " ------------------------------------------------------------------
    1              0.000010 function! s:tags_sink(lines)
                              if len(a:lines) < 2
                                return
                              endif
                              normal! m'
                              let qfl = []
                              let cmd = s:action_for(a:lines[0], 'e')
                              try
                                let [magic, &magic, wrapscan, &wrapscan, acd, &acd] = [&magic, 0, &wrapscan, 1, &acd, 0]
                                for line in a:lines[1:]
                                  try
                                    let parts   = split(line, '\t\zs')
                                    let excmd   = matchstr(join(parts[2:-2], '')[:-2], '^.\{-}\ze;\?"\t')
                                    let base    = fnamemodify(parts[-1], ':h')
                                    let relpath = parts[1][:-2]
                                    let abspath = relpath =~ (s:is_win ? '^[A-Z]:\' : '^/') ? relpath : join([base, relpath], '/')
                                    call s:open(cmd, expand(abspath, 1))
                                    execute excmd
                                    call add(qfl, {'filename': expand('%'), 'lnum': line('.'), 'text': getline('.')})
                                  catch /^Vim:Interrupt$/
                                    break
                                  catch
                                    call s:warn(v:exception)
                                  endtry
                                endfor
                              finally
                                let [&magic, &wrapscan, &acd] = [magic, wrapscan, acd]
                              endtry
                              if len(qfl) > 1
                                call setqflist(qfl)
                                copen
                                wincmd p
                                clast
                              endif
                              normal! zz
                            endfunction
                            
    1              0.000011 function! fzf#vim#tags(query, ...)
                              if !executable('perl')
                                return s:warn('Tags command requires perl')
                              endif
                              if empty(tagfiles())
                                call inputsave()
                                echohl WarningMsg
                                let gen = input('tags not found. Generate? (y/N) ')
                                echohl None
                                call inputrestore()
                                redraw
                                if gen =~? '^y'
                                  call s:warn('Preparing tags')
                                  call system(get(g:, 'fzf_tags_command', 'ctags -R'.(s:is_win ? ' --output-format=e-ctags' : '')))
                                  if empty(tagfiles())
                                    return s:warn('Failed to create tags')
                                  endif
                                else
                                  return s:warn('No tags found')
                                endif
                              endif
                            
                              let tagfiles = tagfiles()
                              let v2_limit = 1024 * 1024 * 200
                              for tagfile in tagfiles
                                let v2_limit -= getfsize(tagfile)
                                if v2_limit < 0
                                  break
                                endif
                              endfor
                              let opts = v2_limit < 0 ? '--algo=v1 ' : ''
                            
                              return s:fzf('tags', {
                              \ 'source':  'perl '.fzf#shellescape(s:bin.tags).' '.join(map(tagfiles, 'fzf#shellescape(fnamemodify(v:val, ":p"))')),
                              \ 'sink*':   s:function('s:tags_sink'),
                              \ 'options': opts.'--nth 1..2 -m --tiebreak=begin --prompt "Tags> "'.s:q(a:query)}, a:000)
                            endfunction
                            
                            " ------------------------------------------------------------------
                            " Snippets (UltiSnips)
                            " ------------------------------------------------------------------
    1              0.000011 function! s:inject_snippet(line)
                              let snip = split(a:line, "\t")[0]
                              execute 'normal! a'.s:strip(snip)."\<c-r>=UltiSnips#ExpandSnippet()\<cr>"
                            endfunction
                            
    1              0.000010 function! fzf#vim#snippets(...)
                              if !exists(':UltiSnipsEdit')
                                return s:warn('UltiSnips not found')
                              endif
                              let list = UltiSnips#SnippetsInCurrentScope()
                              if empty(list)
                                return s:warn('No snippets available here')
                              endif
                              let aligned = sort(s:align_lists(items(list)))
                              let colored = map(aligned, 's:yellow(v:val[0])."\t".v:val[1]')
                              return s:fzf('snippets', {
                              \ 'source':  colored,
                              \ 'options': '--ansi --tiebreak=index +m -n 1 -d "\t"',
                              \ 'sink':    s:function('s:inject_snippet')}, a:000)
                            endfunction
                            
                            " ------------------------------------------------------------------
                            " Commands
                            " ------------------------------------------------------------------
    1              0.000019 let s:nbs = nr2char(0x2007)
                            
    1              0.000010 function! s:format_cmd(line)
                              return substitute(a:line, '\C \([A-Z]\S*\) ',
                                    \ '\=s:nbs.s:yellow(submatch(1), "Function").s:nbs', '')
                            endfunction
                            
    1              0.000009 function! s:command_sink(lines)
                              if len(a:lines) < 2
                                return
                              endif
                              let cmd = matchstr(a:lines[1], s:nbs.'\zs\S*\ze'.s:nbs)
                              if empty(a:lines[0])
                                call feedkeys(':'.cmd.(a:lines[1][0] == '!' ? '' : ' '))
                              else
                                execute cmd
                              endif
                            endfunction
                            
    1              0.000010 function! s:format_excmd(ex)
                              let match = matchlist(a:ex, '^|:\(\S\+\)|\s*\S*\(.*\)')
                              return printf('   '.s:blue('%-38s', 'Statement').'%s', s:nbs.match[1].s:nbs, s:strip(match[2]))
                            endfunction
                            
    1              0.000008 function! s:excmds()
                              let help = globpath($VIMRUNTIME, 'doc/index.txt')
                              if empty(help)
                                return []
                              endif
                            
                              let commands = []
                              let command = ''
                              for line in readfile(help)
                                if line =~ '^|:[^|]'
                                  if !empty(command)
                                    call add(commands, s:format_excmd(command))
                                  endif
                                  let command = line
                                elseif line =~ '^\s\+\S' && !empty(command)
                                  let command .= substitute(line, '^\s*', ' ', '')
                                elseif !empty(commands) && line =~ '^\s*$'
                                  break
                                endif
                              endfor
                              if !empty(command)
                                call add(commands, s:format_excmd(command))
                              endif
                              return commands
                            endfunction
                            
    1              0.000010 function! fzf#vim#commands(...)
                              redir => cout
                              silent command
                              redir END
                              let list = split(cout, "\n")
                              return s:fzf('commands', {
                              \ 'source':  extend(extend(list[0:0], map(list[1:], 's:format_cmd(v:val)')), s:excmds()),
                              \ 'sink*':   s:function('s:command_sink'),
                              \ 'options': '--ansi --expect '.get(g:, 'fzf_commands_expect', 'ctrl-x').
                              \            ' --tiebreak=index --header-lines 1 -x --prompt "Commands> " -n2,3,2..3 -d'.s:nbs}, a:000)
                            endfunction
                            
                            " ------------------------------------------------------------------
                            " Marks
                            " ------------------------------------------------------------------
    1              0.000009 function! s:format_mark(line)
                              return substitute(a:line, '\S', '\=s:yellow(submatch(0))', '')
                            endfunction
                            
    1              0.000009 function! s:mark_sink(lines)
                              if len(a:lines) < 2
                                return
                              endif
                              let cmd = s:action_for(a:lines[0])
                              if !empty(cmd)
                                execute 'silent' cmd
                              endif
                              execute 'normal! `'.matchstr(a:lines[1], '\S').'zz'
                            endfunction
                            
    1              0.000010 function! fzf#vim#marks(...)
                              redir => cout
                              silent marks
                              redir END
                              let list = split(cout, "\n")
                              return s:fzf('marks', {
                              \ 'source':  extend(list[0:0], map(list[1:], 's:format_mark(v:val)')),
                              \ 'sink*':   s:function('s:mark_sink'),
                              \ 'options': '+m -x --ansi --tiebreak=index --header-lines 1 --tiebreak=begin --prompt "Marks> "'}, a:000)
                            endfunction
                            
                            " ------------------------------------------------------------------
                            " Help tags
                            " ------------------------------------------------------------------
    1              0.000009 function! s:helptag_sink(line)
                              let [tag, file, path] = split(a:line, "\t")[0:2]
                              let rtp = fnamemodify(path, ':p:h:h')
                              if stridx(&rtp, rtp) < 0
                                execute 'set rtp+='.s:escape(rtp)
                              endif
                              execute 'help' tag
                            endfunction
                            
    1              0.000009 function! fzf#vim#helptags(...)
                              if !executable('grep') || !executable('perl')
                                return s:warn('Helptags command requires grep and perl')
                              endif
                              let sorted = sort(split(globpath(&runtimepath, 'doc/tags'), '\n'))
                              let tags = exists('*uniq') ? uniq(sorted) : fzf#vim#_uniq(sorted)
                            
                              if exists('s:helptags_script')
                                silent! call delete(s:helptags_script)
                              endif
                              let s:helptags_script = tempname()
                              call writefile(['/('.(s:is_win ? '^[A-Z]:\/.*?[^:]' : '.*?').'):(.*?)\t(.*?)\t/; printf(qq('.s:green('%-40s', 'Label').'\t%s\t%s\n), $2, $3, $1)'], s:helptags_script)
                              return s:fzf('helptags', {
                              \ 'source':  'grep -H ".*" '.join(map(tags, 'fzf#shellescape(v:val)')).
                                \ ' | perl -n '.fzf#shellescape(s:helptags_script).' | sort',
                              \ 'sink':    s:function('s:helptag_sink'),
                              \ 'options': ['--ansi', '+m', '--tiebreak=begin', '--with-nth', '..-2']}, a:000)
                            endfunction
                            
                            " ------------------------------------------------------------------
                            " File types
                            " ------------------------------------------------------------------
    1              0.000010 function! fzf#vim#filetypes(...)
                              return s:fzf('filetypes', {
                              \ 'source':  sort(map(split(globpath(&rtp, 'syntax/*.vim'), '\n'),
                              \            'fnamemodify(v:val, ":t:r")')),
                              \ 'sink':    'setf',
                              \ 'options': '+m --prompt="File types> "'
                              \}, a:000)
                            endfunction
                            
                            " ------------------------------------------------------------------
                            " Windows
                            " ------------------------------------------------------------------
    1              0.000011 function! s:format_win(tab, win, buf)
                              let modified = getbufvar(a:buf, '&modified')
                              let name = bufname(a:buf)
                              let name = empty(name) ? '[No Name]' : name
                              let active = tabpagewinnr(a:tab) == a:win
                              return (active? s:blue('> ', 'Operator') : '  ') . name . (modified? s:red(' [+]', 'Exception') : '')
                            endfunction
                            
    1              0.000011 function! s:windows_sink(line)
                              let list = matchlist(a:line, '^ *\([0-9]\+\) *\([0-9]\+\)')
                              call s:jump(list[1], list[2])
                            endfunction
                            
    1              0.000009 function! fzf#vim#windows(...)
                              let lines = []
                              for t in range(1, tabpagenr('$'))
                                let buffers = tabpagebuflist(t)
                                for w in range(1, len(buffers))
                                  call add(lines,
                                    \ printf('%s %s  %s',
                                        \ s:yellow(printf('%3d', t), 'Number'),
                                        \ s:cyan(printf('%3d', w), 'String'),
                                        \ s:format_win(t, w, buffers[w-1])))
                                endfor
                              endfor
                              return s:fzf('windows', {
                              \ 'source':  extend(['Tab Win    Name'], lines),
                              \ 'sink':    s:function('s:windows_sink'),
                              \ 'options': '+m --ansi --tiebreak=begin --header-lines=1'}, a:000)
                            endfunction
                            
                            " ------------------------------------------------------------------
                            " Commits / BCommits
                            " ------------------------------------------------------------------
    1              0.000009 function! s:yank_to_register(data)
                              let @" = a:data
                              silent! let @* = a:data
                              silent! let @+ = a:data
                            endfunction
                            
    1              0.000010 function! s:commits_sink(lines)
                              if len(a:lines) < 2
                                return
                              endif
                            
                              let pat = '[0-9a-f]\{7,9}'
                            
                              if a:lines[0] == 'ctrl-y'
                                let hashes = join(filter(map(a:lines[1:], 'matchstr(v:val, pat)'), 'len(v:val)'))
                                return s:yank_to_register(hashes)
                              end
                            
                              let diff = a:lines[0] == 'ctrl-d'
                              let cmd = s:action_for(a:lines[0], 'e')
                              let buf = bufnr('')
                              for idx in range(1, len(a:lines) - 1)
                                let sha = matchstr(a:lines[idx], pat)
                                if !empty(sha)
                                  if diff
                                    if idx > 1
                                      execute 'tab sb' buf
                                    endif
                                    execute 'Gdiff' sha
                                  else
                                    " Since fugitive buffers are unlisted, we can't keep using 'e'
                                    let c = (cmd == 'e' && idx > 1) ? 'tab split' : cmd
                                    execute c 'fugitive://'.s:git_root.'/.git//'.sha
                                  endif
                                endif
                              endfor
                            endfunction
                            
    1              0.000011 function! s:commits(buffer_local, args)
                              let s:git_root = s:get_git_root()
                              if empty(s:git_root)
                                return s:warn('Not in git repository')
                              endif
                            
                              let source = 'git log '.get(g:, 'fzf_commits_log_options', '--color=always '.fzf#shellescape('--format=%C(auto)%h%d %s %C(green)%cr'))
                              let current = expand('%')
                              let managed = 0
                              if !empty(current)
                                call system('git show '.fzf#shellescape(current).' 2> '.(s:is_win ? 'nul' : '/dev/null'))
                                let managed = !v:shell_error
                              endif
                            
                              if a:buffer_local
                                if !managed
                                  return s:warn('The current buffer is not in the working tree')
                                endif
                                let source .= ' --follow '.fzf#shellescape(current)
                              else
                                let source .= ' --graph'
                              endif
                            
                              let command = a:buffer_local ? 'BCommits' : 'Commits'
                              let expect_keys = join(keys(get(g:, 'fzf_action', s:default_action)), ',')
                              let options = {
                              \ 'source':  source,
                              \ 'sink*':   s:function('s:commits_sink'),
                              \ 'options': ['--ansi', '--multi', '--tiebreak=index', '--reverse',
                              \   '--inline-info', '--prompt', command.'> ', '--bind=ctrl-s:toggle-sort',
                              \   '--header', ':: Press '.s:magenta('CTRL-S', 'Special').' to toggle sort, '.s:magenta('CTRL-Y', 'Special').' to yank commit hashes',
                              \   '--expect=ctrl-y,'.expect_keys]
                              \ }
                            
                              if a:buffer_local
                                let options.options[-2] .= ', '.s:magenta('CTRL-D', 'Special').' to diff'
                                let options.options[-1] .= ',ctrl-d'
                              endif
                            
                              if !s:is_win && &columns > s:wide
                                call extend(options.options,
                                \ ['--preview', 'echo {} | grep -o "[a-f0-9]\{7,\}" | head -1 | xargs git show --format=format: --color=always | head -200'])
                              endif
                            
                              return s:fzf(a:buffer_local ? 'bcommits' : 'commits', options, a:args)
                            endfunction
                            
    1              0.000010 function! fzf#vim#commits(...)
                              return s:commits(0, a:000)
                            endfunction
                            
    1              0.000009 function! fzf#vim#buffer_commits(...)
                              return s:commits(1, a:000)
                            endfunction
                            
                            " ------------------------------------------------------------------
                            " fzf#vim#maps(mode, opts[with count and op])
                            " ------------------------------------------------------------------
    1              0.000009 function! s:align_pairs(list)
                              let maxlen = 0
                              let pairs = []
                              for elem in a:list
                                let match = matchlist(elem, '^\(\S*\)\s*\(.*\)$')
                                let [_, k, v] = match[0:2]
                                let maxlen = max([maxlen, len(k)])
                                call add(pairs, [k, substitute(v, '^\*\?[@ ]\?', '', '')])
                              endfor
                              let maxlen = min([maxlen, 35])
                              return map(pairs, "printf('%-'.maxlen.'s', v:val[0]).' '.v:val[1]")
                            endfunction
                            
    1              0.000013 function! s:highlight_keys(str)
                              return substitute(
                                    \ substitute(a:str, '<[^ >]\+>', s:yellow('\0', 'Special'), 'g'),
                                    \ '<Plug>', s:blue('<Plug>', 'SpecialKey'), 'g')
                            endfunction
                            
    1              0.000009 function! s:key_sink(line)
                              let key = matchstr(a:line, '^\S*')
                              redraw
                              call feedkeys(s:map_gv.s:map_cnt.s:map_reg, 'n')
                              call feedkeys(s:map_op.
                                    \ substitute(key, '<[^ >]\+>', '\=eval("\"\\".submatch(0)."\"")', 'g'))
                            endfunction
                            
    1              0.000009 function! fzf#vim#maps(mode, ...)
                              let s:map_gv  = a:mode == 'x' ? 'gv' : ''
                              let s:map_cnt = v:count == 0 ? '' : v:count
                              let s:map_reg = empty(v:register) ? '' : ('"'.v:register)
                              let s:map_op  = a:mode == 'o' ? v:operator : ''
                            
                              redir => cout
                              silent execute 'verbose' a:mode.'map'
                              redir END
                              let list = []
                              let curr = ''
                              for line in split(cout, "\n")
                                if line =~ "^\t"
                                  let src = '  '.join(reverse(reverse(split(split(line)[-1], '/'))[0:2]), '/')
                                  call add(list, printf('%s %s', curr, s:green(src, 'Comment')))
                                  let curr = ''
                                else
                                  let curr = line[3:]
                                endif
                              endfor
                              if !empty(curr)
                                call add(list, curr)
                              endif
                              let aligned = s:align_pairs(list)
                              let sorted  = sort(aligned)
                              let colored = map(sorted, 's:highlight_keys(v:val)')
                              let pcolor  = a:mode == 'x' ? 9 : a:mode == 'o' ? 10 : 12
                              return s:fzf('maps', {
                              \ 'source':  colored,
                              \ 'sink':    s:function('s:key_sink'),
                              \ 'options': '--prompt "Maps ('.a:mode.')> " --ansi --no-hscroll --nth 1,.. --color prompt:'.pcolor}, a:000)
                            endfunction
                            
                            " ----------------------------------------------------------------------------
                            " fzf#vim#complete - completion helper
                            " ----------------------------------------------------------------------------
    1              0.000046 inoremap <silent> <Plug>(-fzf-complete-trigger) <c-o>:call <sid>complete_trigger()<cr>
                            
    1              0.000020 function! s:pluck(dict, key, default)
                              return has_key(a:dict, a:key) ? remove(a:dict, a:key) : a:default
                            endfunction
                            
    1              0.000009 function! s:complete_trigger()
                              let opts = copy(s:opts)
                              call s:prepend_opts(opts, ['+m', '-q', s:query])
                              let opts['sink*'] = s:function('s:complete_insert')
                              let s:reducer = s:pluck(opts, 'reducer', s:function('s:first_line'))
                              call fzf#run(opts)
                            endfunction
                            
                            " The default reducer
    1              0.000008 function! s:first_line(lines)
                              return a:lines[0]
                            endfunction
                            
    1              0.000009 function! s:complete_insert(lines)
                              if empty(a:lines)
                                return
                              endif
                            
                              let chars = strchars(s:query)
                              if     chars == 0 | let del = ''
                              elseif chars == 1 | let del = '"_x'
                              else              | let del = (chars - 1).'"_dvh'
                              endif
                            
                              let data = call(s:reducer, [a:lines])
                              let ve = &ve
                              set ve=
                              execute 'normal!' ((s:eol || empty(chars)) ? '' : 'h').del.(s:eol ? 'a': 'i').data
                              let &ve = ve
                              if mode() =~ 't'
                                call feedkeys('a', 'n')
                              else
                                execute "normal! \<esc>la"
                              endif
                            endfunction
                            
    1              0.000011 function! s:eval(dict, key, arg)
                              if has_key(a:dict, a:key) && type(a:dict[a:key]) == s:TYPE.funcref
                                let ret = copy(a:dict)
                                let ret[a:key] = call(a:dict[a:key], [a:arg])
                                return ret
                              endif
                              return a:dict
                            endfunction
                            
    1              0.000009 function! fzf#vim#complete(...)
                              if a:0 == 0
                                let s:opts = fzf#wrap()
                              elseif type(a:1) == s:TYPE.dict
                                let s:opts = copy(a:1)
                              elseif type(a:1) == s:TYPE.string
                                let s:opts = extend({'source': a:1}, get(a:000, 1, fzf#wrap()))
                              else
                                echoerr 'Invalid argument: '.string(a:000)
                                return ''
                              endif
                              for s in ['sink', 'sink*']
                                if has_key(s:opts, s)
                                  call remove(s:opts, s)
                                endif
                              endfor
                            
                              let eol = col('$')
                              let ve = &ve
                              set ve=all
                              let s:eol = col('.') == eol
                              let &ve = ve
                            
                              let Prefix = s:pluck(s:opts, 'prefix', '\k*$')
                              if col('.') == 1
                                let s:query = ''
                              else
                                let full_prefix = getline('.')[0 : col('.')-2]
                                if type(Prefix) == s:TYPE.funcref
                                  let s:query = call(Prefix, [full_prefix])
                                else
                                  let s:query = matchstr(full_prefix, Prefix)
                                endif
                              endif
                              let s:opts = s:eval(s:opts, 'source', s:query)
                              let s:opts = s:eval(s:opts, 'options', s:query)
                              let s:opts = s:eval(s:opts, 'extra_options', s:query)
                              if has_key(s:opts, 'extra_options')
                                call s:merge_opts(s:opts, remove(s:opts, 'extra_options'))
                              endif
                              if has_key(s:opts, 'options')
                                if type(s:opts.options) == s:TYPE.list
                                  call add(s:opts.options, '--no-expect')
                                else
                                  let s:opts.options .= ' --no-expect'
                                endif
                              endif
                            
                              call feedkeys("\<Plug>(-fzf-complete-trigger)")
                              return ''
                            endfunction
                            
                            " ------------------------------------------------------------------
    1              0.000039 let &cpo = s:cpo_save
    1              0.000010 unlet s:cpo_save
                            

SCRIPT  /usr/share/nvim/runtime/ftplugin/scss.vim
Sourced 1 time
Total time:   0.001235
 Self time:   0.000806

count  total (s)   self (s)
                            " Vim filetype plugin
                            " Language:	SCSS
                            " Maintainer:	Tim Pope <vimNOSPAM@tpope.org>
                            " Last Change:	2016 Aug 29
                            
    1              0.000015 if exists("b:did_ftplugin")
                              finish
                            endif
                            
    1   0.000896   0.000467 runtime! ftplugin/sass.vim
    1              0.000017 setlocal comments=s1:/*,mb:*,ex:*/,://
                            
                            " vim:set sw=2:

SCRIPT  /usr/share/nvim/runtime/ftplugin/sass.vim
Sourced 1 time
Total time:   0.000393
 Self time:   0.000393

count  total (s)   self (s)
                            " Vim filetype plugin
                            " Language:	Sass
                            " Maintainer:	Tim Pope <vimNOSPAM@tpope.org>
                            " Last Change:	2016 Aug 29
                            
                            " Only do this when not done yet for this buffer
    1              0.000013 if exists("b:did_ftplugin")
                              finish
                            endif
    1              0.000010 let b:did_ftplugin = 1
                            
    1              0.000006 let b:undo_ftplugin = "setl com< cms< def< inc< inex< ofu< sua<"
                            
    1              0.000017 setlocal comments=://
    1              0.000010 setlocal commentstring=//\ %s
    1              0.000008 setlocal define=^\\s*\\%(@mixin\\\|=\\)
    1              0.000008 setlocal includeexpr=substitute(v:fname,'\\%(.*/\\\|^\\)\\zs','_','')
    1              0.000006 setlocal omnifunc=csscomplete#CompleteCSS
    1              0.000008 setlocal suffixesadd=.sass,.scss,.css
                            
    1              0.000011 let &l:include = '^\s*@import\s\+\%(url(\)\=["'']\='
                            
                            " vim:set sw=2:

SCRIPT  /usr/share/nvim/runtime/indent/scss.vim
Sourced 1 time
Total time:   0.001527
 Self time:   0.000842

count  total (s)   self (s)
                            " Vim indent file
                            " Language:	SCSS
                            " Maintainer:	Tim Pope <vimNOSPAM@tpope.org>
                            " Last Change:	2010 Jul 26
                            
    1              0.000017 if exists("b:did_indent")
                              finish
                            endif
                            
    1   0.001250   0.000566 runtime! indent/css.vim
                            
                            " vim:set sw=2:

SCRIPT  /usr/share/nvim/runtime/indent/css.vim
Sourced 1 time
Total time:   0.000659
 Self time:   0.000659

count  total (s)   self (s)
                            " Vim indent file
                            " Language:	    CSS
                            " Maintainer:	    Nikolai Weibull <now@bitwi.se>
                            " Latest Revision:  2012-05-30
                            "		    Use of shiftwidth() added by Oleg Zubchenko.	
                            
    1              0.000016 if exists("b:did_indent")
                              finish
                            endif
    1              0.000011 let b:did_indent = 1
                            
    1              0.000019 setlocal indentexpr=GetCSSIndent()
    1              0.000014 setlocal indentkeys=0{,0},!^F,o,O
    1              0.000017 setlocal nosmartindent
                            
    1              0.000012 let b:undo_indent = "setl smartindent< indentkeys< indentexpr<"
                            
    1              0.000013 if exists("*GetCSSIndent")
                              finish
                            endif
    1              0.000029 let s:keepcpo= &cpo
    1              0.000034 set cpo&vim
                            
    1              0.000013 function s:prevnonblanknoncomment(lnum)
                              let lnum = a:lnum
                              while lnum > 1
                                let lnum = prevnonblank(lnum)
                                let line = getline(lnum)
                                if line =~ '\*/'
                                  while lnum > 1 && line !~ '/\*'
                                    let lnum -= 1
                                  endwhile
                                  if line =~ '^\s*/\*'
                                    let lnum -= 1
                                  else
                                    break
                                  endif
                                else
                                  break
                                endif
                              endwhile
                              return lnum
                            endfunction
                            
    1              0.000012 function s:count_braces(lnum, count_open)
                              let n_open = 0
                              let n_close = 0
                              let line = getline(a:lnum)
                              let pattern = '[{}]'
                              let i = match(line, pattern)
                              while i != -1
                                if synIDattr(synID(a:lnum, i + 1, 0), 'name') !~ 'css\%(Comment\|StringQ\{1,2}\)'
                                  if line[i] == '{'
                                    let n_open += 1
                                  elseif line[i] == '}'
                                    if n_open > 0
                                      let n_open -= 1
                                    else
                                      let n_close += 1
                                    endif
                                  endif
                                endif
                                let i = match(line, pattern, i + 1)
                              endwhile
                              return a:count_open ? n_open : n_close
                            endfunction
                            
    1              0.000006 function GetCSSIndent()
                              let line = getline(v:lnum)
                              if line =~ '^\s*\*'
                                return cindent(v:lnum)
                              endif
                            
                              let pnum = s:prevnonblanknoncomment(v:lnum - 1)
                              if pnum == 0
                                return 0
                              endif
                            
                              return indent(pnum) + s:count_braces(pnum, 1) * shiftwidth()
                                    \ - s:count_braces(v:lnum, 0) * shiftwidth()
                            endfunction
                            
    1              0.000016 let &cpo = s:keepcpo
    1              0.000009 unlet s:keepcpo

SCRIPT  /usr/share/nvim/runtime/syntax/scss.vim
Sourced 1 time
Total time:   0.029424
 Self time:   0.000910

count  total (s)   self (s)
                            " Vim syntax file
                            " Language:	SCSS
                            " Maintainer:	Tim Pope <vimNOSPAM@tpope.org>
                            " Filenames:	*.scss
                            " Last Change:	2010 Jul 26
                            
    1              0.000018 if exists("b:current_syntax")
                              finish
                            endif
                            
    1   0.029108   0.000593 runtime! syntax/sass.vim
                            
    1              0.000013 syn match scssComment "//.*" contains=sassTodo,@Spell
    1              0.000015 syn region scssComment start="/\*" end="\*/" contains=sassTodo,@Spell
                            
    1              0.000005 hi def link scssComment sassComment
                            
    1              0.000006 let b:current_syntax = "scss"
                            
                            " vim:set sw=2:

SCRIPT  /usr/share/nvim/runtime/syntax/sass.vim
Sourced 1 time
Total time:   0.028486
 Self time:   0.009288

count  total (s)   self (s)
                            " Vim syntax file
                            " Language:	Sass
                            " Maintainer:	Tim Pope <vimNOSPAM@tpope.org>
                            " Filenames:	*.sass
                            " Last Change:	2016 Aug 29
                            
    1              0.000017 if exists("b:current_syntax")
                              finish
                            endif
                            
    1   0.019749   0.000550 runtime! syntax/css.vim
                            
    1              0.000006 syn case ignore
                            
    1              0.000044 syn cluster sassCssProperties contains=cssFontProp,cssFontDescriptorProp,cssColorProp,cssTextProp,cssBoxProp,cssGeneratedContentProp,cssPagingProp,cssUIProp,cssRenderProp,cssAuralProp,cssTableProp
    1              0.002303 syn cluster sassCssAttributes contains=css.*Attr,sassEndOfLineComment,scssComment,cssValue.*,cssColor,cssURL,sassDefault,cssImportant,cssError,cssStringQ,cssStringQQ,cssFunction,cssUnicodeEscape,cssRenderProp
                            
    1              0.000030 syn region sassDefinition matchgroup=cssBraces start="{" end="}" contains=TOP
                            
    1              0.001533 syn match sassProperty "\%([{};]\s*\|^\)\@<=\%([[:alnum:]-]\|#{[^{}]*}\)\+\s*:" contains=css.*Prop skipwhite nextgroup=sassCssAttribute contained containedin=sassDefinition
    1              0.001521 syn match sassProperty "^\s*\zs\s\%(\%([[:alnum:]-]\|#{[^{}]*}\)\+\s*:\|:[[:alnum:]-]\+\)"hs=s+1 contains=css.*Prop skipwhite nextgroup=sassCssAttribute
    1              0.001567 syn match sassProperty "^\s*\zs\s\%(:\=[[:alnum:]-]\+\s*=\)"hs=s+1 contains=css.*Prop skipwhite nextgroup=sassCssAttribute
    1              0.000055 syn match sassCssAttribute +\%("\%([^"]\|\\"\)*"\|'\%([^']\|\\'\)*'\|#{[^{}]*}\|[^{};]\)*+ contained contains=@sassCssAttributes,sassVariable,sassFunction,sassInterpolation
    1              0.000010 syn match sassDefault "!default\>" contained
    1              0.000021 syn match sassVariable "!\%(important\>\|default\>\)\@![[:alnum:]_-]\+"
    1              0.000009 syn match sassVariable "$[[:alnum:]_-]\+"
    1              0.000031 syn match sassVariableAssignment "\%([!$][[:alnum:]_-]\+\s*\)\@<=\%(||\)\==" nextgroup=sassCssAttribute skipwhite
    1              0.000015 syn match sassVariableAssignment "\%([!$][[:alnum:]_-]\+\s*\)\@<=:" nextgroup=sassCssAttribute skipwhite
                            
    1              0.000015 syn match sassFunction "\<\%(rgb\|rgba\|red\|green\|blue\|mix\)\>(\@=" contained
    1              0.000025 syn match sassFunction "\<\%(hsl\|hsla\|hue\|saturation\|lightness\|adjust-hue\|lighten\|darken\|saturate\|desaturate\|grayscale\|complement\)\>(\@=" contained
    1              0.000019 syn match sassFunction "\<\%(alpha\|opacity\|rgba\|opacify\|fade-in\|transparentize\|fade-out\)\>(\@=" contained
    1              0.000012 syn match sassFunction "\<\%(unquote\|quote\)\>(\@=" contained
    1              0.000014 syn match sassFunction "\<\%(percentage\|round\|ceil\|floor\|abs\)\>(\@=" contained
    1              0.000013 syn match sassFunction "\<\%(type-of\|unit\|unitless\|comparable\)\>(\@=" contained
                            
    1              0.000042 syn region sassInterpolation matchgroup=sassInterpolationDelimiter start="#{" end="}" contains=@sassCssAttributes,sassVariable,sassFunction containedin=cssStringQ,cssStringQQ,cssPseudoClass,sassProperty
                            
    1              0.000020 syn match sassMixinName "[[:alnum:]_-]\+" contained nextgroup=sassCssAttribute
    1              0.000018 syn match sassMixin  "^="               nextgroup=sassMixinName skipwhite
    1              0.000014 syn match sassMixin  "\%([{};]\s*\|^\s*\)\@<=@mixin"   nextgroup=sassMixinName skipwhite
    1              0.000018 syn match sassMixing "^\s\+\zs+"        nextgroup=sassMixinName
    1              0.000018 syn match sassMixing "\%([{};]\s*\|^\s*\)\@<=@include" nextgroup=sassMixinName skipwhite
    1              0.000021 syn match sassExtend "\%([{};]\s*\|^\s*\)\@<=@extend"
    1              0.000020 syn match sassPlaceholder "\%([{};]\s*\|^\s*\)\@<=%"   nextgroup=sassMixinName skipwhite
                            
    1              0.000023 syn match sassFunctionName "[[:alnum:]_-]\+" contained nextgroup=sassCssAttribute
    1              0.000023 syn match sassFunctionDecl "\%([{};]\s*\|^\s*\)\@<=@function"   nextgroup=sassFunctionName skipwhite
    1              0.000019 syn match sassReturn "\%([{};]\s*\|^\s*\)\@<=@return"
                            
    1              0.000016 syn match sassEscape     "^\s*\zs\\"
    1              0.000037 syn match sassIdChar     "#[[:alnum:]_-]\@=" nextgroup=sassId
    1              0.000011 syn match sassId         "[[:alnum:]_-]\+" contained
    1              0.000027 syn match sassClassChar  "\.[[:alnum:]_-]\@=" nextgroup=sassClass
    1              0.000009 syn match sassClass      "[[:alnum:]_-]\+" contained
    1              0.000015 syn match sassAmpersand  "&"
                            
                            " TODO: Attribute namespaces
                            " TODO: Arithmetic (including strings and concatenation)
                            
    1              0.000043 syn region sassMediaQuery matchgroup=sassMedia start="@media" end="[{};]\@=\|$" contains=sassMediaOperators
    1              0.000010 syn keyword sassMediaOperators and not only contained
    1              0.000044 syn region sassCharset start="@charset" end=";\|$" contains=scssComment,cssStringQ,cssStringQQ,cssURL,cssUnicodeEscape,cssMediaType
    1              0.000053 syn region sassInclude start="@import" end=";\|$" contains=scssComment,cssStringQ,cssStringQQ,cssURL,cssUnicodeEscape,cssMediaType
    1              0.000035 syn region sassDebugLine end=";\|$" matchgroup=sassDebug start="@debug\>" contains=@sassCssAttributes,sassVariable,sassFunction
    1              0.000035 syn region sassWarnLine end=";\|$" matchgroup=sassWarn start="@warn\>" contains=@sassCssAttributes,sassVariable,sassFunction
    1              0.000054 syn region sassControlLine matchgroup=sassControl start="@\%(if\|else\%(\s\+if\)\=\|while\|for\|each\)\>" end="[{};]\@=\|$" contains=sassFor,@sassCssAttributes,sassVariable,sassFunction
    1              0.000010 syn keyword sassFor from to through in contained
                            
    1              0.000018 syn keyword sassTodo        FIXME NOTE TODO OPTIMIZE XXX contained
    1              0.000024 syn region  sassComment     start="^\z(\s*\)//"  end="^\%(\z1 \)\@!" contains=sassTodo,@Spell
    1              0.000036 syn region  sassCssComment  start="^\z(\s*\)/\*" end="^\%(\z1 \)\@!" contains=sassTodo,@Spell
    1              0.000013 syn match   sassEndOfLineComment "//.*" contains=sassComment,sassTodo,@Spell
                            
    1              0.000006 hi def link sassEndOfLineComment        sassComment
    1              0.000004 hi def link sassCssComment              sassComment
    1              0.000010 hi def link sassComment                 Comment
    1              0.000006 hi def link sassDefault                 cssImportant
    1              0.000011 hi def link sassVariable                Identifier
    1              0.000010 hi def link sassFunction                Function
    1              0.000010 hi def link sassMixing                  PreProc
    1              0.000010 hi def link sassMixin                   PreProc
    1              0.000010 hi def link sassPlaceholder             PreProc
    1              0.000010 hi def link sassExtend                  PreProc
    1              0.000010 hi def link sassFunctionDecl            PreProc
    1              0.000010 hi def link sassReturn                  PreProc
    1              0.000010 hi def link sassTodo                    Todo
    1              0.000010 hi def link sassCharset                 PreProc
    1              0.000016 hi def link sassMedia                   PreProc
    1              0.000010 hi def link sassMediaOperators          PreProc
    1              0.000010 hi def link sassInclude                 Include
    1              0.000004 hi def link sassDebug                   sassControl
    1              0.000004 hi def link sassWarn                    sassControl
    1              0.000010 hi def link sassControl                 PreProc
    1              0.000010 hi def link sassFor                     PreProc
    1              0.000010 hi def link sassEscape                  Special
    1              0.000010 hi def link sassIdChar                  Special
    1              0.000010 hi def link sassClassChar               Special
    1              0.000012 hi def link sassInterpolationDelimiter  Delimiter
    1              0.000010 hi def link sassAmpersand               Character
    1              0.000012 hi def link sassId                      Identifier
    1              0.000011 hi def link sassClass                   Type
                            
    1              0.000008 let b:current_syntax = "sass"
                            
                            " vim:set sw=2:

SCRIPT  /usr/share/nvim/runtime/syntax/css.vim
Sourced 1 time
Total time:   0.019175
 Self time:   0.019175

count  total (s)   self (s)
                            " Vim syntax file
                            " Language:     Cascading Style Sheets
                            " Previous Contributor List:
                            "               Claudio Fleiner <claudio@fleiner.com> (Maintainer)
                            "               Yeti            (Add full CSS2, HTML4 support)
                            "               Nikolai Weibull (Add CSS2 support)
                            " Maintainer:   Jules Wang      <w.jq0722@gmail.com>
                            " URL:          https://github.com/JulesWang/css.vim
                            " Last Change:  2017 Jan 14
                            "  		cssClassName updated by Ryuichi Hayashida Jan 2016
                            
                            " quit when a syntax file was already loaded
    1              0.000017 if !exists("main_syntax")
    1              0.000011   if exists("b:current_syntax")
                                finish
                              endif
    1              0.000017   let main_syntax = 'css'
    1              0.000013 elseif exists("b:current_syntax") && b:current_syntax == "css"
                              finish
                            endif
                            
    1              0.000035 let s:cpo_save = &cpo
    1              0.000026 set cpo&vim
                            
    1              0.000009 syn case ignore
                            
                            " HTML4 tags
    1              0.000058 syn keyword cssTagName abbr address area a b base
    1              0.000009 syn keyword cssTagName bdo blockquote body br button
    1              0.000011 syn keyword cssTagName caption cite code col colgroup dd del
    1              0.000009 syn keyword cssTagName dfn div dl dt em fieldset form
    1              0.000011 syn keyword cssTagName h1 h2 h3 h4 h5 h6 head hr html img i
    1              0.000014 syn keyword cssTagName iframe input ins isindex kbd label legend li
    1              0.000019 syn keyword cssTagName link map menu meta noscript ol optgroup
    1              0.000010 syn keyword cssTagName option p param pre q s samp script small
    1              0.000008 syn keyword cssTagName span strong sub sup tbody td
    1              0.000009 syn keyword cssTagName textarea tfoot th thead title tr ul u var
    1              0.000006 syn keyword cssTagName object svg
    1              0.000017 syn match   cssTagName /\<select\>\|\<style\>\|\<table\>/
                            
                            " 34 HTML5 tags
    1              0.000009 syn keyword cssTagName article aside audio bdi canvas command data
    1              0.000010 syn keyword cssTagName datalist details dialog embed figcaption figure footer
    1              0.000010 syn keyword cssTagName header hgroup keygen main mark menuitem meter nav
    1              0.000008 syn keyword cssTagName output progress rt rp ruby section
    1              0.000014 syn keyword cssTagName source summary time track video wbr
                            
                            " Tags not supported in HTML5
                            " acronym applet basefont big center dir
                            " font frame frameset noframes strike tt
                            
    1              0.000009 syn match cssTagName "\*"
                            
                            " selectors
    1              0.000018 syn match cssSelectorOp "[,>+~]"
    1              0.000017 syn match cssSelectorOp2 "[~|^$*]\?=" contained
    1              0.000053 syn region cssAttributeSelector matchgroup=cssSelectorOp start="\[" end="]" contains=cssUnicodeEscape,cssSelectorOp2,cssStringQ,cssStringQQ
                            
                            " .class and #id
    1              0.000033 syn match cssClassName "\.-\=[A-Za-z_][A-Za-z0-9_-]*" contains=cssClassNameDot
    1              0.000009 syn match cssClassNameDot contained '\.'
                            
    1              0.000004 try
    1              0.000020 syn match cssIdentifier "#[A-Za-zÀ-ÿ_@][A-Za-zÀ-ÿ0-9_@-]*"
    1              0.000004 catch /^.*/
                            syn match cssIdentifier "#[A-Za-z_@][A-Za-z0-9_@-]*"
                            endtry
                            
                            " digits
    1              0.000083 syn match cssValueInteger contained "[-+]\=\d\+" contains=cssUnitDecorators
    1              0.000024 syn match cssValueNumber contained "[-+]\=\d\+\(\.\d*\)\=" contains=cssUnitDecorators
    1              0.000030 syn match cssValueLength contained "[-+]\=\d\+\(\.\d*\)\=\(%\|mm\|cm\|in\|pt\|pc\|em\|ex\|px\|rem\|dpi\|dppx\|dpcm\)\>" contains=cssUnitDecorators
    1              0.000023 syn match cssValueAngle contained "[-+]\=\d\+\(\.\d*\)\=\(deg\|grad\|rad\)\>" contains=cssUnitDecorators
    1              0.000020 syn match cssValueTime contained "+\=\d\+\(\.\d*\)\=\(ms\|s\)\>" contains=cssUnitDecorators
    1              0.000020 syn match cssValueFrequency contained "+\=\d\+\(\.\d*\)\=\(Hz\|kHz\)\>" contains=cssUnitDecorators
                            
                            
    1              0.000029 syn match cssIncludeKeyword /@\(-[a-z]\+-\)\=\(media\|keyframes\|import\|charset\|namespace\|page\)/ contained
                            " @media
    1              0.000095 syn region cssInclude start=/@media\>/ end=/\ze{/ skipwhite skipnl contains=cssMediaProp,cssValueLength,cssMediaKeyword,cssValueInteger,cssMediaAttr,cssVendor,cssMediaType,cssIncludeKeyword,cssMediaComma,cssComment nextgroup=cssMediaBlock
    1              0.000015 syn keyword cssMediaType contained screen print aural braille embossed handheld projection tty tv speech all contained skipwhite skipnl
    1              0.000009 syn keyword cssMediaKeyword only not and contained
    1              0.001741 syn region cssMediaBlock transparent matchgroup=cssBraces start='{' end='}' contains=css.*Attr,css.*Prop,cssComment,cssValue.*,cssColor,cssURL,cssImportant,cssError,cssStringQ,cssStringQQ,cssFunction,cssUnicodeEscape,cssVendor,cssDefinition,cssTagName,cssClassName,cssIdentifier,cssPseudoClass,cssSelectorOp,cssSelectorOp2,cssAttributeSelector fold
    1              0.000014 syn match cssMediaComma "," skipwhite skipnl contained
                            
                            " Reference: http://www.w3.org/TR/css3-mediaqueries/
    1              0.000012 syn keyword cssMediaProp contained width height orientation scan grid
    1              0.000017 syn match cssMediaProp contained /\(\(max\|min\)-\)\=\(\(device\)-\)\=aspect-ratio/
    1              0.000013 syn match cssMediaProp contained /\(\(max\|min\)-\)\=device-pixel-ratio/
    1              0.000013 syn match cssMediaProp contained /\(\(max\|min\)-\)\=device-\(height\|width\)/
    1              0.000019 syn match cssMediaProp contained /\(\(max\|min\)-\)\=\(height\|width\|resolution\|monochrome\|color\(-index\)\=\)/
    1              0.000009 syn keyword cssMediaAttr contained portrait landscape progressive interlace
                            
                            " @page
                            " http://www.w3.org/TR/css3-page/
    1              0.000040 syn match cssPage "@page\>[^{]*{\@=" contains=cssPagePseudo,cssIncludeKeyword nextgroup=cssPageWrap transparent skipwhite skipnl
    1              0.000015 syn match cssPagePseudo /:\(left\|right\|first\|blank\)/ contained skipwhite skipnl
    1              0.001167 syn region cssPageWrap contained transparent matchgroup=cssBraces start="{" end="}" contains=cssPageMargin,cssPageProp,cssAttrRegion,css.*Prop,cssComment,cssValue.*,cssColor,cssURL,cssImportant,cssError,cssStringQ,cssStringQQ,cssFunction,cssUnicodeEscape,cssVendor,cssDefinition,cssHacks
    1              0.000025 syn match cssPageMargin /@\(\(top\|left\|right\|bottom\)-\(left\|center\|right\|middle\|bottom\)\)\(-corner\)\=/ contained nextgroup=cssDefinition skipwhite skipnl
    1              0.000008 syn keyword cssPageProp contained content size
                            " http://www.w3.org/TR/CSS2/page.html#break-inside
    1              0.000007 syn keyword cssPageProp contained orphans widows
                            
                            " @keyframe
                            " http://www.w3.org/TR/css3-animations/#keyframes
    1              0.000041 syn match cssKeyFrame "@\(-[a-z]\+-\)\=keyframes\>[^{]*{\@=" nextgroup=cssKeyFrameWrap contains=cssVendor,cssIncludeKeyword skipwhite skipnl transparent
    1              0.000023 syn region cssKeyFrameWrap contained transparent matchgroup=cssBraces start="{" end="}" contains=cssKeyFrameSelector
    1              0.000013 syn match cssKeyFrameSelector /\(\d*%\|from\|to\)\=/  contained skipwhite skipnl nextgroup=cssDefinition
                            
                            " @import
    1              0.000041 syn region cssInclude start=/@import\>/    end=/\ze;/ transparent contains=cssStringQ,cssStringQQ,cssUnicodeEscape,cssComment,cssIncludeKeyword,cssURL,cssMediaProp,cssValueLength,cssMediaKeyword,cssValueInteger,cssMediaAttr,cssVendor,cssMediaType
    1              0.000023 syn region cssInclude start=/@charset\>/   end=/\ze;/ transparent contains=cssStringQ,cssStringQQ,cssUnicodeEscape,cssComment,cssIncludeKeyword
    1              0.000021 syn region cssInclude start=/@namespace\>/ end=/\ze;/ transparent contains=cssStringQ,cssStringQQ,cssUnicodeEscape,cssComment,cssIncludeKeyword
                            
                            " @font-face
                            " http://www.w3.org/TR/css3-fonts/#at-font-face-rule
    1              0.000032 syn match cssFontDescriptor "@font-face\>" nextgroup=cssFontDescriptorBlock skipwhite skipnl
    1              0.000559 syn region cssFontDescriptorBlock contained transparent matchgroup=cssBraces start="{" end="}" contains=cssComment,cssError,cssUnicodeEscape,cssCommonAttr,cssFontDescriptorProp,cssValue.*,cssFontDescriptorFunction,cssFontDescriptorAttr,cssNoise
                            
    1              0.000011 syn match cssFontDescriptorProp contained "\<font-family\>"
    1              0.000012 syn keyword cssFontDescriptorProp contained src
    1              0.000015 syn match cssFontDescriptorProp contained "\<font-\(style\|weight\|stretch\)\>"
    1              0.000010 syn match cssFontDescriptorProp contained "\<unicode-range\>"
    1              0.000012 syn match cssFontDescriptorProp contained "\<font-\(variant\|feature-settings\)\>"
                            
                            " src functions
    1              0.000029 syn region cssFontDescriptorFunction contained matchgroup=cssFunctionName start="\<\(uri\|url\|local\|format\)\s*(" end=")" contains=cssStringQ,cssStringQQ oneline keepend
                            " font-sytle and font-weight attributes
    1              0.000009 syn keyword cssFontDescriptorAttr contained normal italic oblique bold
                            " font-stretch attributes
    1              0.000017 syn match cssFontDescriptorAttr contained "\<\(\(ultra\|extra\|semi\)-\)\=\(condensed\|expanded\)\>"
                            " unicode-range attributes
    1              0.000016 syn match cssFontDescriptorAttr contained "U+[0-9A-Fa-f?]\+"
    1              0.000010 syn match cssFontDescriptorAttr contained "U+\x\+-\x\+"
                            " font-feature-settings attributes
    1              0.000006 syn keyword cssFontDescriptorAttr contained on off
                            
                            
                            
                            " The 16 basic color names
    1              0.000029 syn keyword cssColor contained aqua black blue fuchsia gray green lime maroon navy olive purple red silver teal yellow
                            
                            " 130 more color names
    1              0.000008 syn keyword cssColor contained aliceblue antiquewhite aquamarine azure
    1              0.000018 syn keyword cssColor contained beige bisque blanchedalmond blueviolet brown burlywood
    1              0.000063 syn keyword cssColor contained cadetblue chartreuse chocolate coral cornflowerblue cornsilk crimson cyan
    1              0.000018 syn match cssColor contained /\<dark\(blue\|cyan\|goldenrod\|gray\|green\|grey\|khaki\)\>/
    1              0.000017 syn match cssColor contained /\<dark\(magenta\|olivegreen\|orange\|orchid\|red\|salmon\|seagreen\)\>/
    1              0.000012 syn match cssColor contained /\<darkslate\(blue\|gray\|grey\)\>/
    1              0.000012 syn match cssColor contained /\<dark\(turquoise\|violet\)\>/
    1              0.000045 syn keyword cssColor contained deeppink deepskyblue dimgray dimgrey dodgerblue firebrick
    1              0.000038 syn keyword cssColor contained floralwhite forestgreen gainsboro ghostwhite gold
    1              0.000045 syn keyword cssColor contained goldenrod greenyellow grey honeydew hotpink
    1              0.000052 syn keyword cssColor contained indianred indigo ivory khaki lavender lavenderblush lawngreen
    1              0.000028 syn keyword cssColor contained lemonchiffon limegreen linen magenta
    1              0.000016 syn match cssColor contained /\<light\(blue\|coral\|cyan\|goldenrodyellow\|gray\|green\)\>/
    1              0.000019 syn match cssColor contained /\<light\(grey\|pink\|salmon\|seagreen\|skyblue\|yellow\)\>/
    1              0.000014 syn match cssColor contained /\<light\(slategray\|slategrey\|steelblue\)\>/
    1              0.000017 syn match cssColor contained /\<medium\(aquamarine\|blue\|orchid\|purple\|seagreen\)\>/
    1              0.000020 syn match cssColor contained /\<medium\(slateblue\|springgreen\|turquoise\|violetred\)\>/
    1              0.000009 syn keyword cssColor contained midnightblue mintcream mistyrose moccasin navajowhite
    1              0.000009 syn keyword cssColor contained oldlace olivedrab orange orangered orchid
    1              0.000015 syn match cssColor contained /\<pale\(goldenrod\|green\|turquoise\|violetred\)\>/
    1              0.000009 syn keyword cssColor contained papayawhip peachpuff peru pink plum powderblue
    1              0.000009 syn keyword cssColor contained rosybrown royalblue saddlebrown salmon sandybrown
    1              0.000009 syn keyword cssColor contained seagreen seashell sienna skyblue slateblue
    1              0.000009 syn keyword cssColor contained slategray slategrey snow springgreen steelblue tan
    1              0.000008 syn keyword cssColor contained thistle tomato turquoise violet wheat
    1              0.000007 syn keyword cssColor contained whitesmoke yellowgreen
                            
                            " FIXME: These are actually case-insensitive too, but (a) specs recommend using
                            " mixed-case (b) it's hard to highlight the word `Background' correctly in
                            " all situations
    1              0.000006 syn case match
    1              0.000021 syn keyword cssColor contained ActiveBorder ActiveCaption AppWorkspace ButtonFace ButtonHighlight ButtonShadow ButtonText CaptionText GrayText Highlight HighlightText InactiveBorder InactiveCaption InactiveCaptionText InfoBackground InfoText Menu MenuText Scrollbar ThreeDDarkShadow ThreeDFace ThreeDHighlight ThreeDLightShadow ThreeDShadow Window WindowFrame WindowText Background
    1              0.000004 syn case ignore
                            
    1              0.000010 syn match cssImportant contained "!\s*important\>"
                            
    1              0.000010 syn match cssColor contained "\<transparent\>"
    1              0.000009 syn match cssColor contained "\<currentColor\>"
    1              0.000008 syn match cssColor contained "\<white\>"
    1              0.000016 syn match cssColor contained "#[0-9A-Fa-f]\{3\}\>" contains=cssUnitDecorators
    1              0.000013 syn match cssColor contained "#[0-9A-Fa-f]\{6\}\>" contains=cssUnitDecorators
                            
    1              0.000020 syn region cssURL contained matchgroup=cssFunctionName start="\<url\s*(" end=")" contains=cssStringQ,cssStringQQ oneline
    1              0.000058 syn region cssFunction contained matchgroup=cssFunctionName start="\<\(rgb\|clip\|attr\|counter\|rect\|cubic-bezier\|steps\)\s*(" end=")" oneline  contains=cssValueInteger,cssValueNumber,cssValueLength,cssFunctionComma
    1              0.000032 syn region cssFunction contained matchgroup=cssFunctionName start="\<\(rgba\|hsl\|hsla\|color-stop\|from\|to\)\s*(" end=")" oneline  contains=cssColor,cssValueInteger,cssValueNumber,cssValueLength,cssFunctionComma,cssFunction
    1              0.000043 syn region cssFunction contained matchgroup=cssFunctionName start="\<\(linear-\|radial-\)\=\gradient\s*(" end=")" oneline  contains=cssColor,cssValueInteger,cssValueNumber,cssValueLength,cssFunction,cssGradientAttr,cssFunctionComma
    1              0.000040 syn region cssFunction contained matchgroup=cssFunctionName start="\<\(matrix\(3d\)\=\|scale\(3d\|X\|Y\|Z\)\=\|translate\(3d\|X\|Y\|Z\)\=\|skew\(X\|Y\)\=\|rotate\(3d\|X\|Y\|Z\)\=\|perspective\)\s*(" end=")" oneline contains=cssValueInteger,cssValueNumber,cssValueLength,cssValueAngle,cssFunctionComma
    1              0.000014 syn keyword cssGradientAttr contained top bottom left right cover center middle ellipse at
    1              0.000007 syn match cssFunctionComma contained ","
                            
                            " Common Prop and Attr
    1              0.000010 syn keyword cssCommonAttr contained auto none inherit all default normal
    1              0.000010 syn keyword cssCommonAttr contained top bottom center stretch hidden visible
                            "------------------------------------------------
                            " CSS Animations
                            " http://www.w3.org/TR/css3-animations/
    1              0.000031 syn match cssAnimationProp contained "\<animation\(-\(delay\|direction\|duration\|fill-mode\|name\|play-state\|timing-function\|iteration-count\)\)\=\>"
                            
                            " animation-direction attributes
    1              0.000014 syn keyword cssAnimationAttr contained alternate reverse
    1              0.000013 syn match cssAnimationAttr contained "\<alternate-reverse\>"
                            
                            " animation-fill-mode attributes
    1              0.000007 syn keyword cssAnimationAttr contained forwards backwards both
                            
                            " animation-play-state attributes
    1              0.000006 syn keyword cssAnimationAttr contained running paused
                            
                            " animation-iteration-count attributes
    1              0.000005 syn keyword cssAnimationAttr contained infinite
                            "------------------------------------------------
                            "  CSS Backgrounds and Borders Module Level 3
                            "  http://www.w3.org/TR/css3-background/
    1              0.000032 syn match cssBackgroundProp contained "\<background\(-\(attachment\|clip\|color\|image\|origin\|position\|repeat\|size\)\)\=\>"
                            " background-attachment attributes
    1              0.000016 syn keyword cssBackgroundAttr contained scroll fixed local
                            
                            " background-position attributes
    1              0.000008 syn keyword cssBackgroundAttr contained left center right top bottom
                            
                            " background-repeat attributes
    1              0.000012 syn match cssBackgroundAttr contained "\<no-repeat\>"
    1              0.000014 syn match cssBackgroundAttr contained "\<repeat\(-[xy]\)\=\>"
    1              0.000007 syn keyword cssBackgroundAttr contained space round
                            
                            " background-size attributes
    1              0.000006 syn keyword cssBackgroundAttr contained cover contain
                            
    1              0.000025 syn match cssBorderProp contained "\<border\(-\(top\|right\|bottom\|left\)\)\=\(-\(width\|color\|style\)\)\=\>"
    1              0.000015 syn match cssBorderProp contained "\<border\(-\(top\|bottom\)-\(left\|right\)\)\=-radius\>"
    1              0.000017 syn match cssBorderProp contained "\<border-image\(-\(outset\|repeat\|slice\|source\|width\)\)\=\>"
    1              0.000011 syn match cssBorderProp contained "\<box-decoration-break\>"
    1              0.000012 syn match cssBorderProp contained "\<box-shadow\>"
                            
                            " border-image attributes
    1              0.000016 syn keyword cssBorderAttr contained stretch round space fill
                            
                            " border-style attributes
    1              0.000012 syn keyword cssBorderAttr contained dotted dashed solid double groove ridge inset outset
                            
                            " border-width attributes
    1              0.000007 syn keyword cssBorderAttr contained thin thick medium
                            
                            " box-decoration-break attributes
    1              0.000006 syn keyword cssBorderAttr contained clone slice
                            "------------------------------------------------
                            
    1              0.000022 syn match cssBoxProp contained "\<padding\(-\(top\|right\|bottom\|left\)\)\=\>"
    1              0.000014 syn match cssBoxProp contained "\<margin\(-\(top\|right\|bottom\|left\)\)\=\>"
    1              0.000012 syn match cssBoxProp contained "\<overflow\(-\(x\|y\|style\)\)\=\>"
    1              0.000010 syn match cssBoxProp contained "\<rotation\(-point\)\=\>"
    1              0.000015 syn keyword cssBoxAttr contained visible hidden scroll auto
    1              0.000010 syn match cssBoxAttr contained "\<no-\(display\|content\)\>"
                            
    1              0.000013 syn keyword cssColorProp contained opacity
    1              0.000009 syn match cssColorProp contained "\<color-profile\>"
    1              0.000014 syn match cssColorProp contained "\<rendering-intent\>"
                            
                            
    1              0.000020 syn match cssDimensionProp contained "\<\(min\|max\)-\(width\|height\)\>"
    1              0.000006 syn keyword cssDimensionProp contained height
    1              0.000005 syn keyword cssDimensionProp contained width
                            
                            " shadow and sizing are in other property groups
    1              0.000026 syn match cssFlexibleBoxProp contained "\<box-\(align\|direction\|flex\|ordinal-group\|orient\|pack\|shadow\|sizing\)\>"
    1              0.000015 syn keyword cssFlexibleBoxAttr contained start end baseline
    1              0.000005 syn keyword cssFlexibleBoxAttr contained reverse
    1              0.000009 syn keyword cssFlexibleBoxAttr contained single multiple
    1              0.000006 syn keyword cssFlexibleBoxAttr contained horizontal
    1              0.000011 syn match cssFlexibleBoxAttr contained "\<vertical\(-align\)\@!\>" "escape vertical-align
    1              0.000013 syn match cssFlexibleBoxAttr contained "\<\(inline\|block\)-axis\>"
                            
                            " CSS Fonts Module Level 3
                            " http://www.w3.org/TR/css-fonts-3/
    1              0.000074 syn match cssFontProp contained "\<font\(-\(family\|\|feature-settings\|kerning\|language-override\|size\(-adjust\)\=\|stretch\|style\|synthesis\|variant\(-\(alternates\|caps\|east-asian\|ligatures\|numeric\|position\)\)\=\|weight\)\)\=\>"
                            
                            " font attributes
    1              0.000021 syn keyword cssFontAttr contained icon menu caption
    1              0.000019 syn match cssFontAttr contained "\<small-\(caps\|caption\)\>"
    1              0.000009 syn match cssFontAttr contained "\<message-box\>"
    1              0.000008 syn match cssFontAttr contained "\<status-bar\>"
    1              0.000007 syn keyword cssFontAttr contained larger smaller
    1              0.000015 syn match cssFontAttr contained "\<\(x\{1,2\}-\)\=\(large\|small\)\>"
                            " font-family attributes
    1              0.000011 syn match cssFontAttr contained "\<\(sans-\)\=serif\>"
    1              0.000027 syn keyword cssFontAttr contained Antiqua Arial Black Book Charcoal Comic Courier Dingbats Gadget Geneva Georgia Grande Helvetica Impact Linotype Lucida MS Monaco Neue New Palatino Roboto Roman Symbol Tahoma Times Trebuchet Verdana Webdings Wingdings York Zapf
    1              0.000009 syn keyword cssFontAttr contained cursive fantasy monospace
                            " font-feature-settings attributes
    1              0.000006 syn keyword cssFontAttr contained on off
                            " font-stretch attributes
    1              0.000015 syn match cssFontAttr contained "\<\(\(ultra\|extra\|semi\)-\)\=\(condensed\|expanded\)\>"
                            " font-style attributes
    1              0.000006 syn keyword cssFontAttr contained italic oblique
                            " font-synthesis attributes
    1              0.000006 syn keyword cssFontAttr contained weight style
                            " font-weight attributes
    1              0.000006 syn keyword cssFontAttr contained bold bolder lighter
                            " TODO: font-variant-* attributes
                            "------------------------------------------------
                            
                            " Webkit specific property/attributes
    1              0.000009 syn match cssFontProp contained "\<font-smooth\>"
    1              0.000014 syn match cssFontAttr contained "\<\(subpixel-\)\=\antialiased\>"
                            
                            
                            " CSS Multi-column Layout Module
                            " http://www.w3.org/TR/css3-multicol/
    1              0.000022 syn match cssMultiColumnProp contained "\<break-\(after\|before\|inside\)\>"
    1              0.000020 syn match cssMultiColumnProp contained "\<column-\(count\|fill\|gap\|rule\(-\(color\|style\|width\)\)\=\|span\|width\)\>"
    1              0.000012 syn keyword cssMultiColumnProp contained columns
    1              0.000015 syn keyword cssMultiColumnAttr contained balance medium
    1              0.000008 syn keyword cssMultiColumnAttr contained always avoid left right page column
    1              0.000011 syn match cssMultiColumnAttr contained "\<avoid-\(page\|column\)\>"
                            
                            " http://www.w3.org/TR/css3-break/#page-break
    1              0.000013 syn match cssMultiColumnProp contained "\<page\(-break-\(before\|after\|inside\)\)\=\>"
                            
                            " TODO find following items in w3c docs.
    1              0.000015 syn keyword cssGeneratedContentProp contained quotes crop
    1              0.000012 syn match cssGeneratedContentProp contained "\<counter-\(reset\|increment\)\>"
    1              0.000008 syn match cssGeneratedContentProp contained "\<move-to\>"
    1              0.000009 syn match cssGeneratedContentProp contained "\<page-policy\>"
    1              0.000023 syn match cssGeneratedContentAttr contained "\<\(no-\)\=\(open\|close\)-quote\>"
                            
    1              0.000018 syn match cssGridProp contained "\<grid-\(columns\|rows\)\>"
                            
    1              0.000019 syn match cssHyerlinkProp contained "\<target\(-\(name\|new\|position\)\)\=\>"
                            
    1              0.000020 syn match cssListProp contained "\<list-style\(-\(type\|position\|image\)\)\=\>"
    1              0.000035 syn match cssListAttr contained "\<\(lower\|upper\)-\(roman\|alpha\|greek\|latin\)\>"
    1              0.000017 syn match cssListAttr contained "\<\(hiragana\|katakana\)\(-iroha\)\=\>"
    1              0.000019 syn match cssListAttr contained "\<\(decimal\(-leading-zero\)\=\|cjk-ideographic\)\>"
    1              0.000011 syn keyword cssListAttr contained disc circle square hebrew armenian georgian
    1              0.000006 syn keyword cssListAttr contained inside outside
                            
    1              0.000017 syn keyword cssPositioningProp contained bottom clear clip display float left
    1              0.000007 syn keyword cssPositioningProp contained position right top visibility
    1              0.000009 syn match cssPositioningProp contained "\<z-index\>"
    1              0.000017 syn keyword cssPositioningAttr contained block compact
    1              0.000021 syn match cssPositioningAttr contained "\<table\(-\(row-group\|\(header\|footer\)-group\|row\|column\(-group\)\=\|cell\|caption\)\)\=\>"
    1              0.000007 syn keyword cssPositioningAttr contained left right both
    1              0.000015 syn match cssPositioningAttr contained "\<list-item\>"
    1              0.000012 syn match cssPositioningAttr contained "\<inline\(-\(block\|box\|table\)\)\=\>"
    1              0.000008 syn keyword cssPositioningAttr contained static relative absolute fixed
                            
    1              0.000017 syn keyword cssPrintAttr contained landscape portrait crop cross always avoid
                            
    1              0.000027 syn match cssTableProp contained "\<\(caption-side\|table-layout\|border-collapse\|border-spacing\|empty-cells\)\>"
    1              0.000019 syn keyword cssTableAttr contained fixed collapse separate show hide once always
                            
                            
    1              0.000014 syn keyword cssTextProp contained color direction
    1              0.000032 syn match cssTextProp "\<\(\(word\|letter\)-spacing\|text\(-\(decoration\|transform\|align\|index\|shadow\)\)\=\|vertical-align\|unicode-bidi\|line-height\)\>"
    1              0.000020 syn match cssTextProp contained "\<text-\(justify\|outline\|warp\|align-last\|size-adjust\|rendering\|stroke\|indent\)\>"
    1              0.000011 syn match cssTextProp contained "\<word-\(break\|\wrap\)\>"
    1              0.000013 syn match cssTextProp contained "\<white-space\>"
    1              0.000011 syn match cssTextProp contained "\<hanging-punctuation\>"
    1              0.000009 syn match cssTextProp contained "\<punctuation-trim\>"
    1              0.000016 syn match cssTextAttr contained "\<line-through\>"
    1              0.000013 syn match cssTextAttr contained "\<\(text-\)\=\(top\|bottom\)\>"
    1              0.000008 syn keyword cssTextAttr contained ltr rtl embed nowrap
    1              0.000009 syn keyword cssTextAttr contained underline overline blink sub super middle
    1              0.000007 syn keyword cssTextAttr contained capitalize uppercase lowercase
    1              0.000007 syn keyword cssTextAttr contained justify baseline sub super
    1              0.000007 syn keyword cssTextAttr contained optimizeLegibility optimizeSpeed
    1              0.000015 syn match cssTextAttr contained "\<pre\(-\(line\|wrap\)\)\=\>"
    1              0.000011 syn match cssTextAttr contained "\<\(allow\|force\)-end\>"
    1              0.000007 syn keyword cssTextAttr contained start end adjacent
    1              0.000012 syn match cssTextAttr contained "\<inter-\(word\|ideographic\|cluster\)\>"
    1              0.000008 syn keyword cssTextAttr contained distribute kashida first last
    1              0.000009 syn keyword cssTextAttr contained clip ellipsis unrestricted suppress
    1              0.000008 syn match cssTextAttr contained "\<break-all\>"
    1              0.000009 syn match cssTextAttr contained "\<break-word\>"
    1              0.000011 syn keyword cssTextAttr contained hyphenate
    1              0.000010 syn match cssTextAttr contained "\<bidi-override\>"
                            
    1              0.000023 syn match cssTransformProp contained "\<transform\(-\(origin\|style\)\)\=\>"
    1              0.000015 syn match cssTransformProp contained "\<perspective\(-origin\)\=\>"
    1              0.000010 syn match cssTransformProp contained "\<backface-visibility\>"
                            
                            " CSS Transitions
                            " http://www.w3.org/TR/css3-transitions/
    1              0.000024 syn match cssTransitionProp contained "\<transition\(-\(delay\|duration\|property\|timing-function\)\)\=\>"
                            
                            " transition-time-function attributes
    1              0.000019 syn match cssTransitionAttr contained "\<linear\(-gradient\)\@!\>"
    1              0.000015 syn match cssTransitionAttr contained "\<ease\(-\(in-out\|out\|in\)\)\=\>"
    1              0.000011 syn match cssTransitionAttr contained "\<step\(-start\|-end\)\=\>"
                            "------------------------------------------------
                            " CSS Basic User Interface Module Level 3 (CSS3 UI)
                            " http://www.w3.org/TR/css3-ui/
    1              0.000018 syn match cssUIProp contained "\<box-sizing\>"
    1              0.000030 syn match cssUIAttr contained "\<\(content\|padding\|border\)\(-box\)\=\>"
                            
    1              0.000006 syn keyword cssUIProp contained cursor
    1              0.000015 syn match cssUIAttr contained "\<\(\([ns]\=[ew]\=\)\|col\|row\|nesw\|nwse\)-resize\>"
    1              0.000009 syn keyword cssUIAttr contained crosshair help move pointer alias copy
    1              0.000009 syn keyword cssUIAttr contained progress wait text cell move
    1              0.000009 syn match cssUIAttr contained "\<context-menu\>"
    1              0.000008 syn match cssUIAttr contained "\<no-drop\>"
    1              0.000009 syn match cssUIAttr contained "\<not-allowed\>"
    1              0.000012 syn match cssUIAttr contained "\<all-scroll\>"
    1              0.000011 syn match cssUIAttr contained "\<\(vertical-\)\=text\>"
    1              0.000012 syn match cssUIAttr contained "\<zoom\(-in\|-out\)\=\>"
                            
    1              0.000015 syn match cssUIProp contained "\<ime-mode\>"
    1              0.000007 syn keyword cssUIAttr contained active inactive disabled
                            
    1              0.000013 syn match cssUIProp contained "\<nav-\(down\|index\|left\|right\|up\)\=\>"
    1              0.000014 syn match cssUIProp contained "\<outline\(-\(width\|style\|color\|offset\)\)\=\>"
    1              0.000006 syn keyword cssUIAttr contained invert
                            
    1              0.000006 syn keyword cssUIProp contained icon resize
    1              0.000006 syn keyword cssUIAttr contained both horizontal vertical
                            
    1              0.000009 syn match cssUIProp contained "\<text-overflow\>"
    1              0.000006 syn keyword cssUIAttr contained clip ellipsis
                            
                            " Already highlighted Props: font content
                            "------------------------------------------------
                            " Webkit/iOS specific attributes
    1              0.000009 syn match cssUIAttr contained '\(preserve-3d\)'
                            " IE specific attributes
    1              0.000019 syn match cssIEUIAttr contained '\(bicubic\)'
                            
                            " Webkit/iOS specific properties
    1              0.000016 syn match cssUIProp contained '\(tap-highlight-color\|user-select\|touch-callout\)'
                            " IE specific properties
    1              0.000028 syn match cssIEUIProp contained '\(interpolation-mode\|zoom\|filter\)'
                            
                            " Webkit/Firebox specific properties/attributes
    1              0.000007 syn keyword cssUIProp contained appearance
    1              0.000008 syn keyword cssUIAttr contained window button field icon document menu
                            
                            
    1              0.000027 syn match cssAuralProp contained "\<\(pause\|cue\)\(-\(before\|after\)\)\=\>"
    1              0.000028 syn match cssAuralProp contained "\<\(play-during\|speech-rate\|voice-family\|pitch\(-range\)\=\|speak\(-\(punctuation\|numeral\|header\)\)\=\)\>"
    1              0.000015 syn keyword cssAuralProp contained volume during azimuth elevation stress richness
    1              0.000026 syn match cssAuralAttr contained "\<\(x-\)\=\(soft\|loud\)\>"
    1              0.000007 syn keyword cssAuralAttr contained silent
    1              0.000009 syn match cssAuralAttr contained "\<spell-out\>"
    1              0.000006 syn keyword cssAuralAttr contained non mix
    1              0.000045 syn match cssAuralAttr contained "\<\(left\|right\)-side\>"
    1              0.000015 syn match cssAuralAttr contained "\<\(far\|center\)-\(left\|center\|right\)\>"
    1              0.000008 syn keyword cssAuralAttr contained leftwards rightwards behind
    1              0.000007 syn keyword cssAuralAttr contained below level above lower higher
    1              0.000012 syn match cssAuralAttr contained "\<\(x-\)\=\(slow\|fast\|low\|high\)\>"
    1              0.000006 syn keyword cssAuralAttr contained faster slower
    1              0.000010 syn keyword cssAuralAttr contained male female child code digits continuous
                            
                            " mobile text
    1              0.000018 syn match cssMobileTextProp contained "\<text-size-adjust\>"
                            
                            
                            
    1              0.000016 syn match cssBraces contained "[{}]"
    1              0.000011 syn match cssError contained "{@<>"
    1              0.001921 syn region cssDefinition transparent matchgroup=cssBraces start='{' end='}' contains=cssAttrRegion,css.*Prop,cssComment,cssValue.*,cssColor,cssURL,cssImportant,cssError,cssStringQ,cssStringQQ,cssFunction,cssUnicodeEscape,cssVendor,cssDefinition,cssHacks,cssNoise fold
    1              0.000032 syn match cssBraceError "}"
    1              0.000015 syn match cssAttrComma ","
                            
                            " Pseudo class
                            " http://www.w3.org/TR/css3-selectors/
    1              0.000055 syn match cssPseudoClass ":[A-Za-z0-9_-]*" contains=cssNoise,cssPseudoClassId,cssUnicodeEscape,cssVendor,cssPseudoClassFn
    1              0.000015 syn keyword cssPseudoClassId contained link visited active hover before after left right
    1              0.000011 syn keyword cssPseudoClassId contained root empty target enable disabled checked invalid
    1              0.000013 syn match cssPseudoClassId contained "\<first-\(line\|letter\)\>"
    1              0.000014 syn match cssPseudoClassId contained "\<\(first\|last\|only\)-\(of-type\|child\)\>"
    1              0.000022 syn region cssPseudoClassFn contained matchgroup=cssFunctionName start="\<\(not\|lang\|\(nth\|nth-last\)-\(of-type\|child\)\)(" end=")"
                            " ------------------------------------
                            " Vendor specific properties
    1              0.000009 syn match cssPseudoClassId contained  "\<selection\>"
    1              0.000010 syn match cssPseudoClassId contained  "\<focus\(-inner\)\=\>"
    1              0.000015 syn match cssPseudoClassId contained  "\<\(input-\)\=placeholder\>"
                            
                            " Misc highlight groups
    1              0.000029 syntax match cssUnitDecorators /\(#\|-\|%\|mm\|cm\|in\|pt\|pc\|em\|ex\|px\|ch\|rem\|vh\|vw\|vmin\|vmax\|dpi\|dppx\|dpcm\|Hz\|kHz\|s\|ms\|deg\|grad\|rad\)/ contained
    1              0.000010 syntax match cssNoise contained /\(:\|;\|\/\)/
                            
                            " Comment
    1              0.000015 syn region cssComment start="/\*" end="\*/" contains=@Spell fold
                            
    1              0.000013 syn match cssUnicodeEscape "\\\x\{1,6}\s\?"
    1              0.000016 syn match cssSpecialCharQQ +\\\\\|\\"+ contained
    1              0.000016 syn match cssSpecialCharQ +\\\\\|\\'+ contained
    1              0.000019 syn region cssStringQQ start=+"+ skip=+\\\\\|\\"+ end=+"+ contains=cssUnicodeEscape,cssSpecialCharQQ
    1              0.000064 syn region cssStringQ start=+'+ skip=+\\\\\|\\'+ end=+'+ contains=cssUnicodeEscape,cssSpecialCharQ
                            
                            " Vendor Prefix
    1              0.000014 syn match cssVendor contained "\(-\(webkit\|moz\|o\|ms\)-\)"
                            
                            " Various CSS Hack characters
                            " In earlier versions of IE (6 and 7), one can prefix property names
                            " with a _ or * to isolate those definitions to particular versions of IE
                            " This is purely decorative and therefore we assign to the same highlight
                            " group to cssVendor, for more information:
                            " http://www.paulirish.com/2009/browser-specific-css-hacks/
    1              0.000010 syn match cssHacks contained /\(_\|*\)/
                            
                            " Attr Enhance
                            " Some keywords are both Prop and Attr, so we have to handle them
    1              0.002513 syn region cssAttrRegion start=/:/ end=/\ze\(;\|)\|}\)/ contained contains=css.*Attr,cssColor,cssImportant,cssValue.*,cssFunction,cssString.*,cssURL,cssComment,cssUnicodeEscape,cssVendor,cssError,cssAttrComma,cssNoise
                            
                            " Hack for transition
                            " 'transition' has Props after ':'.
    1              0.003685 syn region cssAttrRegion start=/transition\s*:/ end=/\ze\(;\|)\|}\)/ contained contains=css.*Prop,css.*Attr,cssColor,cssImportant,cssValue.*,cssFunction,cssString.*,cssURL,cssComment,cssUnicodeEscape,cssVendor,cssError,cssAttrComma,cssNoise
                            
                            
    1              0.000019 if main_syntax == "css"
    1              0.000007   syn sync minlines=10
    1              0.000004 endif
                            
                            " Define the default highlighting.
                            " Only when an item doesn't have highlighting yet
                            
    1              0.000012 hi def link cssComment Comment
    1              0.000010 hi def link cssVendor Comment
    1              0.000021 hi def link cssHacks Comment
    1              0.000010 hi def link cssTagName Statement
    1              0.000081 hi def link cssDeprecated Error
    1              0.000011 hi def link cssSelectorOp Special
    1              0.000010 hi def link cssSelectorOp2 Special
    1              0.000009 hi def link cssAttrComma Special
                            
    1              0.000012 hi def link cssAnimationProp cssProp
    1              0.000004 hi def link cssBackgroundProp cssProp
    1              0.000004 hi def link cssBorderProp cssProp
    1              0.000004 hi def link cssBoxProp cssProp
    1              0.000004 hi def link cssColorProp cssProp
    1              0.000012 hi def link cssContentForPagedMediaProp cssProp
    1              0.000004 hi def link cssDimensionProp cssProp
    1              0.000004 hi def link cssFlexibleBoxProp cssProp
    1              0.000004 hi def link cssFontProp cssProp
    1              0.000004 hi def link cssGeneratedContentProp cssProp
    1              0.000004 hi def link cssGridProp cssProp
    1              0.000004 hi def link cssHyerlinkProp cssProp
    1              0.000011 hi def link cssLineboxProp cssProp
    1              0.000004 hi def link cssListProp cssProp
    1              0.000011 hi def link cssMarqueeProp cssProp
    1              0.000004 hi def link cssMultiColumnProp cssProp
    1              0.000017 hi def link cssPagedMediaProp cssProp
    1              0.000004 hi def link cssPositioningProp cssProp
    1              0.000013 hi def link cssPrintProp cssProp
    1              0.000012 hi def link cssRubyProp cssProp
    1              0.000012 hi def link cssSpeechProp cssProp
    1              0.000004 hi def link cssTableProp cssProp
    1              0.000004 hi def link cssTextProp cssProp
    1              0.000004 hi def link cssTransformProp cssProp
    1              0.000004 hi def link cssTransitionProp cssProp
    1              0.000004 hi def link cssUIProp cssProp
    1              0.000004 hi def link cssIEUIProp cssProp
    1              0.000004 hi def link cssAuralProp cssProp
    1              0.000011 hi def link cssRenderProp cssProp
    1              0.000004 hi def link cssMobileTextProp cssProp
                            
    1              0.000017 hi def link cssAnimationAttr cssAttr
    1              0.000006 hi def link cssBackgroundAttr cssAttr
    1              0.000004 hi def link cssBorderAttr cssAttr
    1              0.000004 hi def link cssBoxAttr cssAttr
    1              0.000012 hi def link cssContentForPagedMediaAttr cssAttr
    1              0.000014 hi def link cssDimensionAttr cssAttr
    1              0.000005 hi def link cssFlexibleBoxAttr cssAttr
    1              0.000004 hi def link cssFontAttr cssAttr
    1              0.000004 hi def link cssGeneratedContentAttr cssAttr
    1              0.000012 hi def link cssGridAttr cssAttr
    1              0.000012 hi def link cssHyerlinkAttr cssAttr
    1              0.000012 hi def link cssLineboxAttr cssAttr
    1              0.000004 hi def link cssListAttr cssAttr
    1              0.000012 hi def link cssMarginAttr cssAttr
    1              0.000012 hi def link cssMarqueeAttr cssAttr
    1              0.000004 hi def link cssMultiColumnAttr cssAttr
    1              0.000012 hi def link cssPaddingAttr cssAttr
    1              0.000018 hi def link cssPagedMediaAttr cssAttr
    1              0.000005 hi def link cssPositioningAttr cssAttr
    1              0.000004 hi def link cssGradientAttr cssAttr
    1              0.000004 hi def link cssPrintAttr cssAttr
    1              0.000012 hi def link cssRubyAttr cssAttr
    1              0.000012 hi def link cssSpeechAttr cssAttr
    1              0.000004 hi def link cssTableAttr cssAttr
    1              0.000004 hi def link cssTextAttr cssAttr
    1              0.000012 hi def link cssTransformAttr cssAttr
    1              0.000004 hi def link cssTransitionAttr cssAttr
    1              0.000004 hi def link cssUIAttr cssAttr
    1              0.000004 hi def link cssIEUIAttr cssAttr
    1              0.000004 hi def link cssAuralAttr cssAttr
    1              0.000012 hi def link cssRenderAttr cssAttr
    1              0.000005 hi def link cssCommonAttr cssAttr
                            
    1              0.000009 hi def link cssPseudoClassId PreProc
    1              0.000017 hi def link cssPseudoClassLang Constant
    1              0.000011 hi def link cssValueLength Number
    1              0.000011 hi def link cssValueInteger Number
    1              0.000011 hi def link cssValueNumber Number
    1              0.000011 hi def link cssValueAngle Number
    1              0.000011 hi def link cssValueTime Number
    1              0.000011 hi def link cssValueFrequency Number
    1              0.000010 hi def link cssFunction Constant
    1              0.000011 hi def link cssURL String
    1              0.000010 hi def link cssFunctionName Function
    1              0.000010 hi def link cssFunctionComma Function
    1              0.000010 hi def link cssColor Constant
    1              0.000010 hi def link cssIdentifier Function
    1              0.000010 hi def link cssInclude Include
    1              0.000013 hi def link cssIncludeKeyword atKeyword
    1              0.000016 hi def link cssImportant Special
    1              0.000010 hi def link cssBraces Function
    1              0.000010 hi def link cssBraceError Error
    1              0.000011 hi def link cssError Error
    1              0.000010 hi def link cssUnicodeEscape Special
    1              0.000011 hi def link cssStringQQ String
    1              0.000011 hi def link cssStringQ String
    1              0.000011 hi def link cssAttributeSelector String
    1              0.000012 hi def link cssMedia atKeyword
    1              0.000010 hi def link cssMediaType Special
    1              0.000012 hi def link cssMediaComma Normal
    1              0.000010 hi def link cssMediaKeyword Statement
    1              0.000005 hi def link cssMediaProp cssProp
    1              0.000005 hi def link cssMediaAttr cssAttr
    1              0.000004 hi def link cssPage atKeyword
    1              0.000010 hi def link cssPagePseudo PreProc
    1              0.000005 hi def link cssPageMargin atKeyword
    1              0.000005 hi def link cssPageProp cssProp
    1              0.000004 hi def link cssKeyFrame atKeyword
    1              0.000010 hi def link cssKeyFrameSelector Constant
    1              0.000010 hi def link cssFontDescriptor Special
    1              0.000010 hi def link cssFontDescriptorFunction Constant
    1              0.000005 hi def link cssFontDescriptorProp cssProp
    1              0.000005 hi def link cssFontDescriptorAttr cssAttr
    1              0.000017 hi def link cssUnicodeRange Constant
    1              0.000010 hi def link cssClassName Function
    1              0.000010 hi def link cssClassNameDot Function
    1              0.000009 hi def link cssProp StorageClass
    1              0.000009 hi def link cssAttr Constant
    1              0.000012 hi def link cssUnitDecorators Number
    1              0.000012 hi def link cssNoise Noise
    1              0.000010 hi def link atKeyword PreProc
                            
    1              0.000011 let b:current_syntax = "css"
                            
    1              0.000006 if main_syntax == 'css'
    1              0.000006   unlet main_syntax
    1              0.000003 endif
                            
    1              0.000033 let &cpo = s:cpo_save
    1              0.000005 unlet s:cpo_save
                            " vim: ts=8
                            

SCRIPT  /home/pawelztef/.local/share/nvim/plugged/syntastic/syntax_checkers/scss/mixedindentlint.vim
Sourced 1 time
Total time:   0.015803
 Self time:   0.000408

count  total (s)   self (s)
                            "============================================================================
                            "File:        mixedindentlint.vim
                            "Description: Mixed indentation linter for vim
                            "Maintainer:  Payton Swick <payton@foolord.com>
                            "License:     This program is free software. It comes without any warranty,
                            "             to the extent permitted by applicable law. You can redistribute
                            "             it and/or modify it under the terms of the Do What The Fuck You
                            "             Want To Public License, Version 2, as published by Sam Hocevar.
                            "             See http://sam.zoy.org/wtfpl/COPYING for more details.
                            "============================================================================
                            
    1              0.000023 if exists('g:loaded_syntastic_scss_mixedindentlint_checker')
                                finish
                            endif
    1              0.000022 let g:loaded_syntastic_scss_mixedindentlint_checker = 1
                            
    1   0.015440   0.000045 call g:SyntasticRegistry.CreateAndRegisterChecker({
                                \ 'filetype': 'scss',
                                \ 'name': 'mixedindentlint',
                                \ 'redirect': 'javascript/mixedindentlint'})
                            
                            " vim: set et sts=4 sw=4:

SCRIPT  /home/pawelztef/.local/share/nvim/plugged/syntastic/syntax_checkers/javascript/closurecompiler.vim
Sourced 2 times
Total time:   0.001192
 Self time:   0.000717

count  total (s)   self (s)
                            "============================================================================
                            "File:        closurecompiler.vim
                            "Description: Javascript syntax checker - using Google Closure Compiler
                            "Maintainer:  Motohiro Takayama <mootoh at gmail dot com>
                            "License:     This program is free software. It comes without any warranty,
                            "             to the extent permitted by applicable law. You can redistribute
                            "             it and/or modify it under the terms of the Do What The Fuck You
                            "             Want To Public License, Version 2, as published by Sam Hocevar.
                            "             See http://sam.zoy.org/wtfpl/COPYING for more details.
                            "============================================================================
                            
    2              0.000039 if exists('g:loaded_syntastic_javascript_closurecompiler_checker')
    1              0.000005     finish
                            endif
    1              0.000016 let g:loaded_syntastic_javascript_closurecompiler_checker = 1
                            
    1              0.000030 let s:save_cpo = &cpo
    1              0.000030 set cpo&vim
                            
    1              0.000014 function! SyntaxCheckers_javascript_closurecompiler_IsAvailable() dict
                                call syntastic#log#deprecationWarn('javascript_closure_compiler_path', 'javascript_closurecompiler_path')
                            
                                if !executable(self.getExec())
                                    return 0
                                endif
                            
                                let s:has_script = exists('g:syntastic_javascript_closurecompiler_script')
                                if s:has_script
                                    return 1
                                endif
                            
                                let cp = get(g:, 'syntastic_javascript_closurecompiler_path', '')
                                call self.log('g:syntastic_javascript_closurecompiler_path =', cp)
                            
                                let jar = expand(cp, 1)
                                call self.log('filereadable(' . string(jar) . ') = ' . filereadable(jar))
                            
                                return filereadable(jar)
                            endfunction
                            
    1              0.000013 function! SyntaxCheckers_javascript_closurecompiler_GetLocList() dict
                                call syntastic#log#deprecationWarn('javascript_closure_compiler_options', 'javascript_closurecompiler_args')
                                call syntastic#log#deprecationWarn('javascript_closure_compiler_file_list', 'javascript_closurecompiler_file_list')
                            
                                let buf = bufnr('')
                                let flist = expand(syntastic#util#bufVar(buf, 'javascript_closurecompiler_file_list'), 1)
                                if filereadable(flist)
                                    let file_list = map( readfile(flist), 'expand(v:var, 1)' )
                                else
                                    let file_list = [bufname(buf)]
                                endif
                            
                                let makeprg = self.makeprgBuild({
                                    \ 'exe_after': (s:has_script ? [] : ['-jar', expand(g:syntastic_javascript_closurecompiler_path, 1)]),
                                    \ 'args_after': '--js',
                                    \ 'fname': file_list })
                            
                                let errorformat =
                                    \ '%-GOK,'.
                                    \ '%E%f:%l: ERROR - %m,'.
                                    \ '%W%f:%l: WARNING - %m,'.
                                    \ '%Z%p^'
                            
                                return SyntasticMake({
                                    \ 'makeprg': makeprg,
                                    \ 'errorformat': errorformat })
                            endfunction
                            
    1   0.000502   0.000026 call g:SyntasticRegistry.CreateAndRegisterChecker({
                                \ 'filetype': 'javascript',
                                \ 'name': 'closurecompiler',
                                \ 'exec': get(g:, 'syntastic_javascript_closurecompiler_script', 'java')})
                            
    1              0.000022 let &cpo = s:save_cpo
    1              0.000005 unlet s:save_cpo
                            
                            " vim: set sw=4 sts=4 et fdm=marker:

SCRIPT  /home/pawelztef/.local/share/nvim/plugged/syntastic/syntax_checkers/javascript/eslint.vim
Sourced 2 times
Total time:   0.001165
 Self time:   0.000720

count  total (s)   self (s)
                            "============================================================================
                            "File:        eslint.vim
                            "Description: Javascript syntax checker - using eslint
                            "Maintainer:  Maksim Ryzhikov <rv.maksim at gmail dot com>
                            "License:     This program is free software. It comes without any warranty,
                            "             to the extent permitted by applicable law. You can redistribute
                            "             it and/or modify it under the terms of the Do What The Fuck You
                            "             Want To Public License, Version 2, as published by Sam Hocevar.
                            "             See http://sam.zoy.org/wtfpl/COPYING for more details.
                            "============================================================================
                            
    2              0.000033 if exists('g:loaded_syntastic_javascript_eslint_checker')
    1              0.000004     finish
                            endif
    1              0.000014 let g:loaded_syntastic_javascript_eslint_checker = 1
                            
    1              0.000013 if !exists('g:syntastic_javascript_eslint_sort')
    1              0.000012     let g:syntastic_javascript_eslint_sort = 1
    1              0.000004 endif
                            
    1              0.000012 if !exists('g:syntastic_javascript_eslint_generic')
    1              0.000012     let g:syntastic_javascript_eslint_generic = 0
    1              0.000004 endif
                            
    1              0.000024 let s:save_cpo = &cpo
    1              0.000024 set cpo&vim
                            
    1              0.000011 function! SyntaxCheckers_javascript_eslint_IsAvailable() dict
                                if g:syntastic_javascript_eslint_generic
                                    call self.log('generic eslint, exec =', self.getExec())
                                endif
                            
                                if !executable(self.getExec())
                                    return 0
                                endif
                                return g:syntastic_javascript_eslint_generic || syntastic#util#versionIsAtLeast(self.getVersion(), [0, 1])
                            endfunction
                            
    1              0.000011 function! SyntaxCheckers_javascript_eslint_GetLocList() dict
                                if !g:syntastic_javascript_eslint_generic
                                    call syntastic#log#deprecationWarn('javascript_eslint_conf', 'javascript_eslint_args',
                                        \ "'--config ' . syntastic#util#shexpand(OLD_VAR)")
                                endif
                            
                                let makeprg = self.makeprgBuild({ 'args_before': (g:syntastic_javascript_eslint_generic ? '' : '-f compact') })
                            
                                let errorformat =
                                    \ '%E%f: line %l\, col %c\, Error - %m,' .
                                    \ '%W%f: line %l\, col %c\, Warning - %m'
                            
                                let loclist = SyntasticMake({
                                    \ 'makeprg': makeprg,
                                    \ 'errorformat': errorformat,
                                    \ 'postprocess': ['guards'] })
                            
                                if !g:syntastic_javascript_eslint_generic
                                    if !exists('s:eslint_new')
                                        let s:eslint_new = syntastic#util#versionIsAtLeast(self.getVersion(), [1])
                                    endif
                            
                                    if !s:eslint_new
                                        for e in loclist
                                            let e['col'] += 1
                                        endfor
                                    endif
                                endif
                            
                                return loclist
                            endfunction
                            
    1   0.000463   0.000018 call g:SyntasticRegistry.CreateAndRegisterChecker({
                                \ 'filetype': 'javascript',
                                \ 'name': 'eslint'})
                            
    1              0.000016 let &cpo = s:save_cpo
    1              0.000005 unlet s:save_cpo
                            
                            " vim: set sw=4 sts=4 et fdm=marker:

SCRIPT  /home/pawelztef/.local/share/nvim/plugged/syntastic/syntax_checkers/javascript/flow.vim
Sourced 2 times
Total time:   0.001086
 Self time:   0.000639

count  total (s)   self (s)
                            "============================================================================
                            "File:        flow.vim
                            "Description: Javascript syntax checker - using flow
                            "Maintainer:  Michael Robinson <mike@pagesofinterest.net>
                            "License:     This program is free software. It comes without any warranty,
                            "             to the extent permitted by applicable law. You can redistribute
                            "             it and/or modify it under the terms of the Do What The Fuck You
                            "             Want To Public License, Version 2, as published by Sam Hocevar.
                            "             See http://sam.zoy.org/wtfpl/COPYING for more details.
                            "============================================================================
                            
    2              0.000034 if exists('g:loaded_syntastic_javascript_flow_checker')
    1              0.000005     finish
                            endif
    1              0.000020 let g:loaded_syntastic_javascript_flow_checker = 1
                            
    1              0.000015 if !exists('g:syntastic_javascript_flow_sort')
    1              0.000012     let g:syntastic_javascript_flow_sort = 1
    1              0.000005 endif
                            
    1              0.000023 let s:save_cpo = &cpo
    1              0.000025 set cpo&vim
                            
    1              0.000011 function! SyntaxCheckers_javascript_flow_IsAvailable() dict
                                if !executable(self.getExec())
                                    return 0
                                endif
                                return syntastic#util#versionIsAtLeast(self.getVersion(self.getExecEscaped() . ' version'), [0, 34])
                            endfunction
                            
    1              0.000011 function! SyntaxCheckers_javascript_flow_GetLocList() dict
                                let buf = bufnr('')
                                if syntastic#util#findFileInParent('.flowconfig', fnamemodify(bufname(buf), ':p:h')) ==# ''
                                    return []
                                endif
                            
                                let makeprg = self.makeprgBuild({
                                    \ 'exe': self.getExecEscaped() . ' status',
                                    \ 'args_after': '--quiet --show-all-errors --json' })
                            
                                let errorformat =
                                    \ '%f:%l:%c:%n: %m,' .
                                    \ '%f:%l:%c: %m'
                            
                                let loclist = SyntasticMake({
                                    \ 'makeprg': makeprg,
                                    \ 'errorformat': errorformat,
                                    \ 'preprocess': 'flow',
                                    \ 'defaults': {'type': 'E'} })
                            
                                for e in loclist
                                    if get(e, 'col', 0) && get(e, 'nr', 0)
                                        let e['hl'] = '\%>' . (e['col'] - 1) . 'c\%<' . (e['nr'] + 1) . 'c'
                                        let e['nr'] = 0
                                    endif
                                endfor
                            
                                return loclist
                            endfunction
                            
    1   0.000477   0.000030 call g:SyntasticRegistry.CreateAndRegisterChecker({
                                \ 'filetype': 'javascript',
                                \ 'name': 'flow'})
                            
    1              0.000022 let &cpo = s:save_cpo
    1              0.000005 unlet s:save_cpo
                            
                            " vim: set sw=4 sts=4 et fdm=marker:

SCRIPT  /home/pawelztef/.local/share/nvim/plugged/syntastic/syntax_checkers/javascript/gjslint.vim
Sourced 2 times
Total time:   0.001040
 Self time:   0.000560

count  total (s)   self (s)
                            "============================================================================
                            "File:        gjslint.vim
                            "Description: Javascript syntax checker - using gjslint
                            "Maintainer:  Martin Grenfell <martin.grenfell at gmail dot com>
                            "License:     This program is free software. It comes without any warranty,
                            "             to the extent permitted by applicable law. You can redistribute
                            "             it and/or modify it under the terms of the Do What The Fuck You
                            "             Want To Public License, Version 2, as published by Sam Hocevar.
                            "             See http://sam.zoy.org/wtfpl/COPYING for more details.
                            "============================================================================
                            
    2              0.000036 if exists('g:loaded_syntastic_javascript_gjslint_checker')
    1              0.000004     finish
                            endif
    1              0.000014 let g:loaded_syntastic_javascript_gjslint_checker = 1
                            
    1              0.000024 let s:save_cpo = &cpo
    1              0.000025 set cpo&vim
                            
    1              0.000012 function! SyntaxCheckers_javascript_gjslint_GetLocList() dict
                                call syntastic#log#deprecationWarn('javascript_gjslint_conf', 'javascript_gjslint_args')
                            
                                let makeprg = self.makeprgBuild({
                                    \ 'args': '--nodebug_indentation',
                                    \ 'args_after': '--check_html --nosummary --unix_mode --nobeep' })
                            
                                let errorformat =
                                    \ "%f:%l:(New Error -%\\?\%n) %m," .
                                    \ "%f:%l:(-%\\?%n) %m," .
                                    \ "%-G1 files checked," .
                                    \ " no errors found.," .
                                    \ "%-G%.%#"
                            
                                return SyntasticMake({
                                    \ 'makeprg': makeprg,
                                    \ 'errorformat': errorformat })
                            endfunction
                            
    1   0.000514   0.000034 call g:SyntasticRegistry.CreateAndRegisterChecker({
                                \ 'filetype': 'javascript',
                                \ 'name': 'gjslint'})
                            
    1              0.000016 let &cpo = s:save_cpo
    1              0.000005 unlet s:save_cpo
                            
                            " vim: set sw=4 sts=4 et fdm=marker:

SCRIPT  /home/pawelztef/.local/share/nvim/plugged/syntastic/syntax_checkers/javascript/jscs.vim
Sourced 2 times
Total time:   0.001041
 Self time:   0.000563

count  total (s)   self (s)
                            "============================================================================
                            "File:        jscs.vim
                            "Description: Javascript syntax checker - using jscs
                            "Maintainer:  LCD 47 <lcd047@gmail.com>
                            "License:     This program is free software. It comes without any warranty,
                            "             to the extent permitted by applicable law. You can redistribute
                            "             it and/or modify it under the terms of the Do What The Fuck You
                            "             Want To Public License, Version 2, as published by Sam Hocevar.
                            "             See http://sam.zoy.org/wtfpl/COPYING for more details.
                            "============================================================================
                            
    2              0.000031 if exists('g:loaded_syntastic_javascript_jscs_checker')
    1              0.000003     finish
                            endif
    1              0.000014 let g:loaded_syntastic_javascript_jscs_checker = 1
                            
    1              0.000013 if !exists('g:syntastic_javascript_jscs_sort')
    1              0.000011     let g:syntastic_javascript_jscs_sort = 1
    1              0.000004 endif
                            
    1              0.000024 let s:save_cpo = &cpo
    1              0.000025 set cpo&vim
                            
    1              0.000011 function! SyntaxCheckers_javascript_jscs_IsAvailable() dict
                                if !executable(self.getExec())
                                    return 0
                                endif
                                return syntastic#util#versionIsAtLeast(self.getVersion(), [2, 1])
                            endfunction
                            
    1              0.000009 function! SyntaxCheckers_javascript_jscs_GetLocList() dict
                                let makeprg = self.makeprgBuild({
                                    \ 'args_after': '--no-colors --max-errors -1 --reporter json' })
                            
                                let errorformat = '%f:%l:%c:%m'
                            
                                return SyntasticMake({
                                    \ 'makeprg': makeprg,
                                    \ 'errorformat': errorformat,
                                    \ 'subtype': 'Style',
                                    \ 'preprocess': 'jscs',
                                    \ 'defaults': {'type': 'E'},
                                    \ 'returns': [0, 2] })
                            endfunction
                            
    1   0.000507   0.000029 call g:SyntasticRegistry.CreateAndRegisterChecker({
                                \ 'filetype': 'javascript',
                                \ 'name': 'jscs'})
                            
    1              0.000016 let &cpo = s:save_cpo
    1              0.000005 unlet s:save_cpo
                            
                            " vim: set sw=4 sts=4 et fdm=marker:

SCRIPT  /home/pawelztef/.local/share/nvim/plugged/syntastic/syntax_checkers/javascript/jshint.vim
Sourced 2 times
Total time:   0.001066
 Self time:   0.000618

count  total (s)   self (s)
                            "============================================================================
                            "File:        jshint.vim
                            "Description: Javascript syntax checker - using jshint
                            "Maintainer:  Martin Grenfell <martin.grenfell at gmail dot com>
                            "License:     This program is free software. It comes without any warranty,
                            "             to the extent permitted by applicable law. You can redistribute
                            "             it and/or modify it under the terms of the Do What The Fuck You
                            "             Want To Public License, Version 2, as published by Sam Hocevar.
                            "             See http://sam.zoy.org/wtfpl/COPYING for more details.
                            "============================================================================
                            
    2              0.000039 if exists('g:loaded_syntastic_javascript_jshint_checker')
    1              0.000004     finish
                            endif
    1              0.000014 let g:loaded_syntastic_javascript_jshint_checker = 1
                            
    1              0.000013 if !exists('g:syntastic_javascript_jshint_sort')
    1              0.000012     let g:syntastic_javascript_jshint_sort = 1
    1              0.000004 endif
                            
    1              0.000023 let s:save_cpo = &cpo
    1              0.000024 set cpo&vim
                            
    1              0.000011 function! SyntaxCheckers_javascript_jshint_IsAvailable() dict
                                call syntastic#log#deprecationWarn('jshint_exec', 'javascript_jshint_exec')
                                if !executable(self.getExec())
                                    return 0
                                endif
                            
                                let ver = self.getVersion()
                                let s:jshint_new = syntastic#util#versionIsAtLeast(ver, [1, 1])
                            
                                return syntastic#util#versionIsAtLeast(ver, [1])
                            endfunction
                            
    1              0.000012 function! SyntaxCheckers_javascript_jshint_GetLocList() dict
                                call syntastic#log#deprecationWarn('javascript_jshint_conf', 'javascript_jshint_args',
                                    \ "'--config ' . syntastic#util#shexpand(OLD_VAR)")
                            
                                let makeprg = self.makeprgBuild({ 'args_after': (s:jshint_new ? '--verbose ' : '') })
                            
                                let errorformat = s:jshint_new ?
                                    \ '%A%f: line %l\, col %v\, %m \(%t%*\d\)' :
                                    \ '%E%f: line %l\, col %v\, %m'
                            
                                return SyntasticMake({
                                    \ 'makeprg': makeprg,
                                    \ 'errorformat': errorformat,
                                    \ 'defaults': {'bufnr': bufnr('')},
                                    \ 'returns': [0, 2] })
                            endfunction
                            
    1   0.000477   0.000029 call g:SyntasticRegistry.CreateAndRegisterChecker({
                                \ 'filetype': 'javascript',
                                \ 'name': 'jshint'})
                            
    1              0.000016 let &cpo = s:save_cpo
    1              0.000005 unlet s:save_cpo
                            
                            " vim: set sw=4 sts=4 et fdm=marker:

SCRIPT  /home/pawelztef/.local/share/nvim/plugged/syntastic/syntax_checkers/javascript/jsl.vim
Sourced 2 times
Total time:   0.001044
 Self time:   0.000503

count  total (s)   self (s)
                            "============================================================================
                            "File:        jsl.vim
                            "Description: Javascript syntax checker - using jsl
                            "Maintainer:  Martin Grenfell <martin.grenfell at gmail dot com>
                            "License:     This program is free software. It comes without any warranty,
                            "             to the extent permitted by applicable law. You can redistribute
                            "             it and/or modify it under the terms of the Do What The Fuck You
                            "             Want To Public License, Version 2, as published by Sam Hocevar.
                            "             See http://sam.zoy.org/wtfpl/COPYING for more details.
                            "============================================================================
                            
    2              0.000031 if exists('g:loaded_syntastic_javascript_jsl_checker')
    1              0.000003     finish
                            endif
    1              0.000014 let g:loaded_syntastic_javascript_jsl_checker = 1
                            
    1              0.000024 let s:save_cpo = &cpo
    1              0.000024 set cpo&vim
                            
    1              0.000011 function! SyntaxCheckers_javascript_jsl_GetLocList() dict
                                call syntastic#log#deprecationWarn('javascript_jsl_conf', 'javascript_jsl_args',
                                    \ "'-conf ' . syntastic#util#shexpand(OLD_VAR)")
                            
                                let makeprg = self.makeprgBuild({
                                    \ 'args_after': '-nologo -nofilelisting -nosummary -nocontext -process' })
                            
                                let errorformat =
                                    \ '%W%f(%l): lint warning: %m,'.
                                    \ '%-Z%p^,'.
                                    \ '%W%f(%l): warning: %m,'.
                                    \ '%-Z%p^,'.
                                    \ '%E%f(%l): SyntaxError: %m,'.
                                    \ '%-Z%p^,'.
                                    \ '%-G'
                            
                                return SyntasticMake({
                                    \ 'makeprg': makeprg,
                                    \ 'errorformat': errorformat })
                            endfunction
                            
    1   0.000570   0.000029 call g:SyntasticRegistry.CreateAndRegisterChecker({
                                \ 'filetype': 'javascript',
                                \ 'name': 'jsl'})
                            
    1              0.000017 let &cpo = s:save_cpo
    1              0.000005 unlet s:save_cpo
                            
                            " vim: set sw=4 sts=4 et fdm=marker:

SCRIPT  /home/pawelztef/.local/share/nvim/plugged/syntastic/syntax_checkers/javascript/jslint.vim
Sourced 2 times
Total time:   0.001096
 Self time:   0.000634

count  total (s)   self (s)
                            "============================================================================
                            "File:        jslint.vim
                            "Description: Javascript syntax checker - using jslint
                            "Maintainer:  Martin Grenfell <martin.grenfell at gmail dot com>
                            "License:     This program is free software. It comes without any warranty,
                            "             to the extent permitted by applicable law. You can redistribute
                            "             it and/or modify it under the terms of the Do What The Fuck You
                            "             Want To Public License, Version 2, as published by Sam Hocevar.
                            "             See http://sam.zoy.org/wtfpl/COPYING for more details.
                            "
                            "============================================================================
                            
    2              0.000035 if exists('g:loaded_syntastic_javascript_jslint_checker')
    1              0.000004     finish
                            endif
                            
    1              0.000019 let g:loaded_syntastic_javascript_jslint_checker = 1
                            
    1              0.000026 let s:save_cpo = &cpo
    1              0.000025 set cpo&vim
                            
    1              0.000013 function! SyntaxCheckers_javascript_jslint_GetHighlightRegex(item)
                                let term = matchstr(a:item['text'], '\mExpected .* and instead saw ''\zs.*\ze''')
                                if term !=# ''
                                    let term = '\V\<' . escape(term, '\') . '\>'
                                endif
                                return term
                            endfunction
                            
    1              0.000014 function! SyntaxCheckers_javascript_jslint_GetLocList() dict
                                let makeprg = self.makeprgBuild({ 'args': '--white --nomen --regexp --plusplus --bitwise --newcap --sloppy --vars' })
                            
                                let errorformat =
                                    \ '%E %##%\d%\+ %m,'.
                                    \ '%-Z%.%#Line %l\, Pos %c,'.
                                    \ '%-G%.%#'
                            
                                return SyntasticMake({
                                    \ 'makeprg': makeprg,
                                    \ 'errorformat': errorformat,
                                    \ 'defaults': {'bufnr': bufnr('')} })
                            endfunction
                            
    1   0.000492   0.000030 call g:SyntasticRegistry.CreateAndRegisterChecker({
                                \ 'filetype': 'javascript',
                                \ 'name': 'jslint'})
                            
    1              0.000016 let &cpo = s:save_cpo
    1              0.000005 unlet s:save_cpo
                            
                            " vim: set sw=4 sts=4 et fdm=marker:

SCRIPT  /home/pawelztef/.local/share/nvim/plugged/syntastic/syntax_checkers/javascript/jsxhint.vim
Sourced 2 times
Total time:   0.001093
 Self time:   0.000638

count  total (s)   self (s)
                            "============================================================================
                            "File:        jsxhint.vim
                            "Description: Javascript syntax checker - using jsxhint
                            "Maintainer:  Thomas Boyt <me@thomasboyt.com>
                            "License:     This program is free software. It comes without any warranty,
                            "             to the extent permitted by applicable law. You can redistribute
                            "             it and/or modify it under the terms of the Do What The Fuck You
                            "             Want To Public License, Version 2, as published by Sam Hocevar.
                            "             See http://sam.zoy.org/wtfpl/COPYING for more details.
                            "============================================================================
                            
    2              0.000034 if exists('g:loaded_syntastic_javascript_jsxhint_checker')
    1              0.000004     finish
                            endif
    1              0.000014 let g:loaded_syntastic_javascript_jsxhint_checker = 1
                            
    1              0.000024 let s:save_cpo = &cpo
    1              0.000025 set cpo&vim
                            
    1              0.000012 function! SyntaxCheckers_javascript_jsxhint_IsAvailable() dict " {{{1
                                if !executable(self.getExec())
                                    return 0
                                endif
                            
                                let version_output = syntastic#util#system(self.getExecEscaped() . ' --version')
                                let parsed_ver = !v:shell_error && (version_output =~# '\m^JSXHint\>') ? syntastic#util#parseVersion(version_output) : []
                                if len(parsed_ver)
                                    call self.setVersion(parsed_ver)
                                else
                                    call syntastic#log#ndebug(g:_SYNTASTIC_DEBUG_LOCLIST, 'checker output:', split(version_output, "\n", 1))
                                    call syntastic#log#error("checker javascript/jsxhint: can't parse version string (abnormal termination?)")
                                endif
                            
                                return syntastic#util#versionIsAtLeast(parsed_ver, [0, 4, 1])
                            endfunction " }}}1
                            
    1              0.000011 function! SyntaxCheckers_javascript_jsxhint_GetLocList() dict " {{{1
                                let makeprg = self.makeprgBuild({
                                    \ 'args_after': '--verbose' })
                            
                                let errorformat = '%A%f: line %l\, col %v\, %m \(%t%*\d\)'
                            
                                return SyntasticMake({
                                    \ 'makeprg': makeprg,
                                    \ 'errorformat': errorformat,
                                    \ 'defaults': {'bufnr': bufnr('')} })
                            endfunction " }}}1
                            
    1   0.000486   0.000031 call g:SyntasticRegistry.CreateAndRegisterChecker({
                                \ 'filetype': 'javascript',
                                \ 'name': 'jsxhint'})
                            
    1              0.000016 let &cpo = s:save_cpo
    1              0.000005 unlet s:save_cpo
                            
                            " vim: set sw=4 sts=4 et fdm=marker:

SCRIPT  /home/pawelztef/.local/share/nvim/plugged/syntastic/syntax_checkers/javascript/mixedindentlint.vim
Sourced 2 times
Total time:   0.000994
 Self time:   0.000494

count  total (s)   self (s)
                            "============================================================================
                            "File:        mixedindentlint.vim
                            "Description: Mixed indentation linter for vim
                            "Maintainer:  Payton Swick <payton@foolord.com>
                            "License:     This program is free software. It comes without any warranty,
                            "             to the extent permitted by applicable law. You can redistribute
                            "             it and/or modify it under the terms of the Do What The Fuck You
                            "             Want To Public License, Version 2, as published by Sam Hocevar.
                            "             See http://sam.zoy.org/wtfpl/COPYING for more details.
                            "============================================================================
                            
    2              0.000033 if exists('g:loaded_syntastic_javascript_mixedindentlint_checker')
    1              0.000003     finish
                            endif
    1              0.000015 let g:loaded_syntastic_javascript_mixedindentlint_checker = 1
                            
    1              0.000024 let s:save_cpo = &cpo
    1              0.000025 set cpo&vim
                            
    1              0.000012 function! SyntaxCheckers_javascript_mixedindentlint_GetLocList() dict
                                let makeprg = self.makeprgBuild({})
                            
                                let errorformat = 'Line %l in "%f" %.%#'
                            
                                return SyntasticMake({
                                    \ 'makeprg': makeprg,
                                    \ 'errorformat': errorformat,
                                    \ 'subtype': 'Style',
                                    \ 'defaults': { 'text': 'Indentation differs from rest of file' },
                                    \ 'returns': [0, 1] })
                            endfunction
                            
    1   0.000535   0.000035 call g:SyntasticRegistry.CreateAndRegisterChecker({
                                \ 'filetype': 'javascript',
                                \ 'name': 'mixedindentlint'})
                            
    1              0.000016 let &cpo = s:save_cpo
    1              0.000005 unlet s:save_cpo
                            
                            " vim: set sw=4 sts=4 et fdm=marker:

SCRIPT  /home/pawelztef/.local/share/nvim/plugged/syntastic/syntax_checkers/javascript/standard.vim
Sourced 2 times
Total time:   0.001116
 Self time:   0.000683

count  total (s)   self (s)
                            "============================================================================
                            "File:        standard.vim
                            "Description: JavaScript syntax checker - using standard
                            "Maintainer:  LCD 47 <lcd047@gmail.com>
                            "License:     This program is free software. It comes without any warranty,
                            "             to the extent permitted by applicable law. You can redistribute
                            "             it and/or modify it under the terms of the Do What The Fuck You
                            "             Want To Public License, Version 2, as published by Sam Hocevar.
                            "             See http://sam.zoy.org/wtfpl/COPYING for more details.
                            "============================================================================
                            
    2              0.000034 if exists('g:loaded_syntastic_javascript_standard_checker')
    1              0.000004     finish
                            endif
    1              0.000014 let g:loaded_syntastic_javascript_standard_checker = 1
                            
    1              0.000014 if !exists('g:syntastic_javascript_standard_generic')
    1              0.000013     let g:syntastic_javascript_standard_generic = 0
    1              0.000004 endif
                            
    1              0.000024 let s:save_cpo = &cpo
    1              0.000025 set cpo&vim
                            
    1              0.000011 function! SyntaxCheckers_javascript_standard_IsAvailable() dict
                                if g:syntastic_javascript_standard_generic
                                    call self.log('generic standard, exec =', self.getExec())
                                endif
                            
                                if !executable(self.getExec())
                                    return 0
                                endif
                                return g:syntastic_javascript_standard_generic || syntastic#util#versionIsAtLeast(self.getVersion(), [2, 6, 1])
                            endfunction
                            
    1              0.000051 function! SyntaxCheckers_javascript_standard_GetLocList() dict
                                let makeprg = self.makeprgBuild({ 'args': '-v' })
                            
                                let errorformat = '  %f:%l:%c: %m'
                            
                                return SyntasticMake({
                                    \ 'makeprg': makeprg,
                                    \ 'errorformat': errorformat,
                                    \ 'subtype': 'Style',
                                    \ 'defaults': {'type': 'W'},
                                    \ 'returns': [0, 1] })
                            endfunction
                            
    1   0.000450   0.000017 call g:SyntasticRegistry.CreateAndRegisterChecker({
                                \ 'filetype': 'javascript',
                                \ 'name': 'standard'})
                            
    1              0.000016 let &cpo = s:save_cpo
    1              0.000005 unlet s:save_cpo
                            
                            " vim: set sw=4 sts=4 et fdm=marker:

SCRIPT  /home/pawelztef/.local/share/nvim/plugged/syntastic/syntax_checkers/javascript/tern_lint.vim
Sourced 2 times
Total time:   0.001033
 Self time:   0.000557

count  total (s)   self (s)
                            "============================================================================
                            "File:        tern_lint.vim
                            "Description: Syntax checking plugin for syntastic
                            "Maintainer:  LCD 47 <lcd047@gmail.com>
                            "License:     This program is free software. It comes without any warranty,
                            "             to the extent permitted by applicable law. You can redistribute
                            "             it and/or modify it under the terms of the Do What The Fuck You
                            "             Want To Public License, Version 2, as published by Sam Hocevar.
                            "             See http://sam.zoy.org/wtfpl/COPYING for more details.
                            "============================================================================
                            
    2              0.000032 if exists('g:loaded_syntastic_javascript_tern_lint_checker')
    1              0.000003     finish
                            endif
    1              0.000015 let g:loaded_syntastic_javascript_tern_lint_checker = 1
                            
    1              0.000024 let s:save_cpo = &cpo
    1              0.000025 set cpo&vim
                            
    1              0.000012 function! SyntaxCheckers_javascript_tern_lint_IsAvailable() dict
                                return has('byte_offset') && executable(self.getExec())
                            endfunction
                            
    1              0.000010 function! SyntaxCheckers_javascript_tern_lint_GetLocList() dict
                                let makeprg = self.makeprgBuild({})
                            
                                let errorformat = '%f:%t:%l:%c:%n:%m'
                            
                                let loclist = SyntasticMake({
                                    \ 'makeprg': makeprg,
                                    \ 'errorformat': errorformat,
                                    \ 'preprocess': 'tern_lint',
                                    \ 'returns': [0] })
                            
                                for e in loclist
                                    if get(e, 'col', 0) && get(e, 'nr', 0)
                                        let e['hl'] = '\%>' . (e['col'] - 1) . 'c\%<' . (e['nr'] + 1) . 'c'
                                    endif
                                    let e['nr'] = 0
                                endfor
                            
                                return loclist
                            endfunction
                            
    1   0.000508   0.000033 call g:SyntasticRegistry.CreateAndRegisterChecker({
                                \ 'filetype': 'javascript',
                                \ 'name': 'tern_lint',
                                \ 'exec': 'tern-lint' })
                            
    1              0.000016 let &cpo = s:save_cpo
    1              0.000005 unlet s:save_cpo
                            
                            " vim: set sw=4 sts=4 et fdm=marker:

SCRIPT  /home/pawelztef/.local/share/nvim/plugged/syntastic/syntax_checkers/scss/sass.vim
Sourced 1 time
Total time:   0.015145
 Self time:   0.000331

count  total (s)   self (s)
                            "============================================================================
                            "File:        scss.vim
                            "Description: scss syntax checking plugin for syntastic
                            "Maintainer:  Martin Grenfell <martin.grenfell at gmail dot com>
                            "License:     This program is free software. It comes without any warranty,
                            "             to the extent permitted by applicable law. You can redistribute
                            "             it and/or modify it under the terms of the Do What The Fuck You
                            "             Want To Public License, Version 2, as published by Sam Hocevar.
                            "             See http://sam.zoy.org/wtfpl/COPYING for more details.
                            "
                            "============================================================================
                            
    1              0.000020 if exists('g:loaded_syntastic_scss_sass_checker')
                                finish
                            endif
    1              0.000013 let g:loaded_syntastic_scss_sass_checker = 1
                            
    1   0.014850   0.000035 call g:SyntasticRegistry.CreateAndRegisterChecker({
                                \ 'filetype': 'scss',
                                \ 'name': 'sass',
                                \ 'redirect': 'sass/sass'})
                            
                            " vim: set sw=4 sts=4 et fdm=marker:

SCRIPT  /home/pawelztef/.local/share/nvim/plugged/syntastic/syntax_checkers/sass/sass.vim
Sourced 3 times
Total time:   0.010834
 Self time:   0.000975

count  total (s)   self (s)
                            "============================================================================
                            "File:        sass.vim
                            "Description: Syntax checking plugin for syntastic
                            "Maintainer:  Martin Grenfell <martin.grenfell at gmail dot com>
                            "License:     This program is free software. It comes without any warranty,
                            "             to the extent permitted by applicable law. You can redistribute
                            "             it and/or modify it under the terms of the Do What The Fuck You
                            "             Want To Public License, Version 2, as published by Sam Hocevar.
                            "             See http://sam.zoy.org/wtfpl/COPYING for more details.
                            "
                            "============================================================================
                            
    3              0.000044 if exists('g:loaded_syntastic_sass_sass_checker')
    2              0.000008     finish
                            endif
    1              0.000015 let g:loaded_syntastic_sass_sass_checker = 1
                            
                            " sass caching for large files drastically speeds up the checking, but store it
                            " in a temp location otherwise sass puts .sass_cache dirs in the users project
    1   0.009420   0.000050 let s:sass_cache_location = syntastic#util#tmpdir()
    1              0.000011 lockvar s:sass_cache_location
                            
    1              0.000007 augroup syntastic
    1              0.000019     autocmd VimLeave * call syntastic#util#rmrf(s:sass_cache_location)
    1              0.000004 augroup END
                            
                            " By default do not check partials as unknown variables are a syntax error
    1              0.000009 if !exists('g:syntastic_sass_check_partials')
    1              0.000012     let g:syntastic_sass_check_partials = 0
    1              0.000004 endif
                            
                            " use compass imports if available
    1              0.000005 let s:imports = ''
    1              0.000100 if executable('compass')
    1              0.000007     let s:imports = '--compass'
    1              0.000003 endif
                            
    1              0.000020 let s:save_cpo = &cpo
    1              0.000019 set cpo&vim
                            
    1              0.000007 function! SyntaxCheckers_sass_sass_GetLocList() dict
                                let buf = bufnr('')
                                if !syntastic#util#bufVar(buf, 'sass_check_partials') && fnamemodify(bufname(buf), ':t')[0] ==# '_'
                                    return []
                                endif
                            
                                let makeprg = self.makeprgBuild({
                                    \ 'args_before': '--cache-location ' . s:sass_cache_location . ' ' . s:imports . ' --check' })
                            
                                let errorformat =
                                    \ '%E%\m%\%%(Syntax %\)%\?%trror: %m,' .
                                    \ '%+C              %.%#,' .
                                    \ '%C        on line %l of %f\, %.%#,' .
                                    \ '%C        on line %l of %f,' .
                                    \ '%-G %\+from line %.%#,' .
                                    \ '%-G %\+Use --trace for backtrace.,' .
                                    \ '%W%>DEPRECATION WARNING on line %l of %f:,' .
                                    \ '%+C%>  %.%#,' .
                                    \ '%W%>WARNING: on line %l of %f:,' .
                                    \ '%+C%>  %.%#,' .
                                    \ '%W%>WARNING on line %l of %f: %m,' .
                                    \ '%+C%>  %.%#,' .
                                    \ '%W%>WARNING on line %l of %f:,' .
                                    \ '%Z%m,' .
                                    \ '%W%>WARNING: %m,' .
                                    \ '%C         on line %l of %f\, %.%#,' .
                                    \ '%C         on line %l of %f,' .
                                    \ '%-G %\+from line %.%#,' .
                                    \ 'Syntax %trror on line %l: %m,' .
                                    \ '%-G%.%#'
                            
                                return SyntasticMake({
                                    \ 'makeprg': makeprg,
                                    \ 'errorformat': errorformat,
                                    \ 'postprocess': ['compressWhitespace'] })
                            endfunction
                            
    1   0.000520   0.000031 call g:SyntasticRegistry.CreateAndRegisterChecker({
                                \ 'filetype': 'sass',
                                \ 'name': 'sass'})
                            
    1              0.000016 let &cpo = s:save_cpo
    1              0.000005 unlet s:save_cpo
                            
                            " vim: set sw=4 sts=4 et fdm=marker:

SCRIPT  /home/pawelztef/.local/share/nvim/plugged/syntastic/syntax_checkers/sass/sass_lint.vim
Sourced 3 times
Total time:   0.001134
 Self time:   0.000675

count  total (s)   self (s)
                            "============================================================================
                            "File:        sass_lint.vim
                            "Description: Syntax checking plugin for syntastic
                            "Maintainer:  LCD 47 <lcd047 at gmail dot com>
                            "License:     This program is free software. It comes without any warranty,
                            "             to the extent permitted by applicable law. You can redistribute
                            "             it and/or modify it under the terms of the Do What The Fuck You
                            "             Want To Public License, Version 2, as published by Sam Hocevar.
                            "             See http://sam.zoy.org/wtfpl/COPYING for more details.
                            "
                            "============================================================================
                            
    3              0.000041 if exists('g:loaded_syntastic_sass_sass_lint_checker')
    2              0.000007     finish
                            endif
    1              0.000019 let g:loaded_syntastic_sass_sass_lint_checker = 1
                            
    1              0.000026 let s:save_cpo = &cpo
    1              0.000025 set cpo&vim
                            
    1              0.000012 function! SyntaxCheckers_sass_sass_lint_IsAvailable() dict
                                if !executable(self.getExec())
                                    return 0
                                endif
                                return syntastic#util#versionIsAtLeast(self.getVersion(), [1, 5])
                            endfunction
                            
    1              0.000011 function! SyntaxCheckers_sass_sass_lint_GetLocList() dict
                                let makeprg = self.makeprgBuild({
                                    \ 'args': '-v',
                                    \ 'args_after': '-q -f compact' })
                            
                                let errorformat =
                                    \ '%f: line %l\, col %c\, %trror - %m,' .
                                    \ '%f: line %l\, col %c\, %tarning - %m'
                            
                                return SyntasticMake({
                                    \ 'makeprg': makeprg,
                                    \ 'errorformat': errorformat,
                                    \ 'returns': [0, 1] })
                            endfunction
                            
    1   0.000493   0.000034 call g:SyntasticRegistry.CreateAndRegisterChecker({
                                \ 'filetype': 'sass',
                                \ 'name': 'sass_lint',
                                \ 'exec': 'sass-lint' })
                            
    1              0.000016 let &cpo = s:save_cpo
    1              0.000005 unlet s:save_cpo
                            
                            " vim: set sw=4 sts=4 et fdm=marker:

SCRIPT  /home/pawelztef/.local/share/nvim/plugged/syntastic/syntax_checkers/sass/sassc.vim
Sourced 3 times
Total time:   0.001084
 Self time:   0.000596

count  total (s)   self (s)
                            "============================================================================
                            "File:        sassc.vim
                            "Description: Syntax checking plugin for syntastic
                            "Maintainer:  LCD 47 <lcd047 at gmail dot com>
                            "License:     This program is free software. It comes without any warranty,
                            "             to the extent permitted by applicable law. You can redistribute
                            "             it and/or modify it under the terms of the Do What The Fuck You
                            "             Want To Public License, Version 2, as published by Sam Hocevar.
                            "             See http://sam.zoy.org/wtfpl/COPYING for more details.
                            "
                            "============================================================================
                            
    3              0.000041 if exists('g:loaded_syntastic_sass_sassc_checker')
    2              0.000007     finish
                            endif
    1              0.000014 let g:loaded_syntastic_sass_sassc_checker = 1
                            
    1              0.000025 let s:save_cpo = &cpo
    1              0.000025 set cpo&vim
                            
    1              0.000011 function! SyntaxCheckers_sass_sassc_GetLocList() dict
                                let makeprg = self.makeprgBuild({ 'fname_after': syntastic#util#DevNull() })
                            
                                let errorformat = '%f:%l: %trror: %m'
                            
                                return SyntasticMake({
                                    \ 'makeprg': makeprg,
                                    \ 'errorformat': errorformat })
                            endfunction
                            
    1   0.000518   0.000029 call g:SyntasticRegistry.CreateAndRegisterChecker({
                                \ 'filetype': 'sass',
                                \ 'name': 'sassc'})
                            
    1              0.000016 let &cpo = s:save_cpo
    1              0.000010 unlet s:save_cpo
                            
                            " vim: set sw=4 sts=4 et fdm=marker:

SCRIPT  /home/pawelztef/.local/share/nvim/plugged/syntastic/syntax_checkers/scss/sass_lint.vim
Sourced 1 time
Total time:   0.001956
 Self time:   0.000272

count  total (s)   self (s)
                            "============================================================================
                            "File:        sass_lint.vim
                            "Description: Syntax checking plugin for syntastic
                            "Maintainer:  LCD 47 <lcd047 at gmail dot com>
                            "License:     This program is free software. It comes without any warranty,
                            "             to the extent permitted by applicable law. You can redistribute
                            "             it and/or modify it under the terms of the Do What The Fuck You
                            "             Want To Public License, Version 2, as published by Sam Hocevar.
                            "             See http://sam.zoy.org/wtfpl/COPYING for more details.
                            "
                            "============================================================================
                            
    1              0.000020 if exists('g:loaded_syntastic_scss_sass_lint_checker')
                                finish
                            endif
    1              0.000019 let g:loaded_syntastic_scss_sass_lint_checker = 1
                            
    1   0.001717   0.000033 call g:SyntasticRegistry.CreateAndRegisterChecker({
                                \ 'filetype': 'scss',
                                \ 'name': 'sass_lint',
                                \ 'redirect': 'sass/sass_lint'})
                            
                            " vim: set sw=4 sts=4 et fdm=marker:

SCRIPT  /home/pawelztef/.local/share/nvim/plugged/syntastic/syntax_checkers/scss/sassc.vim
Sourced 1 time
Total time:   0.002263
 Self time:   0.000341

count  total (s)   self (s)
                            "============================================================================
                            "File:        sassc.vim
                            "Description: Syntax checking plugin for syntastic
                            "Maintainer:  LCD 47 <lcd047 at gmail dot com>
                            "License:     This program is free software. It comes without any warranty,
                            "             to the extent permitted by applicable law. You can redistribute
                            "             it and/or modify it under the terms of the Do What The Fuck You
                            "             Want To Public License, Version 2, as published by Sam Hocevar.
                            "             See http://sam.zoy.org/wtfpl/COPYING for more details.
                            "
                            "============================================================================
                            
    1              0.000094 if exists('g:loaded_syntastic_scss_sassc_checker')
                                finish
                            endif
    1              0.000019 let g:loaded_syntastic_scss_sassc_checker = 1
                            
    1   0.001959   0.000037 call g:SyntasticRegistry.CreateAndRegisterChecker({
                                \ 'filetype': 'scss',
                                \ 'name': 'sassc',
                                \ 'redirect': 'sass/sassc'})
                            
                            " vim: set sw=4 sts=4 et fdm=marker:

SCRIPT  /home/pawelztef/.local/share/nvim/plugged/syntastic/syntax_checkers/scss/scss_lint.vim
Sourced 1 time
Total time:   0.001223
 Self time:   0.000553

count  total (s)   self (s)
                            "============================================================================
                            "File:        scss_lint.vim
                            "Description: SCSS style and syntax checker plugin for Syntastic
                            "Maintainer:  Shane da Silva <shane@dasilva.io>
                            "License:     This program is free software. It comes without any warranty,
                            "             to the extent permitted by applicable law. You can redistribute
                            "             it and/or modify it under the terms of the Do What The Fuck You
                            "             Want To Public License, Version 2, as published by Sam Hocevar.
                            "             See http://sam.zoy.org/wtfpl/COPYING for more details.
                            "============================================================================
                            
    1              0.000021 if exists('g:loaded_syntastic_scss_scss_lint_checker')
                                finish
                            endif
    1              0.000014 let g:loaded_syntastic_scss_scss_lint_checker = 1
                            
    1              0.000081 let s:save_cpo = &cpo
    1              0.000031 set cpo&vim
                            
    1              0.000012 function! SyntaxCheckers_scss_scss_lint_IsAvailable() dict
                                if !executable(self.getExec())
                                    return 0
                                endif
                                return syntastic#util#versionIsAtLeast(self.getVersion(), [0, 29])
                            endfunction
                            
    1              0.000010 function! SyntaxCheckers_scss_scss_lint_GetLocList() dict
                                let makeprg = self.makeprgBuild({ 'args_after': '-f JSON' })
                            
                                let errorformat = '%f:%t:%l:%c:%n:%m'
                            
                                let loclist = SyntasticMake({
                                    \ 'makeprg': makeprg,
                                    \ 'errorformat': errorformat,
                                    \ 'preprocess': 'scss_lint',
                                    \ 'postprocess': ['guards'],
                                    \ 'returns': [0, 1, 2, 65, 66] })
                            
                                let cutoff = strlen('Syntax Error: ')
                                for e in loclist
                                    if e['nr'] > 1
                                        let e['hl'] = '\%>' . (e['col'] - 1) . 'c\%<' . (e['col'] + e['nr']) . 'c'
                                    endif
                                    let e['nr'] = 0
                            
                                    if e['text'][: cutoff-1] ==# 'Syntax Error: '
                                        let e['text'] = e['text'][cutoff :]
                                    else
                                        let e['subtype'] = 'Style'
                                    endif
                                endfor
                            
                                return loclist
                            endfunction
                            
    1   0.000700   0.000030 call g:SyntasticRegistry.CreateAndRegisterChecker({
                                \ 'filetype': 'scss',
                                \ 'name': 'scss_lint',
                                \ 'exec': 'scss-lint' })
                            
    1              0.000021 let &cpo = s:save_cpo
    1              0.000006 unlet s:save_cpo
                            
                            " vim: set sw=4 sts=4 et fdm=marker:

SCRIPT  /home/pawelztef/.local/share/nvim/plugged/syntastic/syntax_checkers/scss/stylelint.vim
Sourced 1 time
Total time:   0.025406
 Self time:   0.000371

count  total (s)   self (s)
                            "============================================================================
                            "File:        stylelint.vim
                            "Description: Syntax checking plugin for syntastic
                            "Maintainer:  LCD 47 <lcd047 at gmail dot com>
                            "License:     This program is free software. It comes without any warranty,
                            "             to the extent permitted by applicable law. You can redistribute
                            "             it and/or modify it under the terms of the Do What The Fuck You
                            "             Want To Public License, Version 2, as published by Sam Hocevar.
                            "             See http://sam.zoy.org/wtfpl/COPYING for more details.
                            "
                            "============================================================================
                            
    1              0.000022 if exists('g:loaded_syntastic_scss_stylelint_checker')
                                finish
                            endif
    1              0.000014 let g:loaded_syntastic_scss_stylelint_checker = 1
                            
    1   0.025069   0.000034 call g:SyntasticRegistry.CreateAndRegisterChecker({
                                \ 'filetype': 'scss',
                                \ 'name': 'stylelint',
                                \ 'redirect': 'css/stylelint'})
                            
                            " vim: set sw=4 sts=4 et fdm=marker:

SCRIPT  /home/pawelztef/.local/share/nvim/plugged/syntastic/syntax_checkers/css/csslint.vim
Sourced 2 times
Total time:   0.001261
 Self time:   0.000585

count  total (s)   self (s)
                            "============================================================================
                            "File:        css.vim
                            "Description: Syntax checking plugin for syntastic using `csslint` CLI tool (http://csslint.net).
                            "Maintainer:  Ory Band <oryband at gmail dot com>
                            "License:     This program is free software. It comes without any warranty,
                            "             to the extent permitted by applicable law. You can redistribute
                            "             it and/or modify it under the terms of the Do What The Fuck You
                            "             Want To Public License, Version 2, as published by Sam Hocevar.
                            "             See http://sam.zoy.org/wtfpl/COPYING for more details.
                            "============================================================================
                            
    2              0.000037 if exists('g:loaded_syntastic_css_csslint_checker')
    1              0.000004     finish
                            endif
    1              0.000016 let g:loaded_syntastic_css_csslint_checker = 1
                            
    1              0.000029 let s:save_cpo = &cpo
    1              0.000077 set cpo&vim
                            
    1              0.000018 function! SyntaxCheckers_css_csslint_GetLocList() dict
                                call syntastic#log#deprecationWarn('csslint_options', 'css_csslint_args')
                            
                                let makeprg = self.makeprgBuild({ 'args_after': '--format=compact' })
                            
                                " Print CSS Lint's error/warning messages from compact format. Ignores blank lines.
                                let errorformat =
                                    \ '%-G,' .
                                    \ '%-G%f: lint free!,' .
                                    \ '%f: line %l\, col %c\, %trror - %m,' .
                                    \ '%f: line %l\, col %c\, %tarning - %m,'.
                                    \ '%f: line %l\, col %c\, %m,'
                            
                                return SyntasticMake({
                                    \ 'makeprg': makeprg,
                                    \ 'errorformat': errorformat,
                                    \ 'postprocess': ['guards'],
                                    \ 'defaults': {'bufnr': bufnr('')} })
                            
                            endfunction
                            
    1   0.000704   0.000028 call g:SyntasticRegistry.CreateAndRegisterChecker({
                                \ 'filetype': 'css',
                                \ 'name': 'csslint'})
                            
    1              0.000021 let &cpo = s:save_cpo
    1              0.000006 unlet s:save_cpo
                            
                            " vim: set sw=4 sts=4 et fdm=marker:

SCRIPT  /home/pawelztef/.local/share/nvim/plugged/syntastic/syntax_checkers/css/mixedindentlint.vim
Sourced 2 times
Total time:   0.003549
 Self time:   0.000408

count  total (s)   self (s)
                            "============================================================================
                            "File:        mixedindentlint.vim
                            "Description: Mixed indentation linter for vim
                            "Maintainer:  Payton Swick <payton@foolord.com>
                            "License:     This program is free software. It comes without any warranty,
                            "             to the extent permitted by applicable law. You can redistribute
                            "             it and/or modify it under the terms of the Do What The Fuck You
                            "             Want To Public License, Version 2, as published by Sam Hocevar.
                            "             See http://sam.zoy.org/wtfpl/COPYING for more details.
                            "============================================================================
                            
    2              0.000057 if exists('g:loaded_syntastic_css_mixedindentlint_checker')
    1              0.000004     finish
                            endif
    1              0.000014 let g:loaded_syntastic_css_mixedindentlint_checker = 1
                            
    1   0.003179   0.000038 call g:SyntasticRegistry.CreateAndRegisterChecker({
                                \ 'filetype': 'css',
                                \ 'name': 'mixedindentlint',
                                \ 'redirect': 'javascript/mixedindentlint'})
                            
                            " vim: set et sts=4 sw=4:

SCRIPT  /home/pawelztef/.local/share/nvim/plugged/syntastic/syntax_checkers/css/phpcs.vim
Sourced 2 times
Total time:   0.007702
 Self time:   0.000329

count  total (s)   self (s)
                            "============================================================================
                            "File:        phpcs.vim
                            "Description: Syntax checking plugin for syntastic
                            "Maintainer:  LCD 47 <lcd047 at gmail dot com>
                            "License:     This program is free software. It comes without any warranty,
                            "             to the extent permitted by applicable law. You can redistribute
                            "             it and/or modify it under the terms of the Do What The Fuck You
                            "             Want To Public License, Version 2, as published by Sam Hocevar.
                            "             See http://sam.zoy.org/wtfpl/COPYING for more details.
                            "
                            "============================================================================
                            
    2              0.000029 if exists('g:loaded_syntastic_css_phpcs_checker')
    1              0.000004     finish
                            endif
    1              0.000013 let g:loaded_syntastic_css_phpcs_checker = 1
                            
    1   0.007404   0.000032 call g:SyntasticRegistry.CreateAndRegisterChecker({
                                \ 'filetype': 'css',
                                \ 'name': 'phpcs',
                                \ 'redirect': 'php/phpcs'})
                            
                            " vim: set sw=4 sts=4 et fdm=marker:

SCRIPT  /home/pawelztef/.local/share/nvim/plugged/syntastic/syntax_checkers/php/php.vim
Sourced 1 time
Total time:   0.001106
 Self time:   0.000612

count  total (s)   self (s)
                            "============================================================================
                            "File:        php.vim
                            "Description: Syntax checking plugin for syntastic
                            "Maintainer:  Martin Grenfell <martin.grenfell at gmail dot com>
                            "License:     This program is free software. It comes without any warranty,
                            "             to the extent permitted by applicable law. You can redistribute
                            "             it and/or modify it under the terms of the Do What The Fuck You
                            "             Want To Public License, Version 2, as published by Sam Hocevar.
                            "             See http://sam.zoy.org/wtfpl/COPYING for more details.
                            "
                            "============================================================================
                            
    1              0.000021 if exists('g:loaded_syntastic_php_php_checker')
                                finish
                            endif
    1              0.000020 let g:loaded_syntastic_php_php_checker = 1
                            
    1              0.000030 let s:save_cpo = &cpo
    1              0.000029 set cpo&vim
                            
    1              0.000008 function! SyntaxCheckers_php_php_GetHighlightRegex(item)
                                let term = matchstr(a:item['text'], "\\munexpected '\\zs[^']\\+\\ze'")
                                return term !=# '' ? '\V' . escape(term, '\') : ''
                            endfunction
                            
    1              0.000007 function! SyntaxCheckers_php_php_GetLocList() dict
                                let makeprg = self.makeprgBuild({
                                    \ 'args': '-d error_reporting=E_ALL',
                                    \ 'args_after': '-l -d error_log= -d display_errors=1 -d log_errors=0 -d xdebug.cli_color=0' })
                            
                                let errorformat =
                                    \ '%-GNo syntax errors detected in%.%#,'.
                                    \ 'Parse error: %#syntax %trror\, %m in %f on line %l,'.
                                    \ 'Parse %trror: %m in %f on line %l,'.
                                    \ 'Fatal %trror: %m in %f on line %l,'.
                                    \ '%-G\s%#,'.
                                    \ '%-GErrors parsing %.%#'
                            
                                return SyntasticMake({
                                    \ 'makeprg': makeprg,
                                    \ 'errorformat': errorformat,
                                    \ 'postprocess': ['guards'] })
                            endfunction
                            
    1   0.000587   0.000093 call g:SyntasticRegistry.CreateAndRegisterChecker({
                                \ 'filetype': 'php',
                                \ 'name': 'php'})
                            
    1              0.000017 let &cpo = s:save_cpo
    1              0.000005 unlet s:save_cpo
                            
                            " vim: set sw=4 sts=4 et fdm=marker:

SCRIPT  /home/pawelztef/.local/share/nvim/plugged/syntastic/syntax_checkers/php/phpcs.vim
Sourced 1 time
Total time:   0.000916
 Self time:   0.000388

count  total (s)   self (s)
                            "============================================================================
                            "File:        phpcs.vim
                            "Description: Syntax checking plugin for syntastic
                            "Maintainer:  Martin Grenfell <martin.grenfell at gmail dot com>
                            "License:     This program is free software. It comes without any warranty,
                            "             to the extent permitted by applicable law. You can redistribute
                            "             it and/or modify it under the terms of the Do What The Fuck You
                            "             Want To Public License, Version 2, as published by Sam Hocevar.
                            "             See http://sam.zoy.org/wtfpl/COPYING for more details.
                            "
                            "============================================================================
                            
    1              0.000027 if exists('g:loaded_syntastic_php_phpcs_checker')
                                finish
                            endif
    1              0.000013 let g:loaded_syntastic_php_phpcs_checker = 1
                            
    1              0.000024 let s:save_cpo = &cpo
    1              0.000025 set cpo&vim
                            
    1              0.000011 function! SyntaxCheckers_php_phpcs_GetLocList() dict
                                let makeprg = self.makeprgBuild({ 'args_after': '--report=csv' })
                            
                                let errorformat =
                                    \ '%-GFile\,Line\,Column\,Type\,Message\,Source\,Severity%.%#,'.
                                    \ '"%f"\,%l\,%c\,%t%*[a-zA-Z]\,"%m"\,%*[a-zA-Z0-9_.-]\,%*[0-9]%.%#'
                            
                                return SyntasticMake({
                                    \ 'makeprg': makeprg,
                                    \ 'errorformat': errorformat,
                                    \ 'subtype': 'Style' })
                            endfunction
                            
    1   0.000558   0.000029 call g:SyntasticRegistry.CreateAndRegisterChecker({
                                \ 'filetype': 'php',
                                \ 'name': 'phpcs' })
                            
    1              0.000016 let &cpo = s:save_cpo
    1              0.000010 unlet s:save_cpo
                            
                            " vim: set sw=4 sts=4 et fdm=marker:

SCRIPT  /home/pawelztef/.local/share/nvim/plugged/syntastic/syntax_checkers/php/phplint.vim
Sourced 1 time
Total time:   0.001122
 Self time:   0.000667

count  total (s)   self (s)
                            "============================================================================
                            "File:        phplint.vim
                            "Description: Syntax checking plugin for syntastic
                            "Maintainer:  LCD 47 <lcd047 at gmail dot com>
                            "License:     This program is free software. It comes without any warranty,
                            "             to the extent permitted by applicable law. You can redistribute
                            "             it and/or modify it under the terms of the Do What The Fuck You
                            "             Want To Public License, Version 2, as published by Sam Hocevar.
                            "             See http://sam.zoy.org/wtfpl/COPYING for more details.
                            "
                            "============================================================================
                            
    1              0.000020 if exists('g:loaded_syntastic_php_phplint_checker')
                                finish
                            endif
    1              0.000013 let g:loaded_syntastic_php_phplint_checker = 1
                            
    1              0.000032 let s:save_cpo = &cpo
    1              0.000025 set cpo&vim
                            
    1              0.000013 function! SyntaxCheckers_php_phplint_GetHighlightRegex(item)
                                let term = matchstr(a:item['text'], '\munresolved function \zs\S\+\ze')
                                if term !=# ''
                                    return '\V' . escape(term, '\')
                                endif
                                let term = matchstr(a:item['text'], '\m\(class\|function\|method\) \zs\S\+\ze was declared as')
                                if term !=# ''
                                    return '\V' . escape(term, '\')
                                endif
                                let term = matchstr(a:item['text'], '\maccess forbidden to \(private\|protected\) \(class\|constant\|method\|variable\|\(private\|protected\) property\) \zs\S\+\ze')
                                if term !=# ''
                                    return '\V' . escape(term, '\')
                                endif
                                let term = matchstr(a:item['text'], '\musing deprecated \(class\|constant\|method\|property\|variable\) \zs\S\+\ze')
                                if term !=# ''
                                    return '\V' . escape(term, '\')
                                endif
                                let term = matchstr(a:item['text'], '\munresolved function \zs\S\+\ze')
                                if term !=# ''
                                    return '\V' . escape(term, '\')
                                endif
                                let term = matchstr(a:item['text'], '\munresolved function \zs\S\+\ze')
                                if term !=# ''
                                    return '\V' . escape(term, '\')
                                endif
                                let term = matchstr(a:item['text'], '\munresolved function \zs\S\+\ze')
                                return term !=# '' ? '\V' . escape(term, '\') : ''
                            endfunction
                            
    1              0.000023 function! SyntaxCheckers_php_phplint_GetLocList() dict
                                let makeprg = self.makeprgBuild({
                                    \ 'args_after':
                                    \   '--print-file-name ' .
                                    \   '--print-line-numbers ' .
                                    \   '--print-column-number ' .
                                    \   '--print-errors ' .
                                    \   '--print-warnings ' .
                                    \   '--no-print-notices ' .
                                    \   '--no-print-context ' .
                                    \   '--no-print-source ' .
                                    \   '--tab-size ' . &tabstop })
                            
                                let errorformat =
                                    \ '%E%f:%l:%v: %tRROR: %m,' .
                                    \ '%W%f:%l:%v: %tarning: %m,' .
                                    \ '%+C%\t%.%#,' .
                                    \ '%-G%.%#'
                            
                                let loclist = SyntasticMake({
                                    \ 'makeprg': makeprg,
                                    \ 'errorformat': errorformat,
                                    \ 'postprocess': ['compressWhitespace'],
                                    \ 'subtype': 'Style',
                                    \ 'returns': [0, 1] })
                            
                                for e in loclist
                                    let e['text'] = substitute(e['text'], '\m \(Hint\|Examples\):.*', '', '')
                                endfor
                            
                                return loclist
                            endfunction
                            
    1   0.000477   0.000023 call g:SyntasticRegistry.CreateAndRegisterChecker({
                                \ 'filetype': 'php',
                                \ 'name': 'phplint',
                                \ 'exec': 'phpl' })
                            
    1              0.000016 let &cpo = s:save_cpo
    1              0.000005 unlet s:save_cpo
                            
                            " vim: set sw=4 sts=4 et fdm=marker:

SCRIPT  /home/pawelztef/.local/share/nvim/plugged/syntastic/syntax_checkers/php/phpmd.vim
Sourced 1 time
Total time:   0.001004
 Self time:   0.000518

count  total (s)   self (s)
                            "============================================================================
                            "File:        phpmd.vim
                            "Description: Syntax checking plugin for syntastic
                            "Maintainer:  Martin Grenfell <martin.grenfell at gmail dot com>
                            "License:     This program is free software. It comes without any warranty,
                            "             to the extent permitted by applicable law. You can redistribute
                            "             it and/or modify it under the terms of the Do What The Fuck You
                            "             Want To Public License, Version 2, as published by Sam Hocevar.
                            "             See http://sam.zoy.org/wtfpl/COPYING for more details.
                            "
                            "============================================================================
                            
    1              0.000020 if exists('g:loaded_syntastic_php_phpmd_checker')
                                finish
                            endif
    1              0.000013 let g:loaded_syntastic_php_phpmd_checker = 1
                            
    1              0.000024 let s:save_cpo = &cpo
    1              0.000024 set cpo&vim
                            
    1              0.000012 function! SyntaxCheckers_php_phpmd_GetHighlightRegex(item)
                                let term = matchstr(a:item['text'], '\m\C^The \S\+ \w\+\(()\)\= \(has\|is not\|utilizes\)')
                                if term !=# ''
                                    return '\V'.substitute(term, '\m\C^The \S\+ \(\w\+\)\(()\)\= .*', '\1', '')
                                endif
                                let term = matchstr(a:item['text'], '\m\C^Avoid \(variables with short\|excessively long variable\) names like \S\+\.')
                                if term !=# ''
                                    return '\V'.substitute(term, '\m\C^Avoid \(variables with short\|excessively long variable\) names like \(\S\+\)\..*', '\2', '')
                                endif
                                let term = matchstr(a:item['text'], '\m\C^Avoid using short method names like \S\+::\S\+()\.')
                                if term !=# ''
                                    return '\V'.substitute(term, '\m\C^Avoid using short method names like \S\+::\(\S\+\)()\..*', '\1', '')
                                endif
                                let term = matchstr(a:item['text'], '\m\C^\S\+ accesses the super-global variable ')
                                if term !=# ''
                                    return '\V'.substitute(term, '\m\C accesses the super-global variable .*$', '', '')
                                endif
                                let term = matchstr(a:item['text'], '\m\C^Constant \S\+ should be defined in uppercase')
                                if term !=# ''
                                    return '\V'.substitute(term, '\m\C^Constant \(\S\+\) should be defined in uppercase', '\1', '')
                                endif
                                let term = matchstr(a:item['text'], "\\m\\C^The '\\S\\+()' method which returns ")
                                if term !=# ''
                                    return '\V'.substitute(term, "\\m\\C^The '\\(\\S\\+\\)()' method which returns.*", '\1', '')
                                endif
                                let term = matchstr(a:item['text'], '\m\C variable \S\+ should begin with ')
                                if term !=# ''
                                    return '\V'.substitute(term, '\m\C.* variable \(\S\+\) should begin with .*', '\1', '')
                                endif
                                let term = matchstr(a:item['text'], "\\m\\C^Avoid unused \\(private fields\\|local variables\\|private methods\\|parameters\\) such as '\\S\\+'")
                                if term !=# ''
                                    return '\V'.substitute(term, "\\m\\C^Avoid unused \\(private fields\\|local variables\\|private methods\\|parameters\\) such as '\\(\\S\\+\\)'.*", '\2', '')
                                endif
                                return ''
                            endfunction
                            
    1              0.000011 function! SyntaxCheckers_php_phpmd_GetLocList() dict
                                let makeprg = self.makeprgBuild({
                                    \ 'post_args_before': 'text',
                                    \ 'post_args': 'codesize,design,unusedcode,naming' })
                            
                                let errorformat = '%E%f:%l%\s%#%m'
                            
                                return SyntasticMake({
                                    \ 'makeprg': makeprg,
                                    \ 'errorformat': errorformat,
                                    \ 'subtype' : 'Style' })
                            endfunction
                            
    1   0.000522   0.000036 call g:SyntasticRegistry.CreateAndRegisterChecker({
                                \ 'filetype': 'php',
                                \ 'name': 'phpmd'})
                            
    1              0.000016 let &cpo = s:save_cpo
    1              0.000005 unlet s:save_cpo
                            
                            " vim: set sw=4 sts=4 et fdm=marker:

SCRIPT  /home/pawelztef/.local/share/nvim/plugged/syntastic/syntax_checkers/php/phpstan.vim
Sourced 1 time
Total time:   0.001067
 Self time:   0.000420

count  total (s)   self (s)
                            "============================================================================
                            "File:        phpstan.vim
                            "Description: Syntax checking plugin for syntastic
                            "Maintainer:  Przepompownia przepompownia@users.noreply.github.com
                            "License:     This program is free software. It comes without any warranty,
                            "             to the extent permitted by applicable law. You can redistribute
                            "             it and/or modify it under the terms of the Do What The Fuck You
                            "             Want To Public License, Version 2, as published by Sam Hocevar.
                            "             See http://sam.zoy.org/wtfpl/COPYING for more details.
                            "
                            "============================================================================
                            
    1              0.000027 if exists('g:loaded_syntastic_php_phpstan_checker')
                                finish
                            endif
    1              0.000014 let g:loaded_syntastic_php_phpstan_checker = 1
                            
    1              0.000024 let s:save_cpo = &cpo
    1              0.000025 set cpo&vim
                            
    1              0.000011 function! SyntaxCheckers_php_phpstan_IsAvailable() dict
                                if !executable(self.getExec())
                                    return 0
                                endif
                                return syntastic#util#versionIsAtLeast(self.getVersion(), [0, 8, 5])
                            endfunction
                            
    1              0.000009 function! SyntaxCheckers_php_phpstan_GetLocList() dict
                                let makeprg = self.makeprgBuild({
                                    \ 'exe_after': 'analyse',
                                    \ 'args': '--level=5',
                                    \ 'args_after': '--errorFormat raw' })
                            
                                let errorformat = '%f:%l:%m'
                            
                                return SyntasticMake({
                                    \ 'makeprg': makeprg,
                                    \ 'errorformat': errorformat,
                                    \ 'subtype' : 'Style' })
                            endfunction
                            
    1   0.000683   0.000036 call g:SyntasticRegistry.CreateAndRegisterChecker({
                                \ 'filetype': 'php',
                                \ 'name': 'phpstan'})
                            
    1              0.000018 let &cpo = s:save_cpo
    1              0.000005 unlet s:save_cpo
                            
                            " vim: set sw=4 sts=4 et fdm=marker:

SCRIPT  /home/pawelztef/.local/share/nvim/plugged/syntastic/syntax_checkers/css/prettycss.vim
Sourced 2 times
Total time:   0.001295
 Self time:   0.000785

count  total (s)   self (s)
                            "============================================================================
                            "File:        prettycss.vim
                            "Description: Syntax checking plugin for syntastic
                            "Maintainer:  LCD 47 <lcd047 at gmail dot com>
                            "License:     This program is free software. It comes without any warranty,
                            "             to the extent permitted by applicable law. You can redistribute
                            "             it and/or modify it under the terms of the Do What The Fuck You
                            "             Want To Public License, Version 2, as published by Sam Hocevar.
                            "             See http://sam.zoy.org/wtfpl/COPYING for more details.
                            "
                            "============================================================================
                            
    2              0.000030 if exists('g:loaded_syntastic_css_prettycss_checker')
    1              0.000004     finish
                            endif
    1              0.000014 let g:loaded_syntastic_css_prettycss_checker = 1
                            
    1              0.000013 if !exists('g:syntastic_css_prettycss_sort')
    1              0.000012     let g:syntastic_css_prettycss_sort = 1
    1              0.000004 endif
                            
    1              0.000024 let s:save_cpo = &cpo
    1              0.000025 set cpo&vim
                            
    1              0.000012 function! SyntaxCheckers_css_prettycss_GetHighlightRegex(item)
                                let term = matchstr(a:item['text'], '\m (\zs[^)]\+\ze)$')
                                if term !=# ''
                                    let term = '\V' . escape(term, '\')
                                endif
                                return term
                            endfunction
                            
    1              0.000011 function! SyntaxCheckers_css_prettycss_GetLocList() dict
                                let makeprg = self.makeprgBuild({})
                            
                                " Print CSS Lint's error/warning messages from compact format. Ignores blank lines.
                                let errorformat =
                                    \ '%EError:  %m\, line %l\, char %c),' .
                                    \ '%WWarning:  %m\, line %l\, char %c),' .
                                    \ '%-G%.%#'
                            
                                let loclist = SyntasticMake({
                                    \ 'makeprg': makeprg,
                                    \ 'errorformat': errorformat,
                                    \ 'defaults': {'bufnr': bufnr('')} })
                            
                                for e in loclist
                                    let e['text'] .= ')'
                                endfor
                            
                                return loclist
                            endfunction
                            
    1   0.000528   0.000019 call g:SyntasticRegistry.CreateAndRegisterChecker({
                                \ 'filetype': 'css',
                                \ 'name': 'prettycss'})
                            
    1              0.000018 let &cpo = s:save_cpo
    1              0.000005 unlet s:save_cpo
                            
                            " vim: set sw=4 sts=4 et fdm=marker:

SCRIPT  /home/pawelztef/.local/share/nvim/plugged/syntastic/syntax_checkers/css/recess.vim
Sourced 2 times
Total time: 34229.700162
 Self time: 34229.691559

count  total (s)   self (s)
                            "============================================================================
                            "File:        recess.vim
                            "Description: Syntax checking plugin for syntastic using `recess`
                            "             (http://twitter.github.io/recess/).
                            "Maintainer:  Tim Carry <tim at pixelastic dot com>
                            "License:     This program is free software. It comes without any warranty,
                            "             to the extent permitted by applicable law. You can redistribute
                            "             it and/or modify it under the terms of the Do What The Fuck You
                            "             Want To Public License, Version 2, as published by Sam Hocevar.
                            "             See http://sam.zoy.org/wtfpl/COPYING for more details.
                            "
                            "============================================================================
                            
    2              0.000021 if exists('g:loaded_syntastic_css_recess_checker')
    1              0.000003     finish
                            endif
    1              0.000007 let g:loaded_syntastic_css_recess_checker = 1
                            
    1              0.005713 call g:SyntasticRegistry.CreateAndRegisterChecker({
                                \ 'filetype': 'css',
                                \ 'name': 'recess',
                                \ 'redirect': 'less/recess'})
                            
                            " vim: set sw=4 sts=4 et fdm=marker:

SCRIPT  /home/pawelztef/.local/share/nvim/plugged/syntastic/syntax_checkers/less/lessc.vim
Sourced 1 time
Total time:   0.001451
 Self time:   0.000755

count  total (s)   self (s)
                            "============================================================================
                            "File:        less.vim
                            "Description: Syntax checking plugin for syntastic
                            "Maintainer:  Julien Blanchard <julien at sideburns dot eu>
                            "License:     This program is free software. It comes without any warranty,
                            "             to the extent permitted by applicable law. You can redistribute
                            "             it and/or modify it under the terms of the Do What The Fuck You
                            "             Want To Public License, Version 2, as published by Sam Hocevar.
                            "             See http://sam.zoy.org/wtfpl/COPYING for more details.
                            "
                            "============================================================================
                            
    1              0.000025 if exists('g:loaded_syntastic_less_lessc_checker')
                                finish
                            endif
    1              0.000016 let g:loaded_syntastic_less_lessc_checker = 1
                            
    1              0.000022 if !exists('g:syntastic_less_use_less_lint')
    1              0.000012     let g:syntastic_less_use_less_lint = 0
    1              0.000008 endif
                            
    1              0.000032 let s:save_cpo = &cpo
    1              0.000027 set cpo&vim
                            
    1   0.000246   0.000153 let s:node_file = 'node ' . syntastic#util#shescape(expand('<sfile>:p:h', 1) . syntastic#util#Slash() . 'less-lint.js')
                            
    1              0.000008 function! SyntaxCheckers_less_lessc_IsAvailable() dict
                                call self.log('g:syntastic_less_use_less_lint =', g:syntastic_less_use_less_lint)
                                return g:syntastic_less_use_less_lint ? executable('node') : executable(self.getExec())
                            endfunction
                            
    1              0.000006 function! SyntaxCheckers_less_lessc_GetLocList() dict
                                call syntastic#log#deprecationWarn('less_options', 'less_lessc_args')
                            
                                let makeprg = self.makeprgBuild({
                                    \ 'exe': (g:syntastic_less_use_less_lint ? s:node_file : self.getExecEscaped()),
                                    \ 'args_after': '--no-color',
                                    \ 'tail': '> ' . syntastic#util#DevNull() })
                            
                                let errorformat =
                                    \ '%m in %f on line %l\, column %c:,' .
                                    \ '%m in %f:%l:%c,' .
                                    \ '%-G%.%#'
                            
                                return SyntasticMake({
                                    \ 'makeprg': makeprg,
                                    \ 'errorformat': errorformat,
                                    \ 'postprocess': ['guards'],
                                    \ 'defaults': {'bufnr': bufnr(''), 'text': 'Syntax error'} })
                            endfunction
                            
    1   0.000622   0.000019 call g:SyntasticRegistry.CreateAndRegisterChecker({
                                \ 'filetype': 'less',
                                \ 'name': 'lessc'})
                            
    1              0.000065 let &cpo = s:save_cpo
    1              0.000006 unlet s:save_cpo
                            
                            " vim: set sw=4 sts=4 et fdm=marker:

SCRIPT  /home/pawelztef/.local/share/nvim/plugged/syntastic/syntax_checkers/less/recess.vim
Sourced 1 time
Total time:   0.001141
 Self time:   0.000510

count  total (s)   self (s)
                            "============================================================================
                            "File:        recess.vim
                            "Description: Syntax checking plugin for syntastic using `recess`
                            "             (http://twitter.github.io/recess/).
                            "Maintainer:  Tim Carry <tim at pixelastic dot com>
                            "License:     This program is free software. It comes without any warranty,
                            "             to the extent permitted by applicable law. You can redistribute
                            "             it and/or modify it under the terms of the Do What The Fuck You
                            "             Want To Public License, Version 2, as published by Sam Hocevar.
                            "             See http://sam.zoy.org/wtfpl/COPYING for more details.
                            "
                            "============================================================================
                            
    1              0.000022 if exists('g:loaded_syntastic_less_recess_checker')
                                finish
                            endif
    1              0.000014 let g:loaded_syntastic_less_recess_checker = 1
                            
    1              0.000026 let s:save_cpo = &cpo
    1              0.000075 set cpo&vim
                            
    1              0.000013 function! SyntaxCheckers_less_recess_GetLocList() dict
                                let makeprg = self.makeprgBuild({
                                    \ 'post_args_after': '--format=compact --stripColors' })
                            
                                let errorformat =
                                    \ '%E%m in %f,' .
                                    \ '%Z %#%l.%.%#,' .
                                    \ '%f:%l:%m,' .
                                    \ '%-G%.%#'
                            
                                return SyntasticMake({
                                    \ 'makeprg': makeprg,
                                    \ 'errorformat': errorformat })
                            endfunction
                            
    1   0.000662   0.000032 call g:SyntasticRegistry.CreateAndRegisterChecker({
                                \ 'filetype': 'less',
                                \ 'name': 'recess'})
                            
    1              0.000018 let &cpo = s:save_cpo
    1              0.000005 unlet s:save_cpo
                            
                            " vim: set sw=4 sts=4 et fdm=marker:

SCRIPT  /home/pawelztef/.local/share/nvim/plugged/syntastic/syntax_checkers/less/stylelint.vim
Sourced 1 time
Total time:   0.003934
 Self time:   0.000427

count  total (s)   self (s)
                            "============================================================================
                            "File:        stylelint.vim
                            "Description: Syntax checking plugin for syntastic
                            "Maintainer:  LCD 47 <lcd047 at gmail dot com>
                            "License:     This program is free software. It comes without any warranty,
                            "             to the extent permitted by applicable law. You can redistribute
                            "             it and/or modify it under the terms of the Do What The Fuck You
                            "             Want To Public License, Version 2, as published by Sam Hocevar.
                            "             See http://sam.zoy.org/wtfpl/COPYING for more details.
                            "
                            "============================================================================
                            
    1              0.000022 if exists('g:loaded_syntastic_less_stylelint_checker')
                                finish
                            endif
    1              0.000015 let g:loaded_syntastic_less_stylelint_checker = 1
                            
    1   0.003540   0.000033 call g:SyntasticRegistry.CreateAndRegisterChecker({
                                \ 'filetype': 'less',
                                \ 'name': 'stylelint',
                                \ 'redirect': 'css/stylelint'})
                            
                            " vim: set sw=4 sts=4 et fdm=marker:

SCRIPT  /home/pawelztef/.local/share/nvim/plugged/syntastic/syntax_checkers/css/stylelint.vim
Sourced 2 times
Total time:   0.001178
 Self time:   0.000680

count  total (s)   self (s)
                            "============================================================================
                            "File:        stylelint.vim
                            "Description: Syntax checking plugin for syntastic using `stylelint`
                            "             (https://github.com/stylelint/stylelint).
                            "Maintainer:  Tim Carry <tim at pixelastic dot com>
                            "License:     This program is free software. It comes without any warranty,
                            "             to the extent permitted by applicable law. You can redistribute
                            "             it and/or modify it under the terms of the Do What The Fuck You
                            "             Want To Public License, Version 2, as published by Sam Hocevar.
                            "             See http://sam.zoy.org/wtfpl/COPYING for more details.
                            "
                            "============================================================================
                            
    2              0.000031 if exists('g:loaded_syntastic_css_stylelint_checker')
    1              0.000003     finish
                            endif
    1              0.000016 let g:loaded_syntastic_css_stylelint_checker = 1
                            
    1              0.000028 let s:save_cpo = &cpo
    1              0.000027 set cpo&vim
                            
    1              0.000029 let s:args_after = {
                                \ 'css':  '-f json',
                                \ 'html': '-f json',
                                \ 'less': '-f json -s less',
                                \ 'scss': '-f json -s scss' }
                            
    1              0.000012 function! SyntaxCheckers_css_stylelint_GetLocList() dict
                                let makeprg = self.makeprgBuild({ 'args_after': get(s:args_after, self.getFiletype(), '') })
                            
                                let errorformat = '%t:%f:%l:%c:%m'
                            
                                return SyntasticMake({
                                    \ 'makeprg': makeprg,
                                    \ 'errorformat': errorformat,
                                    \ 'subtype': 'Style',
                                    \ 'preprocess': 'stylelint',
                                    \ 'returns': [0, 1, 2] })
                            endfunction
                            
    1   0.000517   0.000019 call g:SyntasticRegistry.CreateAndRegisterChecker({
                                \ 'filetype': 'css',
                                \ 'name': 'stylelint'})
                            
    1              0.000017 let &cpo = s:save_cpo
    1              0.000005 unlet s:save_cpo
                            
                            " vim: set sw=4 sts=4 et fdm=marker:
                            

SCRIPT  /home/pawelztef/.local/share/nvim/plugged/syntastic/autoload/syntastic/postprocess.vim
Sourced 1 time
Total time:   0.000711
 Self time:   0.000711

count  total (s)   self (s)
    1              0.000038 if exists('g:loaded_syntastic_postprocess_autoload') || !exists('g:loaded_syntastic_plugin')
                                finish
                            endif
    1              0.000021 let g:loaded_syntastic_postprocess_autoload = 1
                            
    1              0.000038 let s:save_cpo = &cpo
    1              0.000028 set cpo&vim
                            
                            " Public functions {{{1
                            
                            " merge consecutive blanks
    1              0.000015 function! syntastic#postprocess#compressWhitespace(errors) abort " {{{2
                                for e in a:errors
                                    let e['text'] = substitute(e['text'], "\001", '', 'g')
                                    let e['text'] = substitute(e['text'], '\n', ' ', 'g')
                                    let e['text'] = substitute(e['text'], '\m\s\{2,}', ' ', 'g')
                                    let e['text'] = substitute(e['text'], '\m^\s\+', '', '')
                                    let e['text'] = substitute(e['text'], '\m\s\+$', '', '')
                                endfor
                            
                                return a:errors
                            endfunction " }}}2
                            
                            " remove spurious CR under Cygwin
    1              0.000008 function! syntastic#postprocess#cygwinRemoveCR(errors) abort " {{{2
                                if has('win32unix')
                                    for e in a:errors
                                        let e['text'] = substitute(e['text'], '\r', '', 'g')
                                    endfor
                                endif
                            
                                return a:errors
                            endfunction " }}}2
                            
                            " decode XML entities
    1              0.000008 function! syntastic#postprocess#decodeXMLEntities(errors) abort " {{{2
                                for e in a:errors
                                    let e['text'] = syntastic#util#decodeXMLEntities(e['text'])
                                endfor
                            
                                return a:errors
                            endfunction " }}}2
                            
                            " filter out errors referencing other files
    1              0.000008 function! syntastic#postprocess#filterForeignErrors(errors) abort " {{{2
                                return filter(copy(a:errors), 'get(v:val, "bufnr") == ' . bufnr(''))
                            endfunction " }}}2
                            
                            " make sure line numbers are not past end of buffers
                            " XXX: this loads all referenced buffers in memory
    1              0.000008 function! syntastic#postprocess#guards(errors) abort " {{{2
                                let buffers = syntastic#util#unique(map(filter(copy(a:errors), 'v:val["valid"]'), 'str2nr(v:val["bufnr"])'))
                            
                                let guards = {}
                                for b in buffers
                                    let guards[b] = len(getbufline(b, 1, '$'))
                                endfor
                            
                                for e in a:errors
                                    if e['valid'] && e['lnum'] > guards[e['bufnr']]
                                        let e['lnum'] = guards[e['bufnr']]
                                    endif
                                endfor
                            
                                return a:errors
                            endfunction " }}}2
                            
                            " convert error messages from UTF-8 to the current encoding
    1              0.000007 function! syntastic#postprocess#iconv(errors) abort " {{{2
                                if has('iconv') && &encoding !=# '' && &encoding !=# 'utf-8'
                                    for e in a:errors
                                        let e['text'] = iconv(e['text'], "utf-8", &encoding)
                                    endfor
                                endif
                            
                                return a:errors
                            endfunction " }}}2
                            
                            " }}}1
                            
    1              0.000020 let &cpo = s:save_cpo
    1              0.000006 unlet s:save_cpo
                            
                            " vim: set sw=4 sts=4 et fdm=marker:

SCRIPT  /home/pawelztef/.local/share/nvim/plugged/vim-gitgutter/autoload/gitgutter/diff.vim
Sourced 1 time
Total time:   0.009093
 Self time:   0.001325

count  total (s)   self (s)
    1              0.000014 if exists('g:gitgutter_grep_command')
                              let s:grep_available = 1
                              let s:grep_command = g:gitgutter_grep_command
                            else
    1              0.000092   let s:grep_available = executable('grep')
    1              0.000006   if s:grep_available
    1              0.000006     let s:grep_command = 'grep'
    1              0.000015     if $GREP_OPTIONS =~# '--color=always'
                                  let s:grep_command .= ' --color=never'
                                endif
    1              0.000003   endif
    1              0.000003 endif
    1              0.000007 let s:hunk_re = '^@@ -\(\d\+\),\?\(\d*\) +\(\d\+\),\?\(\d*\) @@'
                            
    1   0.007829   0.000061 let s:c_flag = gitgutter#utility#git_supports_command_line_config_override()
                            
    1              0.000020 let s:temp_index = tempname()
    1              0.000011 let s:temp_buffer = tempname()
                            
                            " Returns a diff of the buffer.
                            "
                            " The way to get the diff depends on whether the buffer is saved or unsaved.
                            "
                            " * Saved: the buffer contents is the same as the file on disk in the working
                            "   tree so we simply do:
                            "
                            "       git diff myfile
                            "
                            " * Unsaved: the buffer contents is not the same as the file on disk so we
                            "   need to pass two instances of the file to git-diff:
                            "
                            "       git diff myfileA myfileB
                            "
                            "   The first instance is the file in the index which we obtain with:
                            "
                            "       git show :myfile > myfileA
                            "
                            "   The second instance is the buffer contents.  Ideally we would pass this to
                            "   git-diff on stdin via the second argument to vim's system() function.
                            "   Unfortunately git-diff does not do CRLF conversion for input received on
                            "   stdin, and git-show never performs CRLF conversion, so repos with CRLF
                            "   conversion report that every line is modified due to mismatching EOLs.
                            "
                            "   Instead, we write the buffer contents to a temporary file - myfileB in this
                            "   example.  Note the file extension must be preserved for the CRLF
                            "   conversion to work.
                            "
                            " Before diffing a buffer for the first time, we check whether git knows about
                            " the file:
                            "
                            "     git ls-files --error-unmatch myfile
                            "
                            " After running the diff we pass it through grep where available to reduce
                            " subsequent processing by the plugin.  If grep is not available the plugin
                            " does the filtering instead.
    1              0.000021 function! gitgutter#diff#run_diff(realtime, preserve_full_diff) abort
                              " Wrap compound commands in parentheses to make Windows happy.
                              " bash doesn't mind the parentheses.
                              let cmd = '('
                            
                              let bufnr = gitgutter#utility#bufnr()
                              let tracked = gitgutter#utility#getbufvar(bufnr, 'tracked', 0)  " i.e. tracked by git
                              if !tracked
                                " Don't bother trying to realtime-diff an untracked file.
                                " NOTE: perhaps we should pull this guard up to the caller?
                                if a:realtime
                                  throw 'diff failed'
                                else
                                  let cmd .= g:gitgutter_git_executable.' ls-files --error-unmatch '.gitgutter#utility#shellescape(gitgutter#utility#filename()).' && ('
                                endif
                              endif
                            
                              if a:realtime
                                let blob_name = g:gitgutter_diff_base.':'.gitgutter#utility#shellescape(gitgutter#utility#file_relative_to_repo_root())
                                let blob_file = s:temp_index
                                let buff_file = s:temp_buffer
                                let extension = gitgutter#utility#extension()
                                if !empty(extension)
                                  let blob_file .= '.'.extension
                                  let buff_file .= '.'.extension
                                endif
                                let cmd .= g:gitgutter_git_executable.' show '.blob_name.' > '.blob_file.' && '
                            
                                " Writing the whole buffer resets the '[ and '] marks and also the
                                " 'modified' flag (if &cpoptions includes '+').  These are unwanted
                                " side-effects so we save and restore the values ourselves.
                                let modified      = getbufvar(bufnr, "&mod")
                                let op_mark_start = getpos("'[")
                                let op_mark_end   = getpos("']")
                            
                                execute 'keepalt noautocmd silent write!' buff_file
                            
                                call setbufvar(bufnr, "&mod", modified)
                                call setpos("'[", op_mark_start)
                                call setpos("']", op_mark_end)
                              endif
                            
                              let cmd .= g:gitgutter_git_executable
                              if s:c_flag
                                let cmd .= ' -c "diff.autorefreshindex=0"'
                                let cmd .= ' -c "diff.noprefix=false"'
                              endif
                              let cmd .= ' diff --no-ext-diff --no-color -U0 '.g:gitgutter_diff_args.' '
                            
                              if a:realtime
                                let cmd .= ' -- '.blob_file.' '.buff_file
                              else
                                let cmd .= g:gitgutter_diff_base.' -- '.gitgutter#utility#shellescape(gitgutter#utility#filename())
                              endif
                            
                              if !a:preserve_full_diff && s:grep_available
                                let cmd .= ' | '.s:grep_command.' '.gitgutter#utility#shellescape('^@@ ')
                              endif
                            
                              if (!a:preserve_full_diff && s:grep_available) || a:realtime
                                " grep exits with 1 when no matches are found; diff exits with 1 when
                                " differences are found.  However we want to treat non-matches and
                                " differences as non-erroneous behaviour; so we OR the command with one
                                " which always exits with success (0).
                                let cmd .= ' || exit 0'
                              endif
                            
                              let cmd .= ')'
                            
                              if !tracked
                                let cmd .= ')'
                              endif
                            
                              let cmd = gitgutter#utility#command_in_directory_of_file(cmd)
                            
                              if g:gitgutter_async && gitgutter#async#available() && !a:preserve_full_diff
                                call gitgutter#async#execute(cmd)
                                return 'async'
                            
                              else
                                let diff = gitgutter#utility#system(cmd)
                            
                                if gitgutter#utility#shell_error()
                                  " A shell error indicates the file is not tracked by git (unless something bizarre is going on).
                                  throw 'diff failed'
                                endif
                            
                                return diff
                              endif
                            endfunction
                            
    1              0.000008 function! gitgutter#diff#parse_diff(diff) abort
                              let hunks = []
                              for line in split(a:diff, '\n')
                                let hunk_info = gitgutter#diff#parse_hunk(line)
                                if len(hunk_info) == 4
                                  call add(hunks, hunk_info)
                                endif
                              endfor
                              return hunks
                            endfunction
                            
    1              0.000006 function! gitgutter#diff#parse_hunk(line) abort
                              let matches = matchlist(a:line, s:hunk_re)
                              if len(matches) > 0
                                let from_line  = str2nr(matches[1])
                                let from_count = (matches[2] == '') ? 1 : str2nr(matches[2])
                                let to_line    = str2nr(matches[3])
                                let to_count   = (matches[4] == '') ? 1 : str2nr(matches[4])
                                return [from_line, from_count, to_line, to_count]
                              else
                                return []
                              end
                            endfunction
                            
    1              0.000006 function! gitgutter#diff#process_hunks(hunks) abort
                              let modified_lines = []
                              for hunk in a:hunks
                                call extend(modified_lines, gitgutter#diff#process_hunk(hunk))
                              endfor
                              return modified_lines
                            endfunction
                            
                            " Returns [ [<line_number (number)>, <name (string)>], ...]
    1              0.000007 function! gitgutter#diff#process_hunk(hunk) abort
                              let modifications = []
                              let from_line  = a:hunk[0]
                              let from_count = a:hunk[1]
                              let to_line    = a:hunk[2]
                              let to_count   = a:hunk[3]
                            
                              if gitgutter#diff#is_added(from_count, to_count)
                                call gitgutter#diff#process_added(modifications, from_count, to_count, to_line)
                                call gitgutter#hunk#increment_lines_added(to_count)
                            
                              elseif gitgutter#diff#is_removed(from_count, to_count)
                                call gitgutter#diff#process_removed(modifications, from_count, to_count, to_line)
                                call gitgutter#hunk#increment_lines_removed(from_count)
                            
                              elseif gitgutter#diff#is_modified(from_count, to_count)
                                call gitgutter#diff#process_modified(modifications, from_count, to_count, to_line)
                                call gitgutter#hunk#increment_lines_modified(to_count)
                            
                              elseif gitgutter#diff#is_modified_and_added(from_count, to_count)
                                call gitgutter#diff#process_modified_and_added(modifications, from_count, to_count, to_line)
                                call gitgutter#hunk#increment_lines_added(to_count - from_count)
                                call gitgutter#hunk#increment_lines_modified(from_count)
                            
                              elseif gitgutter#diff#is_modified_and_removed(from_count, to_count)
                                call gitgutter#diff#process_modified_and_removed(modifications, from_count, to_count, to_line)
                                call gitgutter#hunk#increment_lines_modified(to_count)
                                call gitgutter#hunk#increment_lines_removed(from_count - to_count)
                            
                              endif
                              return modifications
                            endfunction
                            
    1              0.000007 function! gitgutter#diff#is_added(from_count, to_count) abort
                              return a:from_count == 0 && a:to_count > 0
                            endfunction
                            
    1              0.000006 function! gitgutter#diff#is_removed(from_count, to_count) abort
                              return a:from_count > 0 && a:to_count == 0
                            endfunction
                            
    1              0.000006 function! gitgutter#diff#is_modified(from_count, to_count) abort
                              return a:from_count > 0 && a:to_count > 0 && a:from_count == a:to_count
                            endfunction
                            
    1              0.000007 function! gitgutter#diff#is_modified_and_added(from_count, to_count) abort
                              return a:from_count > 0 && a:to_count > 0 && a:from_count < a:to_count
                            endfunction
                            
    1              0.000007 function! gitgutter#diff#is_modified_and_removed(from_count, to_count) abort
                              return a:from_count > 0 && a:to_count > 0 && a:from_count > a:to_count
                            endfunction
                            
    1              0.000008 function! gitgutter#diff#process_added(modifications, from_count, to_count, to_line) abort
                              let offset = 0
                              while offset < a:to_count
                                let line_number = a:to_line + offset
                                call add(a:modifications, [line_number, 'added'])
                                let offset += 1
                              endwhile
                            endfunction
                            
    1              0.000008 function! gitgutter#diff#process_removed(modifications, from_count, to_count, to_line) abort
                              if a:to_line == 0
                                call add(a:modifications, [1, 'removed_first_line'])
                              else
                                call add(a:modifications, [a:to_line, 'removed'])
                              endif
                            endfunction
                            
    1              0.000007 function! gitgutter#diff#process_modified(modifications, from_count, to_count, to_line) abort
                              let offset = 0
                              while offset < a:to_count
                                let line_number = a:to_line + offset
                                call add(a:modifications, [line_number, 'modified'])
                                let offset += 1
                              endwhile
                            endfunction
                            
    1              0.000008 function! gitgutter#diff#process_modified_and_added(modifications, from_count, to_count, to_line) abort
                              let offset = 0
                              while offset < a:from_count
                                let line_number = a:to_line + offset
                                call add(a:modifications, [line_number, 'modified'])
                                let offset += 1
                              endwhile
                              while offset < a:to_count
                                let line_number = a:to_line + offset
                                call add(a:modifications, [line_number, 'added'])
                                let offset += 1
                              endwhile
                            endfunction
                            
    1              0.000008 function! gitgutter#diff#process_modified_and_removed(modifications, from_count, to_count, to_line) abort
                              let offset = 0
                              while offset < a:to_count
                                let line_number = a:to_line + offset
                                call add(a:modifications, [line_number, 'modified'])
                                let offset += 1
                              endwhile
                              let a:modifications[-1] = [a:to_line + offset - 1, 'modified_removed']
                            endfunction
                            
                            " Generates a zero-context diff for the current hunk.
                            "
                            " diff - the full diff for the buffer
                            " type - stage | undo | preview
    1              0.000007 function! gitgutter#diff#generate_diff_for_hunk(diff, type) abort
                              let diff_for_hunk = gitgutter#diff#discard_hunks(a:diff, a:type == 'stage' || a:type == 'undo')
                            
                              if a:type == 'stage' || a:type == 'undo'
                                let diff_for_hunk = gitgutter#diff#adjust_hunk_summary(diff_for_hunk, a:type == 'stage')
                              endif
                            
                              return diff_for_hunk
                            endfunction
                            
                            " Returns the diff with all hunks discarded except the current.
                            "
                            " diff        - the diff to process
                            " keep_header - truthy to keep the diff header and hunk summary, falsy to discard it
    1              0.000008 function! gitgutter#diff#discard_hunks(diff, keep_header) abort
                              let modified_diff = []
                              let keep_line = a:keep_header
                              for line in split(a:diff, '\n')
                                let hunk_info = gitgutter#diff#parse_hunk(line)
                                if len(hunk_info) == 4  " start of new hunk
                                  let keep_line = gitgutter#hunk#cursor_in_hunk(hunk_info)
                                endif
                                if keep_line
                                  call add(modified_diff, line)
                                endif
                              endfor
                            
                              if a:keep_header
                                return gitgutter#utility#stringify(modified_diff)
                              else
                                " Discard hunk summary too.
                                return gitgutter#utility#stringify(modified_diff[1:])
                              endif
                            endfunction
                            
                            " Adjust hunk summary (from's / to's line number) to ignore changes above/before this one.
                            "
                            " diff_for_hunk - a diff containing only the hunk of interest
                            " staging       - truthy if the hunk is to be staged, falsy if it is to be undone
                            "
                            " TODO: push this down to #discard_hunks?
    1              0.000006 function! gitgutter#diff#adjust_hunk_summary(diff_for_hunk, staging) abort
                              let line_adjustment = gitgutter#hunk#line_adjustment_for_current_hunk()
                              let adj_diff = []
                              for line in split(a:diff_for_hunk, '\n')
                                if match(line, s:hunk_re) != -1
                                  if a:staging
                                    " increment 'to' line number
                                    let line = substitute(line, '+\@<=\(\d\+\)', '\=submatch(1)+line_adjustment', '')
                                  else
                                    " decrement 'from' line number
                                    let line = substitute(line, '-\@<=\(\d\+\)', '\=submatch(1)-line_adjustment', '')
                                  endif
                                endif
                                call add(adj_diff, line)
                              endfor
                              return gitgutter#utility#stringify(adj_diff)
                            endfunction
                            

SCRIPT  /home/pawelztef/.local/share/nvim/plugged/vim-gitgutter/autoload/gitgutter/async.vim
Sourced 1 time
Total time:   0.000348
 Self time:   0.000348

count  total (s)   self (s)
    1              0.000026 let s:available = has('nvim') || (
                                  \   has('job') && (
                                  \     (has('patch-7-4-1826') && !has('gui_running')) ||
                                  \     (has('patch-7-4-1850') &&  has('gui_running')) ||
                                  \     (has('patch-7-4-1832') &&  has('gui_macvim'))
                                  \   )
                                  \ )
                            
    1              0.000008 function! gitgutter#async#available()
                              return s:available
                            endfunction
                            
                            
    1              0.000006 function! gitgutter#async#execute(cmd) abort
                              let options = {
                                    \   'stdoutbuffer': [],
                                    \   'buffer': gitgutter#utility#bufnr()
                                    \ }
                              let command = s:build_command(a:cmd)
                            
                              if has('nvim')
                                call jobstart(command, extend(options, {
                                      \   'on_stdout': function('s:on_stdout_nvim'),
                                      \   'on_stderr': function('s:on_stderr_nvim'),
                                      \   'on_exit':   function('s:on_exit_nvim')
                                      \ }))
                              else
                                call job_start(command, {
                                      \   'out_cb':   function('s:on_stdout_vim', options),
                                      \   'err_cb':   function('s:on_stderr_vim', options),
                                      \   'close_cb': function('s:on_exit_vim', options)
                                      \ })
                              endif
                            endfunction
                            
                            
    1              0.000006 function! s:build_command(cmd)
                              if has('unix')
                                return ['sh', '-c', a:cmd]
                              endif
                            
                              if has('win32')
                                return has('nvim') ? ['cmd.exe', '/c', a:cmd] : 'cmd.exe /c '.a:cmd
                              endif
                            
                              throw 'unknown os'
                            endfunction
                            
                            
    1              0.000007 function! s:on_stdout_nvim(_job_id, data, _event) dict abort
                              if empty(self.stdoutbuffer)
                                let self.stdoutbuffer = a:data
                              else
                                let self.stdoutbuffer = self.stdoutbuffer[:-2] +
                                      \ [self.stdoutbuffer[-1] . a:data[0]] +
                                      \ a:data[1:]
                              endif
                            endfunction
                            
    1              0.000006 function! s:on_stderr_nvim(_job_id, _data, _event) dict abort
                              " Backward compatibility for nvim < 0.2.0
                              if !has('nvim-0.2.0')
                                let current_buffer = gitgutter#utility#bufnr()
                                call gitgutter#utility#set_buffer(self.buffer)
                                if gitgutter#utility#is_active()
                                  call gitgutter#hunk#reset()
                                endif
                                call gitgutter#utility#set_buffer(current_buffer)
                                return
                              endif
                            
                              call s:buffer_exec(self.buffer, function('gitgutter#hunk#reset'))
                            endfunction
                            
    1              0.000008 function! s:on_exit_nvim(_job_id, _data, _event) dict abort
                              " Backward compatibility for nvim < 0.2.0
                              if !has('nvim-0.2.0')
                                let current_buffer = gitgutter#utility#bufnr()
                                call gitgutter#utility#set_buffer(self.buffer)
                                if gitgutter#utility#is_active()
                                  call gitgutter#handle_diff(gitgutter#utility#stringify(self.stdoutbuffer))
                                endif
                                call gitgutter#utility#set_buffer(current_buffer)
                                return
                              endif
                            
                              call s:buffer_exec(self.buffer, function('gitgutter#handle_diff', [gitgutter#utility#stringify(self.stdoutbuffer)]))
                            endfunction
                            
                            
    1              0.000006 function! s:on_stdout_vim(_channel, data) dict abort
                              call add(self.stdoutbuffer, a:data)
                            endfunction
                            
    1              0.000006 function! s:on_stderr_vim(_channel, _data) dict abort
                              call s:buffer_exec(self.buffer, function('gitgutter#hunk#reset'))
                            endfunction
                            
    1              0.000006 function! s:on_exit_vim(_channel) dict abort
                              call s:buffer_exec(self.buffer, function('gitgutter#handle_diff', [gitgutter#utility#stringify(self.stdoutbuffer)]))
                            endfunction
                            
                            
    1              0.000011 function! s:buffer_exec(buffer, fn)
                              let current_buffer = gitgutter#utility#bufnr()
                              call gitgutter#utility#set_buffer(a:buffer)
                            
                              if gitgutter#utility#is_active()
                                call a:fn()
                              endif
                            
                              call gitgutter#utility#set_buffer(current_buffer)
                            endfunction

SCRIPT  /home/pawelztef/.local/share/nvim/view/~=+Projects=+rails_projects=+grazyna=+spree_simple_blog=+app=+assets=+stylesheets=+spree=+backend=+spree_simple_blog.css.scss=
Sourced 1 time
Total time:   0.037705
 Self time:   0.000638

count  total (s)   self (s)
    1              0.000060 let s:so_save = &so | let s:siso_save = &siso | set so=0 siso=0
    1              0.000005 argglobal
    1              0.000025 setlocal fdm=manual
    1              0.000013 setlocal fde=0
    1              0.000011 setlocal fmr={{{,}}}
    1              0.000011 setlocal fdi=#
    1              0.000013 setlocal fdl=0
    1              0.000012 setlocal fml=1
    1              0.000011 setlocal fdn=20
    1              0.000013 setlocal fen
    1              0.000059 silent! normal! zE
    1              0.000017 let s:l = 103 - ((44 * winheight(0) + 25) / 50)
    1              0.000008 if s:l < 1 | let s:l = 1 | endif
    1              0.000009 exe s:l
    1              0.000024 normal! zt
    1              0.000004 103
    1              0.000021 normal! 0
    1              0.000026 let &so = s:so_save | let &siso = s:siso_save
    1   0.037099   0.000032 doautoall SessionLoadPost
                            " vim: set ft=vim :

SCRIPT  /home/pawelztef/.local/share/nvim/plugged/vim-gitgutter/autoload/gitgutter/debug.vim
Sourced 1 time
Total time:   0.000415
 Self time:   0.000415

count  total (s)   self (s)
    1              0.000025 let s:plugin_dir  = expand('<sfile>:p:h:h:h').'/'
    1              0.000009 let s:log_file    = s:plugin_dir.'gitgutter.log'
    1              0.000008 let s:channel_log = s:plugin_dir.'channel.log'
    1              0.000006 let s:new_log_session = 1
                            
                            
    1              0.000007 function! gitgutter#debug#debug()
                              " Open a scratch buffer
                              vsplit __GitGutter_Debug__
                              normal! ggdG
                              setlocal buftype=nofile
                              setlocal bufhidden=delete
                              setlocal noswapfile
                            
                              call gitgutter#debug#vim_version()
                              call gitgutter#debug#separator()
                            
                              call gitgutter#debug#git_version()
                              call gitgutter#debug#separator()
                            
                              call gitgutter#debug#grep_version()
                              call gitgutter#debug#separator()
                            
                              call gitgutter#debug#option('updatetime')
                              call gitgutter#debug#option('shell')
                              call gitgutter#debug#option('shellcmdflag')
                              call gitgutter#debug#option('shellpipe')
                              call gitgutter#debug#option('shellquote')
                              call gitgutter#debug#option('shellredir')
                              call gitgutter#debug#option('shellslash')
                              call gitgutter#debug#option('shelltemp')
                              call gitgutter#debug#option('shelltype')
                              call gitgutter#debug#option('shellxescape')
                              call gitgutter#debug#option('shellxquote')
                            endfunction
                            
                            
    1              0.000007 function! gitgutter#debug#separator()
                              call gitgutter#debug#output('')
                            endfunction
                            
    1              0.000006 function! gitgutter#debug#vim_version()
                              redir => version_info
                                silent execute 'version'
                              redir END
                              call gitgutter#debug#output(split(version_info, '\n')[0:2])
                            endfunction
                            
    1              0.000006 function! gitgutter#debug#git_version()
                              let v = system(g:gitgutter_git_executable.' --version')
                              call gitgutter#debug#output( substitute(v, '\n$', '', '') )
                            endfunction
                            
    1              0.000005 function! gitgutter#debug#grep_version()
                              let v = system('grep --version')
                              call gitgutter#debug#output( substitute(v, '\n$', '', '') )
                            
                              let v = system('grep --help')
                              call gitgutter#debug#output( substitute(v, '\%x00', '', 'g') )
                            endfunction
                            
    1              0.000006 function! gitgutter#debug#option(name)
                              if exists('+' . a:name)
                                let v = eval('&' . a:name)
                                call gitgutter#debug#output(a:name . '=' . v)
                                " redir => output
                                "   silent execute "verbose set " . a:name . "?"
                                " redir END
                                " call gitgutter#debug#output(a:name . '=' . output)
                              else
                                call gitgutter#debug#output(a:name . ' [n/a]')
                              end
                            endfunction
                            
    1              0.000006 function! gitgutter#debug#output(text)
                              call append(line('$'), a:text)
                            endfunction
                            
                            " assumes optional args are calling function's optional args
    1              0.000005 function! gitgutter#debug#log(message, ...) abort
                              if g:gitgutter_log
                                if s:new_log_session && gitgutter#async#available()
                                  if exists('*ch_logfile')
                                    call ch_logfile(s:channel_log, 'w')
                                  endif
                                endif
                            
                                execute 'redir >> '.s:log_file
                                  if s:new_log_session
                                    let s:start = reltime()
                                    silent echo "\n==== start log session ===="
                                  endif
                            
                                  let elapsed = reltimestr(reltime(s:start)).' '
                                  silent echo ''
                                  " callers excluding this function
                                  silent echo elapsed.expand('<sfile>')[:-22].':'
                                  silent echo elapsed.s:format_for_log(a:message)
                                  if a:0 && !empty(a:1)
                                    for msg in a:000
                                      silent echo elapsed.s:format_for_log(msg)
                                    endfor
                                  endif
                                redir END
                            
                                let s:new_log_session = 0
                              endif
                            endfunction
                            
    1              0.000007 function! s:format_for_log(data) abort
                              if type(a:data) == 1
                                return join(split(a:data,'\n'),"\n")
                              elseif type(a:data) == 3
                                return '['.join(a:data,"\n").']'
                              else
                                return a:data
                              endif
                            endfunction
                            

SCRIPT  /home/pawelztef/.local/share/nvim/plugged/vim-gitgutter/autoload/gitgutter/sign.vim
Sourced 1 time
Total time:   0.000594
 Self time:   0.000594

count  total (s)   self (s)
                            " Vim doesn't namespace sign ids so every plugin shares the same
                            " namespace.  Sign ids are simply integers so to avoid clashes with other
                            " signs we guess at a clear run.
                            "
                            " Note also we currently never reset s:next_sign_id.
    1              0.000009 let s:first_sign_id = 3000
    1              0.000006 let s:next_sign_id  = s:first_sign_id
    1              0.000006 let s:dummy_sign_id = s:first_sign_id - 1
                            " Remove-all-signs optimisation requires Vim 7.3.596+.
    1              0.000011 let s:supports_star = v:version > 703 || (v:version == 703 && has("patch596"))
                            
                            
                            " Removes gitgutter's signs (excluding dummy sign) from the buffer being processed.
    1              0.000007 function! gitgutter#sign#clear_signs() abort
                              let bufnr = gitgutter#utility#bufnr()
                              call gitgutter#sign#find_current_signs()
                            
                              let sign_ids = map(values(gitgutter#utility#getbufvar(bufnr, 'gitgutter_signs')), 'v:val.id')
                              call gitgutter#sign#remove_signs(sign_ids, 1)
                              call gitgutter#utility#setbufvar(bufnr, 'gitgutter_signs', {})
                            endfunction
                            
                            
                            " Updates gitgutter's signs in the buffer being processed.
                            "
                            " modified_lines: list of [<line_number (number)>, <name (string)>]
                            " where name = 'added|removed|modified|modified_removed'
    1              0.000007 function! gitgutter#sign#update_signs(modified_lines) abort
                              call gitgutter#sign#find_current_signs()
                            
                              let new_gitgutter_signs_line_numbers = map(copy(a:modified_lines), 'v:val[0]')
                              let obsolete_signs = gitgutter#sign#obsolete_gitgutter_signs_to_remove(new_gitgutter_signs_line_numbers)
                            
                              let flicker_possible = s:remove_all_old_signs && !empty(a:modified_lines)
                              if flicker_possible
                                call gitgutter#sign#add_dummy_sign()
                              endif
                            
                              call gitgutter#sign#remove_signs(obsolete_signs, s:remove_all_old_signs)
                              call gitgutter#sign#upsert_new_gitgutter_signs(a:modified_lines)
                            
                              if flicker_possible
                                call gitgutter#sign#remove_dummy_sign(0)
                              endif
                            endfunction
                            
                            
    1              0.000006 function! gitgutter#sign#add_dummy_sign() abort
                              let bufnr = gitgutter#utility#bufnr()
                              if !gitgutter#utility#getbufvar(bufnr, 'dummy_sign')
                                execute "sign place" s:dummy_sign_id "line=" . 9999 "name=GitGutterDummy buffer=" . bufnr
                                call gitgutter#utility#setbufvar(bufnr, 'dummy_sign', 1)
                              endif
                            endfunction
                            
    1              0.000007 function! gitgutter#sign#remove_dummy_sign(force) abort
                              let bufnr = gitgutter#utility#bufnr()
                              if gitgutter#utility#getbufvar(bufnr, 'dummy_sign') && (a:force || !g:gitgutter_sign_column_always)
                                execute "sign unplace" s:dummy_sign_id "buffer=" . bufnr
                                call gitgutter#utility#setbufvar(bufnr, 'dummy_sign', 0)
                              endif
                            endfunction
                            
                            
                            "
                            " Internal functions
                            "
                            
                            
    1              0.000006 function! gitgutter#sign#find_current_signs() abort
                              let bufnr = gitgutter#utility#bufnr()
                              let gitgutter_signs = {}  " <line_number (string)>: {'id': <id (number)>, 'name': <name (string)>}
                              let other_signs = []      " [<line_number (number),...]
                              let dummy_sign_placed = 0
                            
                              redir => signs
                                silent execute "sign place buffer=" . bufnr
                              redir END
                            
                              for sign_line in filter(split(signs, '\n')[2:], 'v:val =~# "="')
                                " Typical sign line:  line=88 id=1234 name=GitGutterLineAdded
                                " We assume splitting is faster than a regexp.
                                let components  = split(sign_line)
                                let name        = split(components[2], '=')[1]
                                if name =~# 'GitGutterDummy'
                                  let dummy_sign_placed = 1
                                else
                                  let line_number = str2nr(split(components[0], '=')[1])
                                  if name =~# 'GitGutter'
                                    let id = str2nr(split(components[1], '=')[1])
                                    " Remove orphaned signs (signs placed on lines which have been deleted).
                                    " (When a line is deleted its sign lingers.  Subsequent lines' signs'
                                    " line numbers are decremented appropriately.)
                                    if has_key(gitgutter_signs, line_number)
                                      execute "sign unplace" gitgutter_signs[line_number].id
                                    endif
                                    let gitgutter_signs[line_number] = {'id': id, 'name': name}
                                  else
                                    call add(other_signs, line_number)
                                  endif
                                end
                              endfor
                            
                              call gitgutter#utility#setbufvar(bufnr, 'dummy_sign', dummy_sign_placed)
                              call gitgutter#utility#setbufvar(bufnr, 'gitgutter_signs', gitgutter_signs)
                              call gitgutter#utility#setbufvar(bufnr, 'other_signs', other_signs)
                            endfunction
                            
                            
                            " Returns a list of [<id (number)>, ...]
                            " Sets `s:remove_all_old_signs` as a side-effect.
    1              0.000008 function! gitgutter#sign#obsolete_gitgutter_signs_to_remove(new_gitgutter_signs_line_numbers) abort
                              let bufnr = gitgutter#utility#bufnr()
                              let signs_to_remove = []  " list of [<id (number)>, ...]
                              let remove_all_signs = 1
                              let old_gitgutter_signs = gitgutter#utility#getbufvar(bufnr, 'gitgutter_signs')
                              for line_number in keys(old_gitgutter_signs)
                                if index(a:new_gitgutter_signs_line_numbers, str2nr(line_number)) == -1
                                  call add(signs_to_remove, old_gitgutter_signs[line_number].id)
                                else
                                  let remove_all_signs = 0
                                endif
                              endfor
                              let s:remove_all_old_signs = remove_all_signs
                              return signs_to_remove
                            endfunction
                            
                            
    1              0.000007 function! gitgutter#sign#remove_signs(sign_ids, all_signs) abort
                              let bufnr = gitgutter#utility#bufnr()
                              if a:all_signs && s:supports_star && empty(gitgutter#utility#getbufvar(bufnr, 'other_signs'))
                                let dummy_sign_present = gitgutter#utility#getbufvar(bufnr, 'dummy_sign')
                                execute "sign unplace * buffer=" . bufnr
                                if dummy_sign_present
                                  execute "sign place" s:dummy_sign_id "line=" . 9999 "name=GitGutterDummy buffer=" . bufnr
                                endif
                              else
                                for id in a:sign_ids
                                  execute "sign unplace" id
                                endfor
                              endif
                            endfunction
                            
                            
    1              0.000007 function! gitgutter#sign#upsert_new_gitgutter_signs(modified_lines) abort
                              let bufnr = gitgutter#utility#bufnr()
                              let other_signs         = gitgutter#utility#getbufvar(bufnr, 'other_signs')
                              let old_gitgutter_signs = gitgutter#utility#getbufvar(bufnr, 'gitgutter_signs')
                            
                              for line in a:modified_lines
                                let line_number = line[0]  " <number>
                                if index(other_signs, line_number) == -1  " don't clobber others' signs
                                  let name = gitgutter#utility#highlight_name_for_change(line[1])
                                  if !has_key(old_gitgutter_signs, line_number)  " insert
                                    let id = gitgutter#sign#next_sign_id()
                                    execute "sign place" id "line=" . line_number "name=" . name "buffer=" . bufnr
                                  else  " update if sign has changed
                                    let old_sign = old_gitgutter_signs[line_number]
                                    if old_sign.name !=# name
                                      execute "sign place" old_sign.id "name=" . name "buffer=" . bufnr
                                    end
                                  endif
                                endif
                              endfor
                              " At this point b:gitgutter_gitgutter_signs is out of date.
                            endfunction
                            
                            
    1              0.000010 function! gitgutter#sign#next_sign_id() abort
                              let next_id = s:next_sign_id
                              let s:next_sign_id += 1
                              return next_id
                            endfunction
                            
                            
                            " Only for testing.
    1              0.000005 function! gitgutter#sign#reset()
                              let s:next_sign_id  = s:first_sign_id
                            endfunction

SCRIPT  /home/pawelztef/.local/share/nvim/plugged/ultisnips/autoload/UltiSnips.vim
Sourced 1 time
Total time:   0.248273
 Self time:   0.000649

count  total (s)   self (s)
    1              0.000015 if exists("b:did_autoload_ultisnips") || !exists("g:_uspy")
                                finish
                            endif
    1              0.000007 let b:did_autoload_ultisnips = 1
                            
                            " Also import vim as we expect it to be imported in many places.
    1   0.200448   0.000041 exec g:_uspy "import vim"
    1   0.047270   0.000054 exec g:_uspy "from UltiSnips import UltiSnips_Manager"
                            
    1              0.000018 function! s:compensate_for_pum()
                                """ The CursorMovedI event is not triggered while the popup-menu is visible,
                                """ and it's by this event that UltiSnips updates its vim-state. The fix is
                                """ to explicitly check for the presence of the popup menu, and update
                                """ the vim-state accordingly.
                                if pumvisible()
                                    exec g:_uspy "UltiSnips_Manager._cursor_moved()"
                                endif
                            endfunction
                            
    1              0.000011 function! UltiSnips#Edit(bang, ...)
                                if a:0 == 1 && a:1 != ''
                                    let type = a:1
                                else
                                    let type = ""
                                endif
                                exec g:_uspy "vim.command(\"let file = '%s'\" % UltiSnips_Manager._file_to_edit(vim.eval(\"type\"), vim.eval('a:bang')))"
                            
                                if !len(file)
                                   return
                                endif
                            
                                let mode = 'e'
                                if exists('g:UltiSnipsEditSplit')
                                    if g:UltiSnipsEditSplit == 'vertical'
                                        let mode = 'vs'
                                    elseif g:UltiSnipsEditSplit == 'horizontal'
                                        let mode = 'sp'
                                    elseif g:UltiSnipsEditSplit == 'context'
                                        let mode = 'vs'
                                        if winwidth(0) <= 2 * (&tw ? &tw : 80)
                                            let mode = 'sp'
                                        endif
                                    endif
                                endif
                                exe ':'.mode.' '.escape(file, ' ')
                            endfunction
                            
    1              0.000007 function! UltiSnips#AddFiletypes(filetypes)
                                exec g:_uspy "UltiSnips_Manager.add_buffer_filetypes('" . a:filetypes . "')"
                                return ""
                            endfunction
                            
    1              0.000007 function! UltiSnips#FileTypeComplete(arglead, cmdline, cursorpos)
                                let ret = {}
                                let items = map(
                                \   split(globpath(&runtimepath, 'syntax/*.vim'), '\n'),
                                \   'fnamemodify(v:val, ":t:r")'
                                \ )
                                call insert(items, 'all')
                                for item in items
                                    if !has_key(ret, item) && item =~ '^'.a:arglead
                                        let ret[item] = 1
                                    endif
                                endfor
                            
                                return sort(keys(ret))
                            endfunction
                            
    1              0.000006 function! UltiSnips#ExpandSnippet()
                                exec g:_uspy "UltiSnips_Manager.expand()"
                                return ""
                            endfunction
                            
    1              0.000006 function! UltiSnips#ExpandSnippetOrJump()
                                call s:compensate_for_pum()
                                exec g:_uspy "UltiSnips_Manager.expand_or_jump()"
                                return ""
                            endfunction
                            
    1              0.000006 function! UltiSnips#ListSnippets()
                                exec g:_uspy "UltiSnips_Manager.list_snippets()"
                                return ""
                            endfunction
                            
    1              0.000005 function! UltiSnips#SnippetsInCurrentScope(...)
                                let g:current_ulti_dict = {}
                                let all = get(a:, 1, 0)
                                if all
                                  let g:current_ulti_dict_info = {}
                                endif
                                exec g:_uspy "UltiSnips_Manager.snippets_in_current_scope(" . all . ")"
                                return g:current_ulti_dict
                            endfunction
                            
    1              0.000006 function! UltiSnips#SaveLastVisualSelection() range
                                exec g:_uspy "UltiSnips_Manager._save_last_visual_selection()"
                                return ""
                            endfunction
                            
    1              0.000005 function! UltiSnips#JumpBackwards()
                                call s:compensate_for_pum()
                                exec g:_uspy "UltiSnips_Manager.jump_backwards()"
                                return ""
                            endfunction
                            
    1              0.000006 function! UltiSnips#JumpForwards()
                                call s:compensate_for_pum()
                                exec g:_uspy "UltiSnips_Manager.jump_forwards()"
                                return ""
                            endfunction
                            
    1              0.000007 function! UltiSnips#AddSnippetWithPriority(trigger, value, description, options, filetype, priority)
                                exec g:_uspy "trigger = vim.eval(\"a:trigger\")"
                                exec g:_uspy "value = vim.eval(\"a:value\")"
                                exec g:_uspy "description = vim.eval(\"a:description\")"
                                exec g:_uspy "options = vim.eval(\"a:options\")"
                                exec g:_uspy "filetype = vim.eval(\"a:filetype\")"
                                exec g:_uspy "priority = vim.eval(\"a:priority\")"
                                exec g:_uspy "UltiSnips_Manager.add_snippet(trigger, value, description, options, filetype, priority)"
                                return ""
                            endfunction
                            
    1              0.000006 function! UltiSnips#Anon(value, ...)
                                " Takes the same arguments as SnippetManager.expand_anon:
                                " (value, trigger="", description="", options="")
                                exec g:_uspy "args = vim.eval(\"a:000\")"
                                exec g:_uspy "value = vim.eval(\"a:value\")"
                                exec g:_uspy "UltiSnips_Manager.expand_anon(value, *args)"
                                return ""
                            endfunction
                            
                            
    1              0.000005 function! UltiSnips#CursorMoved()
                                exec g:_uspy "UltiSnips_Manager._cursor_moved()"
                            endf
                            
    1              0.000006 function! UltiSnips#LeavingBuffer()
                                exec g:_uspy "UltiSnips_Manager._leaving_buffer()"
                            endf
                            
    1              0.000006 function! UltiSnips#LeavingInsertMode()
                                exec g:_uspy "UltiSnips_Manager._leaving_insert_mode()"
                            endfunction
                            
    1              0.000006 function! UltiSnips#TrackChange()
                                exec g:_uspy "UltiSnips_Manager._track_change()"
                            endfunction
                            " }}}

SCRIPT  /usr/share/nvim/runtime/autoload/csscomplete.vim
Sourced 1 time
Total time:   0.003850
 Self time:   0.003850

count  total (s)   self (s)
                            " Vim completion script
                            " Language: CSS
                            "           Based on MDN CSS Reference at 2016 Jan <https://developer.mozilla.org/en-US/docs/Web/CSS/Reference>
                            "           plus CSS Speech Module <http://www.w3.org/TR/css3-speech/>
                            " Maintainer: Kao, Wei-Ko(othree) ( othree AT gmail DOT com )
                            " Original Author: Mikolaj Machowski ( mikmach AT wp DOT pl )
                            " Last Change: 2016 Jan 11
                            
    1              0.001426 let s:values = split("all additive-symbols align-content align-items align-self animation animation-delay animation-direction animation-duration animation-fill-mode animation-iteration-count animation-name animation-play-state animation-timing-function backface-visibility background background-attachment background-blend-mode background-clip background-color background-image background-origin background-position background-repeat background-size block-size border border-block-end border-block-end-color border-block-end-style border-block-end-width border-block-start border-block-start-color border-block-start-style border-block-start-width border-bottom border-bottom-color border-bottom-left-radius border-bottom-right-radius border-bottom-style border-bottom-width border-collapse border-color border-image border-image-outset border-image-repeat border-image-slice border-image-source border-image-width border-inline-end border-inline-end-color border-inline-end-style border-inline-end-width border-inline-start                            
                            
    1              0.000012 function! csscomplete#CompleteCSS(findstart, base)
                            
                              if a:findstart
                                " We need whole line to proper checking
                                let line = getline('.')
                                let start = col('.') - 1
                                let compl_begin = col('.') - 2
                                while start >= 0 && line[start - 1] =~ '\%(\k\|-\)'
                                  let start -= 1
                                endwhile
                                let b:after = line[compl_begin :]
                                let b:compl_context = line[0:compl_begin]
                                return start
                              endif
                            
                              " There are few chars important for context:
                              " ^ ; : { } /* */
                              " Where ^ is start of line and /* */ are comment borders
                              " Depending on their relative position to cursor we will know what should
                              " be completed. 
                              " 1. if nearest are ^ or { or ; current word is property
                              " 2. if : it is value (with exception of pseudo things)
                              " 3. if } we are outside of css definitions
                              " 4. for comments ignoring is be the easiest but assume they are the same
                              "    as 1. 
                              " 5. if @ complete at-rule
                              " 6. if ! complete important
                              if exists("b:compl_context")
                                let line = b:compl_context
                                let after = b:after
                                unlet! b:compl_context
                              else
                                let line = a:base
                              endif
                            
                              let res = []
                              let res2 = []
                              let borders = {}
                            
                              " Check last occurrence of sequence
                            
                              let openbrace  = strridx(line, '{')
                              let closebrace = strridx(line, '}')
                              let colon      = strridx(line, ':')
                              let semicolon  = strridx(line, ';')
                              let opencomm   = strridx(line, '/*')
                              let closecomm  = strridx(line, '*/')
                              let style      = strridx(line, 'style\s*=')
                              let atrule     = strridx(line, '@')
                              let exclam     = strridx(line, '!')
                            
                              if openbrace > -1
                                let borders[openbrace] = "openbrace"
                              endif
                              if closebrace > -1
                                let borders[closebrace] = "closebrace"
                              endif
                              if colon > -1
                                let borders[colon] = "colon"
                              endif
                              if semicolon > -1
                                let borders[semicolon] = "semicolon"
                              endif
                              if opencomm > -1
                                let borders[opencomm] = "opencomm"
                              endif
                              if closecomm > -1
                                let borders[closecomm] = "closecomm"
                              endif
                              if style > -1
                                let borders[style] = "style"
                              endif
                              if atrule > -1
                                let borders[atrule] = "atrule"
                              endif
                              if exclam > -1
                                let borders[exclam] = "exclam"
                              endif
                            
                            
                              if len(borders) == 0 || borders[max(keys(borders))] =~ '^\%(openbrace\|semicolon\|opencomm\|closecomm\|style\)$'
                                " Complete properties
                            
                            
                                let entered_property = matchstr(line, '.\{-}\zs[a-zA-Z-]*$')
                            
                                for m in s:values
                                  if m =~? '^'.entered_property
                                    call add(res, m . ':')
                                  elseif m =~? entered_property
                                    call add(res2, m . ':')
                                  endif
                                endfor
                            
                                return res + res2
                            
                              elseif borders[max(keys(borders))] == 'colon'
                                " Get name of property
                                let prop = tolower(matchstr(line, '\zs[a-zA-Z-]*\ze\s*:[^:]\{-}$'))
                            
                                let wide_keywords = ["initial", "inherit", "unset"]
                                let color_values = ["transparent", "rgb(", "rgba(", "hsl(", "hsla(", "#"]
                                let border_style_values = ["none", "hidden", "dotted", "dashed", "solid", "double", "groove", "ridge", "inset", "outset"]
                                let border_width_values = ["thin", "thick", "medium"]
                                let list_style_type_values = ["decimal", "decimal-leading-zero", "arabic-indic", "armenian", "upper-armenian", "lower-armenian", "bengali", "cambodian", "khmer", "cjk-decimal", "devanagari", "georgian", "gujarati", "gurmukhi", "hebrew", "kannada", "lao", "malayalam", "mongolian", "myanmar", "oriya", "persian", "lower-roman", "upper-roman", "tamil", "telugu", "thai", "tibetan", "lower-alpha", "lower-latin", "upper-alpha", "upper-latin", "cjk-earthly-branch", "cjk-heavenly-stem", "lower-greek", "hiragana", "hiragana-iroha", "katakana", "katakana-iroha", "disc", "circle", "square", "disclosure-open", "disclosure-closed"]
                                let timing_functions = ["cubic-bezier(", "steps(", "linear", "ease", "ease-in", "ease-in-out", "ease-out", "step-start", "step-end"]
                            
                                if prop == 'all'
                                  let values = []
                                elseif prop == 'additive-symbols'
                                  let values = []
                                elseif prop == 'align-content'
                                  let values = ["flex-start", "flex-end", "center", "space-between", "space-around", "stretch"]
                                elseif prop == 'align-items'
                                  let values = ["flex-start", "flex-end", "center", "baseline", "stretch"]
                                elseif prop == 'align-self'
                                  let values = ["auto", "flex-start", "flex-end", "center", "baseline", "stretch"]
                                elseif prop == 'animation'
                                  let values = timing_functions + ["normal", "reverse", "alternate", "alternate-reverse"] + ["none", "forwards", "backwards", "both"] + ["running", "paused"]
                                elseif prop == 'animation-delay'
                                  let values = []
                                elseif prop == 'animation-direction'
                                  let values = ["normal", "reverse", "alternate", "alternate-reverse"]
                                elseif prop == 'animation-duration'
                                  let values = []
                                elseif prop == 'animation-fill-mode'
                                  let values = ["none", "forwards", "backwards", "both"]
                                elseif prop == 'animation-iteration-count'
                                  let values = []
                                elseif prop == 'animation-name'
                                  let values = []
                                elseif prop == 'animation-play-state'
                                  let values = ["running", "paused"]
                                elseif prop == 'animation-timing-function'
                                  let values = timing_functions
                                elseif prop == 'background-attachment'
                                  let values = ["scroll", "fixed"]
                                elseif prop == 'background-color'
                                  let values = color_values
                                elseif prop == 'background-image'
                                  let values = ["url(", "none"]
                                elseif prop == 'background-position'
                                  let vals = matchstr(line, '.*:\s*\zs.*')
                                  if vals =~ '^\%([a-zA-Z]\+\)\?$'
                                    let values = ["top", "center", "bottom"]
                                  elseif vals =~ '^[a-zA-Z]\+\s\+\%([a-zA-Z]\+\)\?$'
                                    let values = ["left", "center", "right"]
                                  else
                                    return []
                                  endif
                                elseif prop == 'background-repeat'
                                  let values = ["repeat", "repeat-x", "repeat-y", "no-repeat"]
                                elseif prop == 'background-size'
                                  let values = ["auto", "contain", "cover"]
                                elseif prop == 'background'
                                  let values = ["scroll", "fixed"] + color_values + ["url(", "none"] + ["top", "center", "bottom", "left", "right"] + ["repeat", "repeat-x", "repeat-y", "no-repeat"] + ["auto", "contain", "cover"]
                                elseif prop =~ 'border\%(-top\|-right\|-bottom\|-left\|-block-start\|-block-end\)\?$'
                                  let vals = matchstr(line, '.*:\s*\zs.*')
                                  if vals =~ '^\%([a-zA-Z0-9.]\+\)\?$'
                                    let values = border_width_values
                                  elseif vals =~ '^[a-zA-Z0-9.]\+\s\+\%([a-zA-Z]\+\)\?$'
                                    let values = border_style_values
                                  elseif vals =~ '^[a-zA-Z0-9.]\+\s\+[a-zA-Z]\+\s\+\%([a-zA-Z(]\+\)\?$'
                                    let values = color_values
                                  else
                                    return []
                                  endif
                                elseif prop =~ 'border-\%(top\|right\|bottom\|left\|block-start\|block-end\)-color'
                                  let values = color_values
                                elseif prop =~ 'border-\%(top\|right\|bottom\|left\|block-start\|block-end\)-style'
                                  let values = border_style_values
                                elseif prop =~ 'border-\%(top\|right\|bottom\|left\|block-start\|block-end\)-width'
                                  let values = border_width_values
                                elseif prop == 'border-color'
                                  let values = color_values
                                elseif prop == 'border-style'
                                  let values = border_style_values
                                elseif prop == 'border-width'
                                  let values = border_width_values
                                elseif prop == 'bottom'
                                  let values = ["auto"]
                                elseif prop == 'box-decoration-break'
                                  let values = ["slice", "clone"]
                                elseif prop == 'box-shadow'
                                  let values = ["inset"]
                                elseif prop == 'box-sizing'
                                  let values = ["border-box", "content-box"]
                                elseif prop =~ 'break-\%(before\|after\)'
                                  let values = ["auto", "always", "avoid", "left", "right", "page", "column", "region", "recto", "verso", "avoid-page", "avoid-column", "avoid-region"]
                                elseif prop == 'break-inside'
                                  let values = ["auto", "avoid", "avoid-page", "avoid-column", "avoid-region"]
                                elseif prop == 'caption-side'
                                  let values = ["top", "bottom"]
                                elseif prop == 'clear'
                                  let values = ["none", "left", "right", "both"]
                                elseif prop == 'clip'
                                  let values = ["auto", "rect("]
                                elseif prop == 'clip-path'
                                  let values = ["fill-box", "stroke-box", "view-box", "none"]
                                elseif prop == 'color'
                                  let values = color_values
                                elseif prop == 'columns'
                                  let values = []
                                elseif prop == 'column-count'
                                  let values = ['auto']
                                elseif prop == 'column-fill'
                                  let values = ['auto', 'balance']
                                elseif prop == 'column-rule-color'
                                  let values = color_values
                                elseif prop == 'column-rule-style'
                                  let values = border_style_values
                                elseif prop == 'column-rule-width'
                                  let values = border_width_values
                                elseif prop == 'column-rule'
                                  let vals = matchstr(line, '.*:\s*\zs.*')
                                  if vals =~ '^\%([a-zA-Z0-9.]\+\)\?$'
                                    let values = border_width_values
                                  elseif vals =~ '^[a-zA-Z0-9.]\+\s\+\%([a-zA-Z]\+\)\?$'
                                    let values = border_style_values
                                  elseif vals =~ '^[a-zA-Z0-9.]\+\s\+[a-zA-Z]\+\s\+\%([a-zA-Z(]\+\)\?$'
                                    let values = color_values
                                  else
                                    return []
                                  endif
                                elseif prop == 'column-span'
                                  let values = ["none", "all"]
                                elseif prop == 'column-width'
                                  let values = ["auto"]
                                elseif prop == 'content'
                                  let values = ["normal", "attr(", "open-quote", "close-quote", "no-open-quote", "no-close-quote"]
                                elseif prop =~ 'counter-\%(increment\|reset\)$'
                                  let values = ["none"]
                                elseif prop =~ 'cue\%(-after\|-before\)\=$'
                                  let values = ["url("]
                                elseif prop == 'cursor'
                                  let values = ["url(", "auto", "crosshair", "default", "pointer", "move", "e-resize", "ne-resize", "nw-resize", "n-resize", "se-resize", "sw-resize", "s-resize", "w-resize", "text", "wait", "help", "progress"]
                                elseif prop == 'direction'
                                  let values = ["ltr", "rtl"]
                                elseif prop == 'display'
                                  let values = ["inline", "block", "list-item", "inline-list-item", "run-in", "inline-block", "table", "inline-table", "table-row-group", "table-header-group", "table-footer-group", "table-row", "table-column-group", "table-column", "table-cell", "table-caption", "none", "flex", "inline-flex", "grid", "inline-grid", "ruby", "ruby-base", "ruby-text", "ruby-base-container", "ruby-text-container", "contents"]
                                elseif prop == 'elevation'
                                  let values = ["below", "level", "above", "higher", "lower"]
                                elseif prop == 'empty-cells'
                                  let values = ["show", "hide"]
                                elseif prop == 'fallback'
                                  let values = list_style_type_values
                                elseif prop == 'filter'
                                  let values = ["blur(", "brightness(", "contrast(", "drop-shadow(", "grayscale(", "hue-rotate(", "invert(", "opacity(", "sepia(", "saturate("]
                                elseif prop == 'flex-basis'
                                  let values = ["auto", "content"]
                                elseif prop == 'flex-flow'
                                  let values = ["row", "row-reverse", "column", "column-reverse", "nowrap", "wrap", "wrap-reverse"]
                                elseif prop == 'flex-grow'
                                  let values = []
                                elseif prop == 'flex-shrink'
                                  let values = []
                                elseif prop == 'flex-wrap'
                                  let values = ["nowrap", "wrap", "wrap-reverse"]
                                elseif prop == 'flex'
                                  let values = ["nowrap", "wrap", "wrap-reverse"] + ["row", "row-reverse", "column", "column-reverse", "nowrap", "wrap", "wrap-reverse"] + ["auto", "content"]
                                elseif prop == 'float'
                                  let values = ["left", "right", "none"]
                                elseif prop == 'font-family'
                                  let values = ["sans-serif", "serif", "monospace", "cursive", "fantasy"]
                                elseif prop == 'font-feature-settings'
                                  let values = ["normal", '"aalt"', '"abvf"', '"abvm"', '"abvs"', '"afrc"', '"akhn"', '"blwf"', '"blwm"', '"blws"', '"calt"', '"case"', '"ccmp"', '"cfar"', '"cjct"', '"clig"', '"cpct"', '"cpsp"', '"cswh"', '"curs"', '"cv', '"c2pc"', '"c2sc"', '"dist"', '"dlig"', '"dnom"', '"dtls"', '"expt"', '"falt"', '"fin2"', '"fin3"', '"fina"', '"flac"', '"frac"', '"fwid"', '"half"', '"haln"', '"halt"', '"hist"', '"hkna"', '"hlig"', '"hngl"', '"hojo"', '"hwid"', '"init"', '"isol"', '"ital"', '"jalt"', '"jp78"', '"jp83"', '"jp90"', '"jp04"', '"kern"', '"lfbd"', '"liga"', '"ljmo"', '"lnum"', '"locl"', '"ltra"', '"ltrm"', '"mark"', '"med2"', '"medi"', '"mgrk"', '"mkmk"', '"mset"', '"nalt"', '"nlck"', '"nukt"', '"numr"', '"onum"', '"opbd"', '"ordn"', '"ornm"', '"palt"', '"pcap"', '"pkna"', '"pnum"', '"pref"', '"pres"', '"pstf"', '"psts"', '"pwid"', '"qwid"', '"rand"', '"rclt"', '"rkrf"', '"rlig"', '"rphf"', '"rtbd"', '"rtla"', '"rtlm"', '"ruby"', '"salt"', '"sinf"', '"size"', '"smcp"', '"smpl"', '"ss01"', '"ss02"', '"ss03"                                elseif prop == 'font-kerning'
                                  let values = ["auto", "normal", "none"]
                                elseif prop == 'font-language-override'
                                  let values = ["normal"]
                                elseif prop == 'font-size'
                                  let values = ["xx-small", "x-small", "small", "medium", "large", "x-large", "xx-large", "larger", "smaller"]
                                elseif prop == 'font-size-adjust'
                                  let values = []
                                elseif prop == 'font-stretch'
                                  let values = ["normal", "ultra-condensed", "extra-condensed", "condensed", "semi-condensed", "semi-expanded", "expanded", "extra-expanded", "ultra-expanded"]
                                elseif prop == 'font-style'
                                  let values = ["normal", "italic", "oblique"]
                                elseif prop == 'font-synthesis'
                                  let values = ["none", "weight", "style"]
                                elseif prop == 'font-variant-alternates'
                                  let values = ["normal", "historical-forms", "stylistic(", "styleset(", "character-variant(", "swash(", "ornaments(", "annotation("]
                                elseif prop == 'font-variant-caps'
                                  let values = ["normal", "small-caps", "all-small-caps", "petite-caps", "all-petite-caps", "unicase", "titling-caps"]
                                elseif prop == 'font-variant-asian'
                                  let values = ["normal", "ruby", "jis78", "jis83", "jis90", "jis04", "simplified", "traditional"]
                                elseif prop == 'font-variant-ligatures'
                                  let values = ["normal", "none", "common-ligatures", "no-common-ligatures", "discretionary-ligatures", "no-discretionary-ligatures", "historical-ligatures", "no-historical-ligatures", "contextual", "no-contextual"]
                                elseif prop == 'font-variant-numeric'
                                  let values = ["normal", "ordinal", "slashed-zero", "lining-nums", "oldstyle-nums", "proportional-nums", "tabular-nums", "diagonal-fractions", "stacked-fractions"]
                                elseif prop == 'font-variant-position'
                                  let values = ["normal", "sub", "super"]
                                elseif prop == 'font-variant'
                                  let values = ["normal", "historical-forms", "stylistic(", "styleset(", "character-variant(", "swash(", "ornaments(", "annotation("] + ["small-caps", "all-small-caps", "petite-caps", "all-petite-caps", "unicase", "titling-caps"] + ["ruby", "jis78", "jis83", "jis90", "jis04", "simplified", "traditional"] + ["none", "common-ligatures", "no-common-ligatures", "discretionary-ligatures", "no-discretionary-ligatures", "historical-ligatures", "no-historical-ligatures", "contextual", "no-contextual"] + ["ordinal", "slashed-zero", "lining-nums", "oldstyle-nums", "proportional-nums", "tabular-nums", "diagonal-fractions", "stacked-fractions"] + ["sub", "super"]
                                elseif prop == 'font-weight'
                                  let values = ["normal", "bold", "bolder", "lighter", "100", "200", "300", "400", "500", "600", "700", "800", "900"]
                                elseif prop == 'font'
                                  let values = ["normal", "italic", "oblique", "small-caps", "bold", "bolder", "lighter", "100", "200", "300", "400", "500", "600", "700", "800", "900", "xx-small", "x-small", "small", "medium", "large", "x-large", "xx-large", "larger", "smaller", "sans-serif", "serif", "monospace", "cursive", "fantasy", "caption", "icon", "menu", "message-box", "small-caption", "status-bar"]
                                elseif prop =~ '^\%(height\|width\)$'
                                  let values = ["auto", "border-box", "content-box", "max-content", "min-content", "available", "fit-content"]
                                elseif prop =~ '^\%(left\|rigth\)$'
                                  let values = ["auto"]
                                elseif prop == 'image-rendering'
                                  let values = ["auto", "crisp-edges", "pixelated"]
                                elseif prop == 'image-orientation'
                                  let values = ["from-image", "flip"]
                                elseif prop == 'ime-mode'
                                  let values = ["auto", "normal", "active", "inactive", "disabled"]
                                elseif prop == 'inline-size'
                                  let values = ["auto", "border-box", "content-box", "max-content", "min-content", "available", "fit-content"]
                                elseif prop == 'isolation'
                                  let values = ["auto", "isolate"]
                                elseif prop == 'justify-content'
                                  let values = ["flex-start", "flex-end", "center", "space-between", "space-around"]
                                elseif prop == 'letter-spacing'
                                  let values = ["normal"]
                                elseif prop == 'line-break'
                                  let values = ["auto", "loose", "normal", "strict"]
                                elseif prop == 'line-height'
                                  let values = ["normal"]
                                elseif prop == 'list-style-image'
                                  let values = ["url(", "none"]
                                elseif prop == 'list-style-position'
                                  let values = ["inside", "outside"]
                                elseif prop == 'list-style-type'
                                  let values = list_style_type_values
                                elseif prop == 'list-style'
                                  let values = list_style_type_values + ["inside", "outside"] + ["url(", "none"]
                                elseif prop == 'margin'
                                  let values = ["auto"]
                                elseif prop =~ 'margin-\%(right\|left\|top\|bottom\|block-start\|block-end\|inline-start\|inline-end\)$'
                                  let values = ["auto"]
                                elseif prop == 'marks'
                                  let values = ["crop", "cross", "none"]
                                elseif prop == 'mask'
                                  let values = ["url("]
                                elseif prop == 'mask-type'
                                  let values = ["luminance", "alpha"]
                                elseif prop == '\%(max\|min\)-\%(block\|inline\)-size'
                                  let values = ["auto", "border-box", "content-box", "max-content", "min-content", "available", "fit-content"]
                                elseif prop == '\%(max\|min\)-\%(height\|width\)'
                                  let values = ["auto", "border-box", "content-box", "max-content", "min-content", "available", "fit-content"]
                                elseif prop == '\%(max\|min\)-zoom'
                                  let values = ["auto"]
                                elseif prop == 'mix-blend-mode'
                                  let values = ["normal", "multiply", "screen", "overlay", "darken", "lighten", "color-dodge", "color-burn", "hard-light", "soft-light", "difference", "exclusion", "hue", "saturation", "color", "luminosity"]
                                elseif prop == 'opacity'
                                  let values = []
                                elseif prop == 'orientation'
                                  let values = ["auto", "portrait", "landscape"]
                                elseif prop == 'orphans'
                                  let values = []
                                elseif prop == 'outline-offset'
                                  let values = []
                                elseif prop == 'outline-color'
                                  let values = color_values
                                elseif prop == 'outline-style'
                                  let values = ["none", "hidden", "dotted", "dashed", "solid", "double", "groove", "ridge", "inset", "outset"]
                                elseif prop == 'outline-width'
                                  let values = ["thin", "thick", "medium"]
                                elseif prop == 'outline'
                                  let vals = matchstr(line, '.*:\s*\zs.*')
                                  if vals =~ '^\%([a-zA-Z0-9,()#]\+\)\?$'
                                    let values = color_values
                                  elseif vals =~ '^[a-zA-Z0-9,()#]\+\s\+\%([a-zA-Z]\+\)\?$'
                                    let values = ["none", "hidden", "dotted", "dashed", "solid", "double", "groove", "ridge", "inset", "outset"]
                                  elseif vals =~ '^[a-zA-Z0-9,()#]\+\s\+[a-zA-Z]\+\s\+\%([a-zA-Z(]\+\)\?$'
                                    let values = ["thin", "thick", "medium"]
                                  else
                                    return []
                                  endif
                                elseif prop == 'overflow-wrap'
                                  let values = ["normal", "break-word"]
                                elseif prop =~ 'overflow\%(-x\|-y\)\='
                                  let values = ["visible", "hidden", "scroll", "auto"]
                                elseif prop == 'pad'
                                  let values = []
                                elseif prop == 'padding'
                                  let values = []
                                elseif prop =~ 'padding-\%(top\|right\|bottom\|left\|inline-start\|inline-end\|block-start\|block-end\)$'
                                  let values = []
                                elseif prop =~ 'page-break-\%(after\|before\)$'
                                  let values = ["auto", "always", "avoid", "left", "right", "recto", "verso"]
                                elseif prop == 'page-break-inside'
                                  let values = ["auto", "avoid"]
                                elseif prop =~ 'pause\%(-after\|-before\)\=$'
                                  let values = ["none", "x-weak", "weak", "medium", "strong", "x-strong"]
                                elseif prop == 'perspective'
                                  let values = ["none"]
                                elseif prop == 'perspective-origin'
                                  let values = ["top", "bottom", "left", "center", " right"]
                                elseif prop == 'pointer-events'
                                  let values = ["auto", "none", "visiblePainted", "visibleFill", "visibleStroke", "visible", "painted", "fill", "stroke", "all"]
                                elseif prop == 'position'
                                  let values = ["static", "relative", "absolute", "fixed", "sticky"]
                                elseif prop == 'prefix'
                                  let values = []
                                elseif prop == 'quotes'
                                  let values = ["none"]
                                elseif prop == 'range'
                                  let values = ["auto", "infinite"]
                                elseif prop == 'resize'
                                  let values = ["none", "both", "horizontal", "vertical"]
                                elseif prop =~ 'rest\%(-after\|-before\)\=$'
                                  let values = ["none", "x-weak", "weak", "medium", "strong", "x-strong"]
                                elseif prop == 'ruby-align'
                                  let values = ["start", "center", "space-between", "space-around"]
                                elseif prop == 'ruby-merge'
                                  let values = ["separate", "collapse", "auto"]
                                elseif prop == 'ruby-position'
                                  let values = ["over", "under", "inter-character"]
                                elseif prop == 'scroll-behavior'
                                  let values = ["auto", "smooth"]
                                elseif prop == 'scroll-snap-coordinate'
                                  let values = ["none"]
                                elseif prop == 'scroll-snap-destination'
                                  return []
                                elseif prop == 'scroll-snap-points-\%(x\|y\)$'
                                  let values = ["none", "repeat("]
                                elseif prop == 'scroll-snap-type\%(-x\|-y\)\=$'
                                  let values = ["none", "mandatory", "proximity"]
                                elseif prop == 'shape-image-threshold'
                                  let values = []
                                elseif prop == 'shape-margin'
                                  let values = []
                                elseif prop == 'shape-outside'
                                  let values = ["margin-box", "border-box", "padding-box", "content-box", 'inset(', 'circle(', 'ellipse(', 'polygon(', 'url(']
                                elseif prop == 'speak'
                                  let values = ["auto", "none", "normal"]
                                elseif prop == 'speak-as'
                                  let values = ["auto", "normal", "spell-out", "digits"]
                                elseif prop == 'src'
                                  let values = ["url("]
                                elseif prop == 'suffix'
                                  let values = []
                                elseif prop == 'symbols'
                                  let values = []
                                elseif prop == 'system'
                                  let vals = matchstr(line, '.*:\s*\zs.*')
                                  if vals =~ '^extends'
                                    let values = list_style_type_values
                                  else
                                    let values = ["cyclic", "numeric", "alphabetic", "symbolic", "additive", "fixed", "extends"]
                                  endif
                                elseif prop == 'table-layout'
                                  let values = ["auto", "fixed"]
                                elseif prop == 'tab-size'
                                  let values = []
                                elseif prop == 'text-align'
                                  let values = ["start", "end", "left", "right", "center", "justify", "match-parent"]
                                elseif prop == 'text-align-last'
                                  let values = ["auto", "start", "end", "left", "right", "center", "justify"]
                                elseif prop == 'text-combine-upright'
                                  let values = ["none", "all", "digits"]
                                elseif prop == 'text-decoration-line'
                                  let values = ["none", "underline", "overline", "line-through", "blink"]
                                elseif prop == 'text-decoration-color'
                                  let values = color_values
                                elseif prop == 'text-decoration-style'
                                  let values = ["solid", "double", "dotted", "dashed", "wavy"]
                                elseif prop == 'text-decoration'
                                  let values = ["none", "underline", "overline", "line-through", "blink"] + ["solid", "double", "dotted", "dashed", "wavy"] + color_values
                                elseif prop == 'text-emphasis-color'
                                  let values = color_values
                                elseif prop == 'text-emphasis-position'
                                  let values = ["over", "under", "left", "right"]
                                elseif prop == 'text-emphasis-style'
                                  let values = ["none", "filled", "open", "dot", "circle", "double-circle", "triangle", "sesame"]
                                elseif prop == 'text-emphasis'
                                  let values = color_values + ["over", "under", "left", "right"] + ["none", "filled", "open", "dot", "circle", "double-circle", "triangle", "sesame"]
                                elseif prop == 'text-indent'
                                  let values = ["hanging", "each-line"]
                                elseif prop == 'text-orientation'
                                  let values = ["mixed", "upright", "sideways", "sideways-right", "use-glyph-orientation"]
                                elseif prop == 'text-overflow'
                                  let values = ["clip", "ellipsis"]
                                elseif prop == 'text-rendering'
                                  let values = ["auto", "optimizeSpeed", "optimizeLegibility", "geometricPrecision"]
                                elseif prop == 'text-shadow'
                                  let values = color_values
                                elseif prop == 'text-transform'
                                  let values = ["capitalize", "uppercase", "lowercase", "full-width", "none"]
                                elseif prop == 'text-underline-position'
                                  let values = ["auto", "under", "left", "right"]
                                elseif prop == 'touch-action'
                                  let values = ["auto", "none", "pan-x", "pan-y", "manipulation", "pan-left", "pan-right", "pan-top", "pan-down"]
                                elseif prop == 'transform'
                                  let values = ["matrix(", "translate(", "translateX(", "translateY(", "scale(", "scaleX(", "scaleY(", "rotate(", "skew(", "skewX(", "skewY(", "matrix3d(", "translate3d(", "translateZ(", "scale3d(", "scaleZ(", "rotate3d(", "rotateX(", "rotateY(", "rotateZ(", "perspective("]
                                elseif prop == 'transform-box'
                                  let values = ["border-box", "fill-box", "view-box"]
                                elseif prop == 'transform-origin'
                                  let values = ["left", "center", "right", "top", "bottom"]
                                elseif prop == 'transform-style'
                                  let values = ["flat", "preserve-3d"]
                                elseif prop == 'top'
                                  let values = ["auto"]
                                elseif prop == 'transition-property'
                                  let values = ["all", "none"] + s:values
                                elseif prop == 'transition-duration'
                                  let values = []
                                elseif prop == 'transition-delay'
                                  let values = []
                                elseif prop == 'transition-timing-function'
                                  let values = timing_functions
                                elseif prop == 'transition'
                                  let values = ["all", "none"] + s:values + timing_functions
                                elseif prop == 'unicode-bidi'
                                  let values = ["normal", "embed", "isolate", "bidi-override", "isolate-override", "plaintext"]
                                elseif prop == 'unicode-range'
                                  let values = ["U+"]
                                elseif prop == 'user-zoom'
                                  let values = ["zoom", "fixed"]
                                elseif prop == 'vertical-align'
                                  let values = ["baseline", "sub", "super", "top", "text-top", "middle", "bottom", "text-bottom"]
                                elseif prop == 'visibility'
                                  let values = ["visible", "hidden", "collapse"]
                                elseif prop == 'voice-volume'
                                  let values = ["silent", "x-soft", "soft", "medium", "loud", "x-loud"]
                                elseif prop == 'voice-balance'
                                  let values = ["left", "center", "right", "leftwards", "rightwards"]
                                elseif prop == 'voice-family'
                                  let values = []
                                elseif prop == 'voice-rate'
                                  let values = ["normal", "x-slow", "slow", "medium", "fast", "x-fast"]
                                elseif prop == 'voice-pitch'
                                  let values = ["absolute", "x-low", "low", "medium", "high", "x-high"]
                                elseif prop == 'voice-range'
                                  let values = ["absolute", "x-low", "low", "medium", "high", "x-high"]
                                elseif prop == 'voice-stress'
                                  let values = ["normal", "strong", "moderate", "none", "reduced "]
                                elseif prop == 'voice-duration'
                                  let values = ["auto"]
                                elseif prop == 'white-space'
                                  let values = ["normal", "pre", "nowrap", "pre-wrap", "pre-line"]
                                elseif prop == 'widows'
                                  let values = []
                                elseif prop == 'will-change'
                                  let values = ["auto", "scroll-position", "contents"] + s:values
                                elseif prop == 'word-break'
                                  let values = ["normal", "break-all", "keep-all"]
                                elseif prop == 'word-spacing'
                                  let values = ["normal"]
                                elseif prop == 'word-wrap'
                                  let values = ["normal", "break-word"]
                                elseif prop == 'writing-mode'
                                  let values = ["horizontal-tb", "vertical-rl", "vertical-lr", "sideways-rl", "sideways-lr"]
                                elseif prop == 'z-index'
                                  let values = ["auto"]
                                elseif prop == 'zoom'
                                  let values = ["auto"]
                                else
                                  " If no property match it is possible we are outside of {} and
                                  " trying to complete pseudo-(class|element)
                                  let element = tolower(matchstr(line, '\zs[a-zA-Z1-6]*\ze:[^:[:space:]]\{-}$'))
                                  if stridx('a,abbr,address,area,article,aside,audio,b,base,bdi,bdo,bgsound,blockquote,body,br,button,canvas,caption,center,cite,code,col,colgroup,command,content,data,datalist,dd,del,details,dfn,dialog,div,dl,dt,element,em,embed,fieldset,figcaption,figure,font,footer,form,frame,frameset,head,header,hgroup,hr,html,i,iframe,image,img,input,ins,isindex,kbd,keygen,label,legend,li,link,main,map,mark,menu,menuitem,meta,meter,nav,nobr,noframes,noscript,object,ol,optgroup,option,output,p,param,picture,pre,progress,q,rp,rt,rtc,ruby,s,samp,script,section,select,shadow,small,source,span,strong,style,sub,summary,sup,table,tbody,td,template,textarea,tfoot,th,thead,time,title,tr,track,u,ul,var,video,wbr', ','.element.',') > -1
                                    let values = ["active", "any", "checked", "default", "dir(", "disabled", "empty", "enabled", "first", "first-child", "first-of-type", "fullscreen", "focus", "hover", "indeterminate", "in-range", "invalid", "lang(", "last-child", "last-of-type", "left", "link", "not(", "nth-child(", "nth-last-child(", "nth-last-of-type(", "nth-of-type(", "only-child", "only-of-type", "optional", "out-of-range", "read-only", "read-write", "required", "right", "root", "scope", "target", "valid", "visited", "first-line", "first-letter", "before", "after", "selection", "backdrop"]
                                  else
                                    return []
                                  endif
                                endif
                            
                                let values = wide_keywords + values
                                " Complete values
                                let entered_value = matchstr(line, '.\{-}\zs[a-zA-Z0-9#,.(_-]*$')
                            
                                for m in values
                                  if m =~? '^'.entered_value
                                    call add(res, m)
                                  elseif m =~? entered_value
                                    call add(res2, m)
                                  endif
                                endfor
                            
                                return res + res2
                            
                              elseif borders[max(keys(borders))] == 'closebrace'
                            
                                return []
                            
                              elseif borders[max(keys(borders))] == 'exclam'
                            
                                " Complete values
                                let entered_imp = matchstr(line, '.\{-}!\s*\zs[a-zA-Z ]*$')
                            
                                let values = ["important"]
                            
                                for m in values
                                  if m =~? '^'.entered_imp
                                    call add(res, m)
                                  endif
                                endfor
                            
                                return res
                            
                              elseif borders[max(keys(borders))] == 'atrule'
                            
                                let afterat = matchstr(line, '.*@\zs.*')
                            
                                if afterat =~ '\s'
                            
                                  let atrulename = matchstr(line, '.*@\zs[a-zA-Z-]\+\ze')
                            
                                  if atrulename == 'media'
                                    let entered_atruleafter = matchstr(line, '.*@media\s\+\zs.*$')
                            
                                    if entered_atruleafter =~ "([^)]*$"
                                      let entered_atruleafter = matchstr(entered_atruleafter, '(\s*\zs[^)]*$')
                                      let values = ["max-width", "min-width", "width", "max-height", "min-height", "height", "max-aspect-ration", "min-aspect-ration", "aspect-ratio", "orientation", "max-resolution", "min-resolution", "resolution", "scan", "grid", "update-frequency", "overflow-block", "overflow-inline", "max-color", "min-color", "color", "max-color-index", "min-color-index", "color-index", "monochrome", "inverted-colors", "pointer", "hover", "any-pointer", "any-hover", "light-level", "scripting"]
                                    else
                                      let values = ["screen", "print", "speech", "all", "not", "and", "("]
                                    endif
                            
                                  elseif atrulename == 'supports'
                                    let entered_atruleafter = matchstr(line, '.*@supports\s\+\zs.*$')
                            
                                    if entered_atruleafter =~ "([^)]*$"
                                      let entered_atruleafter = matchstr(entered_atruleafter, '(\s*\zs.*$')
                                      let values = s:values
                                    else
                                      let values = ["("]
                                    endif
                            
                                  elseif atrulename == 'charset'
                                    let entered_atruleafter = matchstr(line, '.*@charset\s\+\zs.*$')
                                    let values = [
                                      \ '"UTF-8";', '"ANSI_X3.4-1968";', '"ISO_8859-1:1987";', '"ISO_8859-2:1987";', '"ISO_8859-3:1988";', '"ISO_8859-4:1988";', '"ISO_8859-5:1988";', 
                                      \ '"ISO_8859-6:1987";', '"ISO_8859-7:1987";', '"ISO_8859-8:1988";', '"ISO_8859-9:1989";', '"ISO-8859-10";', '"ISO_6937-2-add";', '"JIS_X0201";', 
                                      \ '"JIS_Encoding";', '"Shift_JIS";', '"Extended_UNIX_Code_Packed_Format_for_Japanese";', '"Extended_UNIX_Code_Fixed_Width_for_Japanese";',
                                      \ '"BS_4730";', '"SEN_850200_C";', '"IT";', '"ES";', '"DIN_66003";', '"NS_4551-1";', '"NF_Z_62-010";', '"ISO-10646-UTF-1";', '"ISO_646.basic:1983";',
                                      \ '"INVARIANT";', '"ISO_646.irv:1983";', '"NATS-SEFI";', '"NATS-SEFI-ADD";', '"NATS-DANO";', '"NATS-DANO-ADD";', '"SEN_850200_B";', '"KS_C_5601-1987";',
                                      \ '"ISO-2022-KR";', '"EUC-KR";', '"ISO-2022-JP";', '"ISO-2022-JP-2";', '"JIS_C6220-1969-jp";', '"JIS_C6220-1969-ro";', '"PT";', '"greek7-old";', 
                                      \ '"latin-greek";', '"NF_Z_62-010_(1973)";', '"Latin-greek-1";', '"ISO_5427";', '"JIS_C6226-1978";', '"BS_viewdata";', '"INIS";', '"INIS-8";', 
                                      \ '"INIS-cyrillic";', '"ISO_5427:1981";', '"ISO_5428:1980";', '"GB_1988-80";', '"GB_2312-80";', '"NS_4551-2";', '"videotex-suppl";', '"PT2";', 
                                      \ '"ES2";', '"MSZ_7795.3";', '"JIS_C6226-1983";', '"greek7";', '"ASMO_449";', '"iso-ir-90";', '"JIS_C6229-1984-a";', '"JIS_C6229-1984-b";', 
                                      \ '"JIS_C6229-1984-b-add";', '"JIS_C6229-1984-hand";', '"JIS_C6229-1984-hand-add";', '"JIS_C6229-1984-kana";', '"ISO_2033-1983";', 
                                      \ '"ANSI_X3.110-1983";', '"T.61-7bit";', '"T.61-8bit";', '"ECMA-cyrillic";', '"CSA_Z243.4-1985-1";', '"CSA_Z243.4-1985-2";', '"CSA_Z243.4-1985-gr";', 
                                      \ '"ISO_8859-6-E";', '"ISO_8859-6-I";', '"T.101-G2";', '"ISO_8859-8-E";', '"ISO_8859-8-I";', '"CSN_369103";', '"JUS_I.B1.002";', '"IEC_P27-1";', 
                                      \ '"JUS_I.B1.003-serb";', '"JUS_I.B1.003-mac";', '"greek-ccitt";', '"NC_NC00-10:81";', '"ISO_6937-2-25";', '"GOST_19768-74";', '"ISO_8859-supp";', 
                                      \ '"ISO_10367-box";', '"latin-lap";', '"JIS_X0212-1990";', '"DS_2089";', '"us-dk";', '"dk-us";', '"KSC5636";', '"UNICODE-1-1-UTF-7";', '"ISO-2022-CN";', 
                                      \ '"ISO-2022-CN-EXT";', '"ISO-8859-13";', '"ISO-8859-14";', '"ISO-8859-15";', '"ISO-8859-16";', '"GBK";', '"GB18030";', '"OSD_EBCDIC_DF04_15";', 
                                      \ '"OSD_EBCDIC_DF03_IRV";', '"OSD_EBCDIC_DF04_1";', '"ISO-11548-1";', '"KZ-1048";', '"ISO-10646-UCS-2";', '"ISO-10646-UCS-4";', '"ISO-10646-UCS-Basic";',
                                      \ '"ISO-10646-Unicode-Latin1";', '"ISO-10646-J-1";', '"ISO-Unicode-IBM-1261";', '"ISO-Unicode-IBM-1268";', '"ISO-Unicode-IBM-1276";', 
                                      \ '"ISO-Unicode-IBM-1264";', '"ISO-Unicode-IBM-1265";', '"UNICODE-1-1";', '"SCSU";', '"UTF-7";', '"UTF-16BE";', '"UTF-16LE";', '"UTF-16";', '"CESU-8";', 
                                      \ '"UTF-32";', '"UTF-32BE";', '"UTF-32LE";', '"BOCU-1";', '"ISO-8859-1-Windows-3.0-Latin-1";', '"ISO-8859-1-Windows-3.1-Latin-1";', 
                                      \ '"ISO-8859-2-Windows-Latin-2";', '"ISO-8859-9-Windows-Latin-5";', '"hp-roman8";', '"Adobe-Standard-Encoding";', '"Ventura-US";', 
                                      \ '"Ventura-International";', '"DEC-MCS";', '"IBM850";', '"PC8-Danish-Norwegian";', '"IBM862";', '"PC8-Turkish";', '"IBM-Symbols";', '"IBM-Thai";', 
                                      \ '"HP-Legal";', '"HP-Pi-font";', '"HP-Math8";', '"Adobe-Symbol-Encoding";', '"HP-DeskTop";', '"Ventura-Math";', '"Microsoft-Publishing";', 
                                      \ '"Windows-31J";', '"GB2312";', '"Big5";', '"macintosh";', '"IBM037";', '"IBM038";', '"IBM273";', '"IBM274";', '"IBM275";', '"IBM277";', '"IBM278";', 
                                      \ '"IBM280";', '"IBM281";', '"IBM284";', '"IBM285";', '"IBM290";', '"IBM297";', '"IBM420";', '"IBM423";', '"IBM424";', '"IBM437";', '"IBM500";', '"IBM851";', 
                                      \ '"IBM852";', '"IBM855";', '"IBM857";', '"IBM860";', '"IBM861";', '"IBM863";', '"IBM864";', '"IBM865";', '"IBM868";', '"IBM869";', '"IBM870";', '"IBM871";', 
                                      \ '"IBM880";', '"IBM891";', '"IBM903";', '"IBM904";', '"IBM905";', '"IBM918";', '"IBM1026";', '"EBCDIC-AT-DE";', '"EBCDIC-AT-DE-A";', '"EBCDIC-CA-FR";', 
                                      \ '"EBCDIC-DK-NO";', '"EBCDIC-DK-NO-A";', '"EBCDIC-FI-SE";', '"EBCDIC-FI-SE-A";', '"EBCDIC-FR";', '"EBCDIC-IT";', '"EBCDIC-PT";', '"EBCDIC-ES";', 
                                      \ '"EBCDIC-ES-A";', '"EBCDIC-ES-S";', '"EBCDIC-UK";', '"EBCDIC-US";', '"UNKNOWN-8BIT";', '"MNEMONIC";', '"MNEM";', '"VISCII";', '"VIQR";', '"KOI8-R";', 
                                      \ '"HZ-GB-2312";', '"IBM866";', '"IBM775";', '"KOI8-U";', '"IBM00858";', '"IBM00924";', '"IBM01140";', '"IBM01141";', '"IBM01142";', '"IBM01143";', 
                                      \ '"IBM01144";', '"IBM01145";', '"IBM01146";', '"IBM01147";', '"IBM01148";', '"IBM01149";', '"Big5-HKSCS";', '"IBM1047";', '"PTCP154";', '"Amiga-1251";', 
                                      \ '"KOI7-switched";', '"BRF";', '"TSCII";', '"windows-1250";', '"windows-1251";', '"windows-1252";', '"windows-1253";', '"windows-1254";', '"windows-1255";', 
                                      \ '"windows-1256";', '"windows-1257";', '"windows-1258";', '"TIS-620";']
                            
                                  elseif atrulename == 'namespace'
                                    let entered_atruleafter = matchstr(line, '.*@namespace\s\+\zs.*$')
                                    let values = ["url("]
                            
                                  elseif atrulename == 'document'
                                    let entered_atruleafter = matchstr(line, '.*@document\s\+\zs.*$')
                                    let values = ["url(", "url-prefix(", "domain(", "regexp("]
                            
                                  elseif atrulename == 'import'
                                    let entered_atruleafter = matchstr(line, '.*@import\s\+\zs.*$')
                            
                                    if entered_atruleafter =~ "^[\"']"
                                      let filestart = matchstr(entered_atruleafter, '^.\zs.*')
                                      let files = split(glob(filestart.'*'), '\n')
                                      let values = map(copy(files), '"\"".v:val')
                            
                                    elseif entered_atruleafter =~ "^url("
                                      let filestart = matchstr(entered_atruleafter, "^url([\"']\\?\\zs.*")
                                      let files = split(glob(filestart.'*'), '\n')
                                      let values = map(copy(files), '"url(".v:val')
                            
                                    else
                                      let values = ['"', 'url(']
                            
                                    endif
                            
                                  else
                                    return []
                            
                                  endif
                            
                                  for m in values
                                    if m =~? '^'.entered_atruleafter
                                      if entered_atruleafter =~? '^"' && m =~? '^"'
                                        let m = m[1:]
                                      endif
                                      if b:after =~? '"' && stridx(m, '"') > -1
                                        let m = m[0:stridx(m, '"')-1]
                                      endif 
                                      call add(res, m)
                                    elseif m =~? entered_atruleafter
                                      if m =~? '^"'
                                        let m = m[1:]
                                      endif
                                      call add(res2, m)
                                    endif
                                  endfor
                            
                                  return res + res2
                            
                                endif
                            
                                let values = ["charset", "page", "media", "import", "font-face", "namespace", "supports", "keyframes", "viewport", "document"]
                            
                                let entered_atrule = matchstr(line, '.*@\zs[a-zA-Z-]*$')
                            
                                for m in values
                                  if m =~? '^'.entered_atrule
                                    call add(res, m .' ')
                                  elseif m =~? entered_atrule
                                    call add(res2, m .' ')
                                  endif
                                endfor
                            
                                return res + res2
                            
                              endif
                            
                              return []
                            
                            endfunction

SCRIPT  /home/pawelztef/.local/share/nvim/plugged/emmet-vim/autoload/emmet/util.vim
Sourced 1 time
Total time:   0.001560
 Self time:   0.001560

count  total (s)   self (s)
                            "==============================================================================
                            " region utils
                            "==============================================================================
                            " deleteContent : delete content in region
                            "   if region make from between '<foo>' and '</foo>'
                            "   --------------------
                            "   begin:<foo>
                            "   </foo>:end
                            "   --------------------
                            "   this function make the content as following
                            "   --------------------
                            "   begin::end
                            "   --------------------
    1              0.000027 function! emmet#util#deleteContent(region) abort
                              let lines = getline(a:region[0][0], a:region[1][0])
                              call setpos('.', [0, a:region[0][0], a:region[0][1], 0])
                              silent! exe 'delete '.(a:region[1][0] - a:region[0][0])
                              call setline(line('.'), lines[0][:a:region[0][1]-2] . lines[-1][a:region[1][1]])
                            endfunction
                            
                            " change_content : change content in region
                            "   if region make from between '<foo>' and '</foo>'
                            "   --------------------
                            "   begin:<foo>
                            "   </foo>:end
                            "   --------------------
                            "   and content is
                            "   --------------------
                            "   foo
                            "   bar
                            "   baz
                            "   --------------------
                            "   this function make the content as following
                            "   --------------------
                            "   begin:foo
                            "   bar
                            "   baz:end
                            "   --------------------
    1              0.000011 function! emmet#util#setContent(region, content) abort
                              let newlines = split(a:content, '\n', 1)
                              let oldlines = getline(a:region[0][0], a:region[1][0])
                              call setpos('.', [0, a:region[0][0], a:region[0][1], 0])
                              silent! exe 'delete '.(a:region[1][0] - a:region[0][0])
                              if len(newlines) == 0
                                let tmp = ''
                                if a:region[0][1] > 1
                                  let tmp = oldlines[0][:a:region[0][1]-2]
                                endif
                                if a:region[1][1] >= 1
                                  let tmp .= oldlines[-1][a:region[1][1]:]
                                endif
                                call setline(line('.'), tmp)
                              elseif len(newlines) == 1
                                if a:region[0][1] > 1
                                  let newlines[0] = oldlines[0][:a:region[0][1]-2] . newlines[0]
                                endif
                                if a:region[1][1] >= 1
                                  let newlines[0] .= oldlines[-1][a:region[1][1]:]
                                endif
                                call setline(line('.'), newlines[0])
                              else
                                if a:region[0][1] > 1
                                  let newlines[0] = oldlines[0][:a:region[0][1]-2] . newlines[0]
                                endif
                                if a:region[1][1] >= 1
                                  let newlines[-1] .= oldlines[-1][a:region[1][1]:]
                                endif
                                call setline(line('.'), newlines[0])
                                call append(line('.'), newlines[1:])
                              endif
                            endfunction
                            
                            " select_region : select region
                            "   this function make a selection of region
    1              0.000010 function! emmet#util#selectRegion(region) abort
                              call setpos('.', [0, a:region[1][0], a:region[1][1], 0])
                              normal! v
                              call setpos('.', [0, a:region[0][0], a:region[0][1], 0])
                            endfunction
                            
                            " point_in_region : check point is in the region
                            "   this function return 0 or 1
    1              0.000008 function! emmet#util#pointInRegion(point, region) abort
                              if !emmet#util#regionIsValid(a:region) | return 0 | endif
                              if a:region[0][0] > a:point[0] | return 0 | endif
                              if a:region[1][0] < a:point[0] | return 0 | endif
                              if a:region[0][0] == a:point[0] && a:region[0][1] > a:point[1] | return 0 | endif
                              if a:region[1][0] == a:point[0] && a:region[1][1] < a:point[1] | return 0 | endif
                              return 1
                            endfunction
                            
                            " cursor_in_region : check cursor is in the region
                            "   this function return 0 or 1
    1              0.000009 function! emmet#util#cursorInRegion(region) abort
                              if !emmet#util#regionIsValid(a:region) | return 0 | endif
                              let cur = emmet#util#getcurpos()[1:2]
                              return emmet#util#pointInRegion(cur, a:region)
                            endfunction
                            
                            " region_is_valid : check region is valid
                            "   this function return 0 or 1
    1              0.000008 function! emmet#util#regionIsValid(region) abort
                              if a:region[0][0] == 0 || a:region[1][0] == 0 | return 0 | endif
                              return 1
                            endfunction
                            
                            " search_region : make region from pattern which is composing start/end
                            "   this function return array of position
    1              0.000008 function! emmet#util#searchRegion(start, end) abort
                              let b = searchpairpos(a:start, '', a:end, 'bcnW')
                              if b == [0, 0]
                                return [searchpairpos(a:start, '', a:end, 'bnW'), searchpairpos(a:start, '\%#', a:end, 'nW')]
                              else
                                return [b, searchpairpos(a:start, '', a:end. '', 'nW')]
                              endif
                            endfunction
                            
                            " get_content : get content in region
                            "   this function return string in region
    1              0.000023 function! emmet#util#getContent(region) abort
                              if !emmet#util#regionIsValid(a:region)
                                return ''
                              endif
                              let lines = getline(a:region[0][0], a:region[1][0])
                              if a:region[0][0] == a:region[1][0]
                                let lines[0] = lines[0][a:region[0][1]-1:a:region[1][1]-1]
                              else
                                let lines[0] = lines[0][a:region[0][1]-1:]
                                let lines[-1] = lines[-1][:a:region[1][1]-1]
                              endif
                              return join(lines, "\n")
                            endfunction
                            
                            " region_in_region : check region is in the region
                            "   this function return 0 or 1
    1              0.000009 function! emmet#util#regionInRegion(outer, inner) abort
                              if !emmet#util#regionIsValid(a:inner) || !emmet#util#regionIsValid(a:outer)
                                return 0
                              endif
                              return emmet#util#pointInRegion(a:inner[0], a:outer) && emmet#util#pointInRegion(a:inner[1], a:outer)
                            endfunction
                            
                            " get_visualblock : get region of visual block
                            "   this function return region of visual block
    1              0.000007 function! emmet#util#getVisualBlock() abort
                              return [[line("'<"), col("'<")], [line("'>"), col("'>")]]
                            endfunction
                            
                            "==============================================================================
                            " html utils
                            "==============================================================================
    1              0.000015 function! emmet#util#getContentFromURL(url) abort
                              let res = system(printf('%s -i %s', g:emmet_curl_command, shellescape(substitute(a:url, '#.*', '', ''))))
                              while res =~# '^HTTP/1.\d 3' || res =~# '^HTTP/1\.\d 200 Connection established' || res =~# '^HTTP/1\.\d 100 Continue'
                                let pos = stridx(res, "\r\n\r\n")
                                if pos != -1
                                  let res = strpart(res, pos+4)
                                else
                                  let pos = stridx(res, "\n\n")
                                  let res = strpart(res, pos+2)
                                endif
                              endwhile
                              let pos = stridx(res, "\r\n\r\n")
                              if pos != -1
                                let content = strpart(res, pos+4)
                              else
                                let pos = stridx(res, "\n\n")
                                let content = strpart(res, pos+2)
                              endif
                              let header = res[:pos-1]
                              let charset = matchstr(content, '<meta[^>]\+content=["''][^;"'']\+;\s*charset=\zs[^;"'']\+\ze["''][^>]*>')
                              if len(charset) == 0
                                let charset = matchstr(content, '<meta\s\+charset=["'']\?\zs[^"'']\+\ze["'']\?[^>]*>')
                              endif
                              if len(charset) == 0
                                let charset = matchstr(header, '\nContent-Type:.* charset=[''"]\?\zs[^''";\n]\+\ze')
                              endif
                              if len(charset) == 0
                                let s1 = len(split(content, '?'))
                                let utf8 = iconv(content, 'utf-8', &encoding)
                                let s2 = len(split(utf8, '?'))
                                return (s2 == s1 || s2 >= s1 * 2) ? utf8 : content
                              endif
                              return iconv(content, charset, &encoding)
                            endfunction
                            
    1              0.000009 function! emmet#util#getTextFromHTML(buf) abort
                              let threshold_len = 100
                              let threshold_per = 0.1
                              let buf = a:buf
                            
                              let buf = strpart(buf, stridx(buf, '</head>'))
                              let buf = substitute(buf, '<style[^>]*>.\{-}</style>', '', 'g')
                              let buf = substitute(buf, '<script[^>]*>.\{-}</script>', '', 'g')
                              let res = ''
                              let max = 0
                              let mx = '\(<td[^>]\{-}>\)\|\(<\/td>\)\|\(<div[^>]\{-}>\)\|\(<\/div>\)'
                              let m = split(buf, mx)
                              for str in m
                                let c = split(str, '<[^>]*?>')
                                let str = substitute(str, '<[^>]\{-}>', ' ', 'g')
                                let str = substitute(str, '&gt;', '>', 'g')
                                let str = substitute(str, '&lt;', '<', 'g')
                                let str = substitute(str, '&quot;', '"', 'g')
                                let str = substitute(str, '&apos;', '''', 'g')
                                let str = substitute(str, '&nbsp;', ' ', 'g')
                                let str = substitute(str, '&yen;', '\&#65509;', 'g')
                                let str = substitute(str, '&amp;', '\&', 'g')
                                let str = substitute(str, '^\s*\(.*\)\s*$', '\1', '')
                                let str = substitute(str, '\s\+', ' ', 'g')
                                let l = len(str)
                                if l > threshold_len
                                  let per = (l+0.0) / len(c)
                                  if max < l && per > threshold_per
                                    let max = l
                                    let res = str
                                  endif
                                endif
                              endfor
                              let res = substitute(res, '^\s*\(.*\)\s*$', '\1', 'g')
                              return res
                            endfunction
                            
    1              0.000009 function! emmet#util#getImageSize(fn) abort
                              let fn = a:fn
                            
                              if emmet#util#isImageMagickInstalled()
                                return emmet#util#imageSizeWithImageMagick(fn)
                              endif
                            
                              if filereadable(fn)
                                let hex = substitute(system('xxd -p "'.fn.'"'), '\n', '', 'g')
                              else
                                if fn !~# '^\w\+://'
                                  let path = fnamemodify(expand('%'), ':p:gs?\\?/?')
                                  if has('win32') || has('win64') | 
                                    let path = tolower(path)
                                  endif
                                  for k in keys(g:emmet_docroot)
                                    let root = fnamemodify(k, ':p:gs?\\?/?')
                                    if has('win32') || has('win64') | 
                                      let root = tolower(root)
                                    endif
                                    if stridx(path, root) == 0
                                      let v = g:emmet_docroot[k]
                                      let fn = (len(v) == 0 ? k : v) . fn
                                      break
                                    endif
                                  endfor
                                endif
                                let hex = substitute(system(g:emmet_curl_command.' "'.fn.'" | xxd -p'), '\n', '', 'g')
                              endif
                            
                              let [width, height] = [-1, -1]
                              if hex =~# '^89504e470d0a1a0a'
                                let width = eval('0x'.hex[32:39])
                                let height = eval('0x'.hex[40:47])
                              endif
                              if hex =~# '^ffd8'
                                let pos = 4
                                while pos < len(hex)
                                  let bs = hex[pos+0:pos+3]
                                  let pos += 4
                                  if bs ==# 'ffc0' || bs ==# 'ffc2'
                                    let pos += 6
                                    let height = eval('0x'.hex[pos+0:pos+1])*256 + eval('0x'.hex[pos+2:pos+3])
                                    let pos += 4
                                    let width = eval('0x'.hex[pos+0:pos+1])*256 + eval('0x'.hex[pos+2:pos+3])
                                    break
                                  elseif bs =~# 'ffd[9a]'
                                    break
                                  elseif bs =~# 'ff\(e[0-9a-e]\|fe\|db\|dd\|c4\)'
                                    let pos += (eval('0x'.hex[pos+0:pos+1])*256 + eval('0x'.hex[pos+2:pos+3])) * 2
                                  endif
                                endwhile
                              endif
                              if hex =~# '^47494638'
                                let width = eval('0x'.hex[14:15].hex[12:13])
                                let height = eval('0x'.hex[18:19].hex[16:17])
                              endif
                            
                              return [width, height]
                            endfunction
                            
    1              0.000010 function! emmet#util#imageSizeWithImageMagick(fn) abort
                              let img_info = system('identify -format "%wx%h" "'.a:fn.'"')
                              let img_size = split(substitute(img_info, '\n', '', ''), 'x')
                              if len(img_size) != 2
                                return [-1, -1]
                              endif
                              return img_size
                            endfunction
                            
    1              0.000008 function! emmet#util#isImageMagickInstalled() abort
                              if !get(g:, 'emmet_use_identify', 1)
                                return 0
                              endif
                              return executable('identify')
                            endfunction
                            
    1              0.000010 function! emmet#util#unique(arr) abort
                              let m = {}
                              let r = []
                              for i in a:arr
                                if !has_key(m, i)
                                  let m[i] = 1
                                  call add(r, i)
                                endif
                              endfor
                              return r
                            endfunction
                            
    1              0.000019 let s:seed = localtime()
    1              0.000008 function! emmet#util#srand(seed) abort
                              let s:seed = a:seed
                            endfunction
                            
    1              0.000006 function! emmet#util#rand() abort
                              let s:seed = s:seed * 214013 + 2531011
                              return (s:seed < 0 ? s:seed - 0x80000000 : s:seed) / 0x10000 % 0x8000
                            endfunction
                            
    1              0.000008 function! emmet#util#cache(name, ...) abort
                              let content = get(a:000, 0, '')
                              let dir = expand('~/.emmet/cache')
                              if !isdirectory(dir)
                                call mkdir(dir, 'p', 0700)
                              endif
                              let file = dir . '/' . substitute(a:name, '\W', '_', 'g')
                              if len(content) == 0
                                if !filereadable(file)
                                  return ''
                                endif
                            	return join(readfile(file), "\n")
                              endif
                              call writefile(split(content, "\n"), file)
                            endfunction
                            
    1              0.000008 function! emmet#util#getcurpos() abort
                              let pos = getpos('.')
                              if mode(0) ==# 'i' && pos[2] > 0
                                let pos[2] -=1
                              endif
                              return pos
                            endfunction
                            
    1              0.000008 function! emmet#util#closePopup() abort
                              return pumvisible() ? "\<c-e>" : ''
                            endfunction

SCRIPT  /home/pawelztef/.local/share/nvim/plugged/emmet-vim/autoload/emmet.vim
Sourced 1 time
Total time:   0.006196
 Self time:   0.006196

count  total (s)   self (s)
                            "=============================================================================
                            " emmet.vim
                            " Author: Yasuhiro Matsumoto <mattn.jp@gmail.com>
                            " Last Change: 26-Jul-2015.
                            
    1              0.000023 let s:save_cpo = &cpoptions
    1              0.000024 set cpoptions&vim
                            
    1              0.000011 let s:filtermx = '|\(\%(bem\|html\|haml\|slim\|e\|c\|s\|fc\|xsl\|t\|\/[^ ]\+\)\s*,\{0,1}\s*\)*$'
                            
    1              0.000012 function! emmet#getExpandos(type, key) abort
                              let expandos = emmet#getResource(a:type, 'expandos', {})
                              if has_key(expandos, a:key)
                                return expandos[a:key]
                              endif
                              return a:key
                            endfunction
                            
    1              0.000008 function! emmet#splitFilterArg(filters) abort
                              for f in a:filters
                                if f =~# '^/'
                                  return f[1:]
                                endif
                              endfor
                              return ''
                            endfunction
                            
    1              0.000009 function! emmet#useFilter(filters, filter) abort
                              for f in a:filters
                                if a:filter ==# '/' && f =~# '^/'
                                  return 1
                                elseif f ==# a:filter
                                  return 1
                                endif
                              endfor
                              return 0
                            endfunction
                            
    1              0.000007 function! emmet#getIndentation(...) abort
                              if a:0 > 0
                                let type = a:1
                              else
                                let type = emmet#getFileType()
                              endif
                              if has_key(s:emmet_settings, type) && has_key(s:emmet_settings[type], 'indentation')
                                let indent = s:emmet_settings[type].indentation
                              elseif has_key(s:emmet_settings, 'indentation')
                                let indent = s:emmet_settings.indentation
                              elseif has_key(s:emmet_settings.variables, 'indentation')
                                let indent = s:emmet_settings.variables.indentation
                              else
                                let sw = exists('*shiftwidth') ? shiftwidth() : &l:shiftwidth
                                let indent = (&l:expandtab || &l:tabstop !=# sw) ? repeat(' ', sw) : "\t"
                              endif
                              return indent
                            endfunction
                            
    1              0.000008 function! emmet#getBaseType(type) abort
                              if !has_key(s:emmet_settings, a:type)
                                return ''
                              endif
                              if !has_key(s:emmet_settings[a:type], 'extends')
                                return a:type
                              endif
                              let extends = s:emmet_settings[a:type].extends
                              if type(extends) ==# 1
                                let tmp = split(extends, '\s*,\s*')
                                let ext = tmp[0]
                              else
                                let ext = extends[0]
                              endif
                              if a:type !=# ext
                                return emmet#getBaseType(ext)
                              endif
                              return ''
                            endfunction
                            
    1              0.000009 function! emmet#isExtends(type, extend) abort
                              if a:type ==# a:extend
                                return 1
                              endif
                              if !has_key(s:emmet_settings, a:type)
                                return 0
                              endif
                              if !has_key(s:emmet_settings[a:type], 'extends')
                                return 0
                              endif
                              let extends = s:emmet_settings[a:type].extends
                              if type(extends) ==# 1
                                let tmp = split(extends, '\s*,\s*')
                                unlet! extends
                                let extends = tmp
                              endif
                              for ext in extends
                                if a:extend ==# ext
                                  return 1
                                endif
                              endfor
                              return 0
                            endfunction
                            
    1              0.000009 function! emmet#parseIntoTree(abbr, type) abort
                              let abbr = a:abbr
                              let type = a:type
                              return emmet#lang#{emmet#lang#type(type)}#parseIntoTree(abbr, type)
                            endfunction
                            
    1              0.000008 function! emmet#expandAbbrIntelligent(feedkey) abort
                              if !emmet#isExpandable()
                                return a:feedkey
                              endif
                              return "\<plug>(emmet-expand-abbr)"
                            endfunction
                            
    1              0.000007 function! emmet#isExpandable() abort
                              let line = getline('.')
                              if col('.') < len(line)
                                let line = matchstr(line, '^\(.*\%'.col('.').'c\)')
                              endif
                              let part = matchstr(line, '\(\S.*\)$')
                              let type = emmet#getFileType()
                              let ftype = emmet#lang#exists(type) ? type : 'html'
                              let part = emmet#lang#{ftype}#findTokens(part)
                              return len(part) > 0
                            endfunction
                            
    1              0.000008 function! emmet#mergeConfig(lhs, rhs) abort
                              let [lhs, rhs] = [a:lhs, a:rhs]
                              if type(lhs) ==# 3
                                if type(rhs) ==# 3
                                  let lhs += rhs
                                  if len(lhs)
                                    call remove(lhs, 0, len(lhs)-1)
                                  endif
                                  for rhi in rhs
                                    call add(lhs, rhs[rhi])
                                  endfor
                                elseif type(rhs) ==# 4
                                  let lhs += map(keys(rhs), '{v:val : rhs[v:val]}')
                                endif
                              elseif type(lhs) ==# 4
                                if type(rhs) ==# 3
                                  for V in rhs
                                    if type(V) != 4
                                      continue
                                    endif
                                    for k in keys(V)
                                      let lhs[k] = V[k]
                                    endfor
                                  endfor
                                elseif type(rhs) ==# 4
                                  for key in keys(rhs)
                                    if type(rhs[key]) ==# 3
                                      if !has_key(lhs, key)
                                        let lhs[key] = []
                                      endif
                                      if type(lhs[key]) == 3
                                        let lhs[key] += rhs[key]
                                      elseif type(lhs[key]) == 4
                                        for k in keys(rhs[key])
                                          let lhs[key][k] = rhs[key][k]
                                        endfor
                                      endif
                                    elseif type(rhs[key]) ==# 4
                                      if has_key(lhs, key)
                                        call emmet#mergeConfig(lhs[key], rhs[key])
                                      else
                                        let lhs[key] = rhs[key]
                                      endif
                                    else
                                      let lhs[key] = rhs[key]
                                    endif
                                  endfor
                                endif
                              endif
                            endfunction
                            
    1              0.000010 function! emmet#newNode() abort
                              return { 'name': '', 'attr': {}, 'child': [], 'snippet': '', 'basevalue': 0, 'basedirect': 1, 'multiplier': 1, 'parent': {}, 'value': '', 'pos': 0, 'important': 0, 'attrs_order': ['id', 'class'], 'block': 0, 'empty': 0 }
                            endfunction
                            
    1              0.000016 function! s:itemno(itemno, current) abort
                              let current = a:current
                              if current.basedirect > 0
                                if current.basevalue ==# 0
                                  return a:itemno
                                else
                                  return current.basevalue - 1 + a:itemno
                                endif
                              else
                                if current.basevalue ==# 0
                                  return current.multiplier - 1 - a:itemno
                                else
                                  return current.multiplier + current.basevalue - 2 - a:itemno
                                endif
                              endif
                            endfunction
                            
    1              0.000008 function! emmet#toString(...) abort
                              let current = a:1
                              if a:0 > 1
                                let type = a:2
                              else
                                let type = &filetype
                              endif
                              if len(type) ==# 0 | let type = 'html' | endif
                              if a:0 > 2
                                let inline = a:3
                              else
                                let inline = 0
                              endif
                              if a:0 > 3
                                if type(a:4) ==# 1
                                  let filters = split(a:4, '\s*,\s*')
                                else
                                  let filters = a:4
                                endif
                              else
                                let filters = ['html']
                              endif
                              if a:0 > 4
                                let group_itemno = a:5
                              else
                                let group_itemno = 0
                              endif
                              if a:0 > 5
                                let indent = a:6
                              else
                                let indent = ''
                              endif
                            
                              let dollar_expr = emmet#getResource(type, 'dollar_expr', 1)
                              let itemno = 0
                              let str = ''
                              let rtype = emmet#lang#type(type)
                              while itemno < current.multiplier
                                if len(current.name)
                                  if current.multiplier ==# 1
                                    let inner = emmet#lang#{rtype}#toString(s:emmet_settings, current, type, inline, filters, s:itemno(group_itemno, current), indent)
                                  else
                                    let inner = emmet#lang#{rtype}#toString(s:emmet_settings, current, type, inline, filters, s:itemno(itemno, current), indent)
                                  endif
                                  if current.multiplier > 1
                                    let inner = substitute(inner, '\$#', '$line'.(itemno+1).'$', 'g')
                                  endif
                                  let str .= inner
                                else
                                  let snippet = current.snippet
                                  if len(snippet) ==# 0
                                    let snippets = emmet#getResource(type, 'snippets', {})
                                    if !empty(snippets) && has_key(snippets, 'emmet_snippet')
                                      let snippet = snippets['emmet_snippet']
                                    endif
                                  endif
                                  if len(snippet) > 0
                                    let tmp = snippet
                                    let tmp = substitute(tmp, '\${emmet_name}', current.name, 'g')
                                    let snippet_node = emmet#newNode()
                                    let snippet_node.value = '{'.tmp.'}'
                                    let snippet_node.important = current.important
                                    let snippet_node.multiplier = current.multiplier
                                    let str .= emmet#lang#{rtype}#toString(s:emmet_settings, snippet_node, type, inline, filters, s:itemno(group_itemno, current), indent)
                                    if current.multiplier > 1
                                      let str .= "\n"
                                    endif
                                  else
                                    if len(current.name)
                                      let str .= current.name
                                    endif
                                    if len(current.value)
                                      let text = current.value[1:-2]
                                      if dollar_expr
                                        " TODO: regexp engine specified
                                        if exists('&regexpengine')
                                          let text = substitute(text, '\%#=1\%(\\\)\@\<!\(\$\+\)\([^{#]\|$\)', '\=printf("%0".len(submatch(1))."d", max([itemno, group_itemno])+1).submatch(2)', 'g')
                                        else
                                          let text = substitute(text, '\%(\\\)\@\<!\(\$\+\)\([^{#]\|$\)', '\=printf("%0".len(submatch(1))."d", max([itemno, group_itemno])+1).submatch(2)', 'g')
                                        endif
                                        let text = substitute(text, '\${nr}', "\n", 'g')
                                        let text = substitute(text, '\\\$', '$', 'g')
                                      endif
                                      let str .= text
                                    endif
                                  endif
                                  let inner = ''
                                  if len(current.child)
                                    for n in current.child
                                      let inner .= emmet#toString(n, type, inline, filters, s:itemno(group_itemno, n), indent)
                                    endfor
                                  else
                                    let inner = current.value[1:-2]
                                  endif
                                  let inner = substitute(inner, "\n", "\n" . indent, 'g')
                                  let str = substitute(str, '\${child}', inner, '')
                                endif
                                let itemno = itemno + 1
                              endwhile
                              return str
                            endfunction
                            
    1              0.000010 function! emmet#getSettings() abort
                              return s:emmet_settings
                            endfunction
                            
    1              0.000009 function! emmet#getFilters(type) abort
                              let filterstr = emmet#getResource(a:type, 'filters', '')
                              return split(filterstr, '\s*,\s*')
                            endfunction
                            
    1              0.000015 function! emmet#getResource(type, name, default) abort
                              if exists('b:emmet_' . a:name)
                                return get(b:, 'emmet_' . a:name)
                              endif
                              let global = {}
                              if has_key(s:emmet_settings, '*') && has_key(s:emmet_settings['*'], a:name)
                                let global = extend(global, s:emmet_settings['*'][a:name])
                              endif
                            
                              if has_key(s:emmet_settings, a:type)
                                let types = [a:type]
                              else
                                let types = split(a:type, '\.')
                              endif
                            
                              for type in types
                                if !has_key(s:emmet_settings, type)
                                  continue
                                endif
                                let ret = a:default
                            
                                if has_key(s:emmet_settings[type], 'extends')
                                  let extends = s:emmet_settings[type].extends
                                  if type(extends) ==# 1
                                    let tmp = split(extends, '\s*,\s*')
                                    unlet! extends
                                    let extends = tmp
                                  endif
                                  for ext in extends
                                    if has_key(s:emmet_settings, ext) && has_key(s:emmet_settings[ext], a:name)
                                      if type(ret) ==# 3 || type(ret) ==# 4
                                        call emmet#mergeConfig(ret, s:emmet_settings[ext][a:name])
                                      else
                                        let ret = s:emmet_settings[ext][a:name]
                                      endif
                                    endif
                                  endfor
                                endif
                            
                                if has_key(s:emmet_settings[type], a:name)
                                  if type(ret) ==# 3 || type(ret) ==# 4
                                    call emmet#mergeConfig(ret, s:emmet_settings[type][a:name])
                                    return extend(global, ret)
                                  else
                                    return s:emmet_settings[type][a:name]
                                  endif
                                endif
                                if !empty(ret)
                                  if type(ret) ==# 3 || type(ret) ==# 4
                                    let ret = extend(global, ret)
                                  endif
                                  return ret
                                endif
                              endfor
                            
                              let ret = a:default
                              if type(ret) ==# 3 || type(ret) ==# 4
                                let ret = extend(global, ret)
                              endif
                              return ret
                            endfunction
                            
    1              0.000008 function! emmet#getFileType(...) abort
                              let flg = get(a:000, 0, 0)
                              let type = ''
                            
                              if has_key(s:emmet_settings, &filetype)
                                let type = &filetype
                              else
                                let types = split(&filetype, '\.')
                                for part in types
                                  if emmet#lang#exists(part)
                                    let type = part
                                    break
                                  endif
                                  let base = emmet#getBaseType(part)
                                  if base !=# ''
                                    if flg
                                      let type = &filetype
                                    else
                                      let type = base
                                    endif
                                    unlet base
                                    break
                                  endif
                                endfor
                              endif
                              if type ==# 'html'
                                let pos = emmet#util#getcurpos()
                                let type = synIDattr(synID(pos[1], pos[2], 1), 'name')
                                if type =~# '^css\w'
                                  let type = 'css'
                                endif
                                if type =~# '^html\w'
                                  let type = 'html'
                                endif
                                if type =~# '^javaScript'
                                  let type = 'javascript'
                                endif
                                if len(type) ==# 0 && type =~# '^xml'
                                  let type = 'xml'
                                endif
                              endif
                              if len(type) ==# 0 | let type = 'html' | endif
                              return type
                            endfunction
                            
    1              0.000009 function! emmet#getDollarExprs(expand) abort
                              let expand = a:expand
                              let dollar_list = []
                              let dollar_reg = '\%(\\\)\@<!\${\(\([^{}]\|\%(\\\)\@\<=[{}]\)\{}\)}'
                              while 1
                                let matcharr = matchlist(expand, dollar_reg)
                                if len(matcharr) > 0
                                  let key = get(matcharr, 1)
                                  if key !~# '^\d\+:'
                                    let key = substitute(key, '\\{', '{', 'g')
                                    let key = substitute(key, '\\}', '}', 'g')
                                    let value = emmet#getDollarValueByKey(key)
                                    if type(value) ==# type('')
                                      let expr = get(matcharr, 0)
                                      call add(dollar_list, {'expr': expr, 'value': value})
                                    endif
                                  endif
                                else
                                  break
                                endif
                                let expand = substitute(expand, dollar_reg, '', '')
                              endwhile
                              return dollar_list
                            endfunction
                            
    1              0.000009 function! emmet#getDollarValueByKey(key) abort
                              let ret = 0
                              let key = a:key
                              let ftsetting = get(s:emmet_settings, emmet#getFileType())
                              if type(ftsetting) ==# 4 && has_key(ftsetting, key)
                                let V = get(ftsetting, key)
                                if type(V) ==# 1 | return V | endif
                              endif
                              if type(ret) !=# 1 && has_key(s:emmet_settings.variables, key)
                                let V = get(s:emmet_settings.variables, key)
                                if type(V) ==# 1 | return V | endif
                              endif
                              if has_key(s:emmet_settings, 'custom_expands') && type(s:emmet_settings['custom_expands']) ==# 4
                                for k in keys(s:emmet_settings['custom_expands'])
                                  if key =~# k
                                    let V = get(s:emmet_settings['custom_expands'], k)
                                    if type(V) ==# 1 | return V | endif
                                    if type(V) ==# 2 | return V(key) | endif
                                  endif
                                endfor
                              endif
                              return ret
                            endfunction
                            
    1              0.000010 function! emmet#reExpandDollarExpr(expand, times) abort
                              let expand = a:expand
                              let dollar_exprs = emmet#getDollarExprs(expand)
                              if len(dollar_exprs) > 0
                                if a:times < 9
                                  for n in range(len(dollar_exprs))
                                    let pair = get(dollar_exprs, n)
                                    let pat = get(pair, 'expr')
                                    let sub = get(pair, 'value')
                                    let expand = substitute(expand, pat, sub, '')
                                  endfor
                                  return emmet#reExpandDollarExpr(expand, a:times + 1)
                                endif
                              endif
                              return expand
                            endfunction
                            
    1              0.000010 function! emmet#expandDollarExpr(expand) abort
                              return emmet#reExpandDollarExpr(a:expand, 0)
                            endfunction
                            
    1              0.000007 function! emmet#expandCursorExpr(expand, mode) abort
                              let expand = a:expand
                              if expand !~# '\${cursor}'
                                if a:mode ==# 2
                                  let expand = '${cursor}' . expand
                                else
                                  let expand .= '${cursor}'
                                endif
                              endif
                              let expand = substitute(expand, '\${\d\+:\?\([^}]\+\)}', '$select$$cursor$\1$select$', 'g')
                              let expand = substitute(expand, '\${\d\+}', '$select$$cursor$$select$', 'g')
                              let expand = substitute(expand, '\${cursor}', '$cursor$', '')
                              let expand = substitute(expand, '\${cursor}', '', 'g')
                              let expand = substitute(expand, '\${cursor}', '', 'g')
                              return expand
                            endfunction
                            
    1              0.000009 function! emmet#unescapeDollarExpr(expand) abort
                              return substitute(a:expand, '\\\$', '$', 'g')
                            endfunction
                            
    1              0.000009 function! emmet#expandAbbr(mode, abbr) range abort
                              let type = emmet#getFileType()
                              let rtype = emmet#lang#type(emmet#getFileType(1))
                              let indent = emmet#getIndentation(type)
                              let expand = ''
                              let line = ''
                              let part = ''
                              let rest = ''
                            
                              let filters = emmet#getFilters(type)
                              if len(filters) ==# 0
                                let filters = ['html']
                              endif
                            
                              if a:mode ==# 2
                                let leader = substitute(input('Tag: ', ''), '^\s*\(.*\)\s*$', '\1', 'g')
                                if len(leader) ==# 0
                                  return ''
                                endif
                                if leader =~# s:filtermx
                                  let filters = map(split(matchstr(leader, s:filtermx)[1:], '\s*[^\\]\zs,\s*'), 'substitute(v:val, "\\\\\\\\zs.\\\\ze", "&", "g")')
                                  let leader = substitute(leader, s:filtermx, '', '')
                                endif
                                if leader =~# '\*'
                                  let query = substitute(leader, '*', '*' . (a:lastline - a:firstline + 1), '')
                                  if query !~# '}\s*$' && query !~# '\$#'
                                    let query .= '>{$#}'
                                  endif
                                  if emmet#useFilter(filters, '/')
                                    let spl = emmet#splitFilterArg(filters)
                                    let fline = getline(a:firstline)
                                    let query = substitute(query, '>\{0,1}{\$#}\s*$', '{\\$column\\$}*' . len(split(fline, spl)), '')
                                  else
                                    let spl = ''
                                  endif
                                  let items = emmet#parseIntoTree(query, type).child
                                  let itemno = 0
                                  for item in items
                                    let inner = emmet#toString(item, type, 0, filters, 0, indent)
                                    let inner = substitute(inner, '\$#', '$line'.(itemno*(a:lastline - a:firstline + 1)/len(items)+1).'$', 'g')
                                    let expand .= inner
                                    let itemno = itemno + 1
                                  endfor
                                  if emmet#useFilter(filters, 'e')
                                    let expand = substitute(expand, '&', '\&amp;', 'g')
                                    let expand = substitute(expand, '<', '\&lt;', 'g')
                                    let expand = substitute(expand, '>', '\&gt;', 'g')
                                  endif
                                  let line = getline(a:firstline)
                                  let part = substitute(line, '^\s*', '', '')
                                  for n in range(a:firstline, a:lastline)
                                    let lline = getline(n)
                                    let lpart = substitute(lline, '^\s\+', '', '')
                                    if emmet#useFilter(filters, 't')
                                      let lpart = substitute(lpart, '^[0-9.-]\+\s\+', '', '')
                                      let lpart = substitute(lpart, '\s\+$', '', '')
                                    endif
                                    if emmet#useFilter(filters, '/')
                                      for column in split(lpart, spl)
                                        let expand = substitute(expand, '\$column\$', '\=column', '')
                                      endfor
                                    else
                                      let expand = substitute(expand, '\$line'.(n-a:firstline+1).'\$', '\=lpart', 'g')
                                    endif
                                  endfor
                                  let expand = substitute(expand, '\$line\d*\$', '', 'g')
                                  let expand = substitute(expand, '\$column\$', '', 'g')
                                  let content = join(getline(a:firstline, a:lastline), "\n")
                                  if stridx(expand, '$#') < len(expand)-2
                                    let expand = substitute(expand, '^\(.*\)\$#\s*$', '\1', '')
                                  endif
                                  let expand = substitute(expand, '\$#', '\=content', 'g')
                                else
                                  let str = ''
                                  if visualmode() ==# 'V'
                                    let line = getline(a:firstline)
                                    let lspaces = matchstr(line, '^\s*', '', '')
                                    let part = substitute(line, '^\s*', '', '')
                                    for n in range(a:firstline, a:lastline)
                                      if len(leader) > 0
                                        let line = getline(a:firstline)
                                        let spaces = matchstr(line, '^\s*', '', '')
                                        if len(spaces) >= len(lspaces)
                                          let str .= indent . getline(n)[len(lspaces):] . "\n"
                                        else
                                          let str .= getline(n) . "\n"
                                        endif
                                      else
                                        let lpart = substitute(getline(n), '^\s*', '', '')
                                        let str .= lpart . "\n"
                                      endif
                                    endfor
                                    if stridx(leader, '{$#}') ==# -1
                                      let leader .= '{$#}'
                                    endif
                                    let items = emmet#parseIntoTree(leader, type).child
                                  else
                                    let save_regcont = @"
                                    let save_regtype = getregtype('"')
                                    silent! normal! gvygv
                                    let str = @"
                                    call setreg('"', save_regcont, save_regtype)
                                    if stridx(leader, '{$#}') ==# -1
                                      let leader .= '{$#}'
                                    endif
                                    let items = emmet#parseIntoTree(leader, type).child
                                  endif
                                  for item in items
                                    let expand .= emmet#toString(item, type, 0, filters, 0, '')
                                  endfor
                                  if emmet#useFilter(filters, 'e')
                                    let expand = substitute(expand, '&', '\&amp;', 'g')
                                    let expand = substitute(expand, '<', '\&lt;', 'g')
                                    let expand = substitute(expand, '>', '\&gt;', 'g')
                                  endif
                                  if stridx(leader, '{$#}') !=# -1
                                    let expand = substitute(expand, '\$#', '\="\n" . str', 'g')
                                  endif
                                endif
                              elseif a:mode ==# 4
                                let line = getline('.')
                                let spaces = matchstr(line, '^\s*')
                                if line !~# '^\s*$'
                                  put =spaces.a:abbr
                                else
                                  call setline('.', spaces.a:abbr)
                                endif
                                normal! $
                                call emmet#expandAbbr(0, '')
                                return ''
                              else
                                let line = getline('.')
                                if col('.') < len(line)
                                  let line = matchstr(line, '^\(.*\%'.col('.').'c\)')
                                endif
                                if a:mode ==# 1
                                  let part = matchstr(line, '\([a-zA-Z0-9:_\-\@|]\+\)$')
                                else
                                  let part = matchstr(line, '\(\S.*\)$')
                                  let ftype = emmet#lang#exists(type) ? type : 'html'
                                  let part = emmet#lang#{ftype}#findTokens(part)
                                  let line = line[0: strridx(line, part) + len(part) - 1]
                                endif
                                if col('.') ==# col('$')
                                  let rest = ''
                                else
                                  let rest = getline('.')[len(line):]
                                endif
                                let str = part
                                if str =~# s:filtermx
                                  let filters = split(matchstr(str, s:filtermx)[1:], '\s*,\s*')
                                  let str = substitute(str, s:filtermx, '', '')
                                endif
                                let items = emmet#parseIntoTree(str, type).child
                                for item in items
                                  let expand .= emmet#toString(item, type, 0, filters, 0, indent)
                                endfor
                                if emmet#useFilter(filters, 'e')
                                  let expand = substitute(expand, '&', '\&amp;', 'g')
                                  let expand = substitute(expand, '<', '\&lt;', 'g')
                                  let expand = substitute(expand, '>', '\&gt;', 'g')
                                endif
                                let expand = substitute(expand, '\$line\([0-9]\+\)\$', '\=submatch(1)', 'g')
                              endif
                              let expand = emmet#expandDollarExpr(expand)
                              let expand = emmet#expandCursorExpr(expand, a:mode)
                              if len(expand)
                                if has_key(s:emmet_settings, 'timezone') && len(s:emmet_settings.timezone)
                                  let expand = substitute(expand, '${datetime}', strftime('%Y-%m-%dT%H:%M:%S') . s:emmet_settings.timezone, 'g')
                                else
                                  " TODO: on windows, %z/%Z is 'Tokyo(Standard)'
                                  let expand = substitute(expand, '${datetime}', strftime('%Y-%m-%dT%H:%M:%S %z'), 'g')
                                endif
                                let expand = emmet#unescapeDollarExpr(expand)
                                if a:mode ==# 2 && visualmode() ==# 'v'
                                  if a:firstline ==# a:lastline
                                    let expand = substitute(expand, '[\r\n]\s*', '', 'g')
                                  else
                                    let expand = substitute(expand, '[\n]$', '', 'g')
                                  endif
                                  silent! normal! gv
                                  let col = col('''<')
                                  silent! normal! c
                                  let line = getline('.')
                                  let lhs = matchstr(line, '.*\%<'.col.'c.')
                                  let rhs = matchstr(line, '\%>'.(col-1).'c.*')
                                  let expand = lhs.expand.rhs
                                  let lines = split(expand, '\n')
                                  call setline(line('.'), lines[0])
                                  if len(lines) > 1
                                    call append(line('.'), lines[1:])
                                  endif
                                else
                                  if line[:-len(part)-1] =~# '^\s\+$'
                                    let indent = line[:-len(part)-1]
                                  else
                                    let indent = ''
                                  endif
                                  let expand = substitute(expand, '[\r\n]\s*$', '', 'g')
                                  if emmet#useFilter(filters, 's')
                                    let epart = substitute(expand, '[\r\n]\s*', '', 'g')
                                  else
                                    let epart = substitute(expand, '[\r\n]', "\n" . indent, 'g')
                                  endif
                                  let expand = line[:-len(part)-1] . epart . rest
                                  let lines = split(expand, '[\r\n]', 1)
                                  if a:mode ==# 2
                                    silent! exe 'normal! gvc'
                                  endif
                                  call setline('.', lines[0])
                                  if len(lines) > 1
                                    call append('.', lines[1:])
                                  endif
                                endif
                              endif
                              if g:emmet_debug > 1
                                call getchar()
                              endif
                              if search('\ze\$\(cursor\|select\)\$', 'c')
                                let oldselection = &selection
                                let &selection = 'inclusive'
                                if foldclosed(line('.')) !=# -1
                                  silent! foldopen
                                endif
                                let pos = emmet#util#getcurpos()
                                let use_selection = emmet#getResource(type, 'use_selection', 0)
                                try
                                  let l:gdefault = &gdefault
                                  let &gdefault = 0
                                  if use_selection && getline('.')[col('.')-1:] =~# '^\$select'
                                    let pos[2] += 1
                                    silent! s/\$select\$//
                                    let next = searchpos('.\ze\$select\$', 'nW')
                                    silent! %s/\$\(cursor\|select\)\$//g
                                    call emmet#util#selectRegion([pos[1:2], next])
                                    return "\<esc>gv"
                                  else
                                    silent! %s/\$\(cursor\|select\)\$//g
                                    silent! call setpos('.', pos)
                                    if col('.') < col('$')
                                      return "\<right>"
                                    endif
                                  endif
                                finally
                                  let &gdefault = l:gdefault
                                endtry
                                let &selection = oldselection
                              endif
                              return ''
                            endfunction
                            
    1              0.000007 function! emmet#updateTag() abort
                              let type = emmet#getFileType()
                              let region = emmet#util#searchRegion('<\S', '>')
                              if !emmet#util#regionIsValid(region) || !emmet#util#cursorInRegion(region)
                                return ''
                              endif
                              let content = emmet#util#getContent(region)
                              let content = matchstr(content,  '^<[^><]\+>')
                              if content !~# '^<[^><]\+>$'
                                return ''
                              endif
                              let current = emmet#lang#html#parseTag(content)
                              if empty(current)
                                return ''
                              endif
                            
                              let str = substitute(input('Enter Abbreviation: ', ''), '^\s*\(.*\)\s*$', '\1', 'g')
                              let item = emmet#parseIntoTree(str, type).child[0]
                              for k in keys(item.attr)
                                let current.attr[k] = item.attr[k]
                              endfor
                              let html = substitute(emmet#toString(current, 'html', 1), '\n', '', '')
                              let html = substitute(html, '\${cursor}', '', '')
                              let html = matchstr(html,  '^<[^><]\+>')
                              call emmet#util#setContent(region, html)
                              return ''
                            endfunction
                            
    1              0.000005 function! emmet#moveNextPrevItem(flag) abort
                              let type = emmet#getFileType()
                              return emmet#lang#{emmet#lang#type(type)}#moveNextPrevItem(a:flag)
                            endfunction
                            
    1              0.000006 function! emmet#moveNextPrev(flag) abort
                              let type = emmet#getFileType()
                              return emmet#lang#{emmet#lang#type(type)}#moveNextPrev(a:flag)
                            endfunction
                            
    1              0.000005 function! emmet#imageSize() abort
                              let orgpos = emmet#util#getcurpos()
                              let type = emmet#getFileType()
                              call emmet#lang#{emmet#lang#type(type)}#imageSize()
                              silent! call setpos('.', orgpos)
                              return ''
                            endfunction
                            
    1              0.000005 function! emmet#encodeImage() abort
                              let type = emmet#getFileType()
                              return emmet#lang#{emmet#lang#type(type)}#encodeImage()
                            endfunction
                            
    1              0.000006 function! emmet#toggleComment() abort
                              let type = emmet#getFileType()
                              call emmet#lang#{emmet#lang#type(type)}#toggleComment()
                              return ''
                            endfunction
                            
    1              0.000005 function! emmet#balanceTag(flag) range abort
                              let type = emmet#getFileType()
                              return emmet#lang#{emmet#lang#type(type)}#balanceTag(a:flag)
                            endfunction
                            
    1              0.000005 function! emmet#splitJoinTag() abort
                              let type = emmet#getFileType()
                              return emmet#lang#{emmet#lang#type(type)}#splitJoinTag()
                            endfunction
                            
    1              0.000006 function! emmet#mergeLines() range abort
                              let lines = join(map(getline(a:firstline, a:lastline), 'matchstr(v:val, "^\\s*\\zs.*\\ze\\s*$")'), '')
                              let indent = substitute(getline('.'), '^\(\s*\).*', '\1', '')
                              silent! exe 'normal! gvc'
                              call setline('.', indent . lines)
                            endfunction
                            
    1              0.000005 function! emmet#removeTag() abort
                              let type = emmet#getFileType()
                              call emmet#lang#{emmet#lang#type(type)}#removeTag()
                              return ''
                            endfunction
                            
    1              0.000006 function! emmet#anchorizeURL(flag) abort
                              let mx = 'https\=:\/\/[-!#$%&*+,./:;=?@0-9a-zA-Z_~]\+'
                              let pos1 = searchpos(mx, 'bcnW')
                              let url = matchstr(getline(pos1[0])[pos1[1]-1:], mx)
                              let block = [pos1, [pos1[0], pos1[1] + len(url) - 1]]
                              if !emmet#util#cursorInRegion(block)
                                return ''
                              endif
                            
                              let mx = '.*<title[^>]*>\s*\zs\([^<]\+\)\ze\s*<\/title[^>]*>.*'
                              let content = emmet#util#getContentFromURL(url)
                              let content = substitute(content, '\r', '', 'g')
                              let content = substitute(content, '[ \n]\+', ' ', 'g')
                              let content = substitute(content, '<!--.\{-}-->', '', 'g')
                              let title = matchstr(content, mx)
                            
                              let type = emmet#getFileType()
                              let rtype = emmet#lang#type(type)
                              if &filetype ==# 'markdown'
                                let expand = printf('[%s](%s)', substitute(title, '[\[\]]', '\\&', 'g'), url)
                              elseif a:flag ==# 0
                                let a = emmet#lang#html#parseTag('<a>')
                                let a.attr.href = url
                                let a.value = '{' . title . '}'
                                let expand = emmet#toString(a, rtype, 0, [])
                                let expand = substitute(expand, '\${cursor}', '', 'g')
                              else
                                let body = emmet#util#getTextFromHTML(content)
                                let body = '{' . substitute(body, '^\(.\{0,100}\).*', '\1', '') . '...}'
                            
                                let blockquote = emmet#lang#html#parseTag('<blockquote class="quote">')
                                let a = emmet#lang#html#parseTag('<a>')
                                let a.attr.href = url
                                let a.value = '{' . title . '}'
                                call add(blockquote.child, a)
                                call add(blockquote.child, emmet#lang#html#parseTag('<br/>'))
                                let p = emmet#lang#html#parseTag('<p>')
                                let p.value = body
                                call add(blockquote.child, p)
                                let cite = emmet#lang#html#parseTag('<cite>')
                                let cite.value = '{' . url . '}'
                                call add(blockquote.child, cite)
                                let expand = emmet#toString(blockquote, rtype, 0, [])
                                let expand = substitute(expand, '\${cursor}', '', 'g')
                              endif
                              let indent = substitute(getline('.'), '^\(\s*\).*', '\1', '')
                              let expand = substitute(expand, "\n", "\n" . indent, 'g')
                              call emmet#util#setContent(block, expand)
                              return ''
                            endfunction
                            
    1              0.000006 function! emmet#codePretty() range abort
                              let type = input('FileType: ', &filetype, 'filetype')
                              if len(type) ==# 0
                                return
                              endif
                              let block = emmet#util#getVisualBlock()
                              let content = emmet#util#getContent(block)
                              silent! 1new
                              let &l:filetype = type
                              call setline(1, split(content, "\n"))
                              let old_lazyredraw = &lazyredraw
                              set lazyredraw
                              silent! TOhtml
                              let &lazyredraw = old_lazyredraw
                              let content = join(getline(1, '$'), "\n")
                              silent! bw!
                              silent! bw!
                              let content = matchstr(content, '<body[^>]*>[\s\n]*\zs.*\ze</body>')
                              call emmet#util#setContent(block, content)
                            endfunction
                            
    1              0.000006 function! emmet#expandWord(abbr, type, orig) abort
                              let str = a:abbr
                              let type = a:type
                              let indent = emmet#getIndentation(type)
                            
                              if len(type) ==# 0 | let type = 'html' | endif
                              if str =~# s:filtermx
                                let filters = split(matchstr(str, s:filtermx)[1:], '\s*,\s*')
                                let str = substitute(str, s:filtermx, '', '')
                              else
                                let filters = emmet#getFilters(a:type)
                                if len(filters) ==# 0
                                  let filters = ['html']
                                endif
                              endif
                              let str = substitute(str, '|', '${cursor}', 'g')
                              let items = emmet#parseIntoTree(str, a:type).child
                              let expand = ''
                              for item in items
                                let expand .= emmet#toString(item, a:type, 0, filters, 0, indent)
                              endfor
                              if emmet#useFilter(filters, 'e')
                                let expand = substitute(expand, '&', '\&amp;', 'g')
                                let expand = substitute(expand, '<', '\&lt;', 'g')
                                let expand = substitute(expand, '>', '\&gt;', 'g')
                              endif
                              if emmet#useFilter(filters, 's')
                                let expand = substitute(expand, "\n\s\*", '', 'g')
                              endif
                              if a:orig ==# 0
                                let expand = emmet#expandDollarExpr(expand)
                                let expand = substitute(expand, '\${cursor}', '', 'g')
                              endif
                              return expand
                            endfunction
                            
    1              0.000006 function! emmet#getSnippets(type) abort
                              let type = a:type
                              if len(type) ==# 0 || !has_key(s:emmet_settings, type)
                                let type = 'html'
                              endif
                              return emmet#getResource(type, 'snippets', {})
                            endfunction
                            
    1              0.000006 function! emmet#completeTag(findstart, base) abort
                              if a:findstart
                                let line = getline('.')
                                let start = col('.') - 1
                                while start > 0 && line[start - 1] =~# '[a-zA-Z0-9:_\@\-]'
                                  let start -= 1
                                endwhile
                                return start
                              else
                                let type = emmet#getFileType()
                                let res = []
                            
                                let snippets = emmet#getResource(type, 'snippets', {})
                                for item in keys(snippets)
                                  if stridx(item, a:base) !=# -1
                                    call add(res, substitute(item, '\${cursor}\||', '', 'g'))
                                  endif
                                endfor
                                let aliases = emmet#getResource(type, 'aliases', {})
                                for item in values(aliases)
                                  if stridx(item, a:base) !=# -1
                                    call add(res, substitute(item, '\${cursor}\||', '', 'g'))
                                  endif
                                endfor
                                return res
                              endif
                            endfunction
                            
    1              0.000006 unlet! s:emmet_settings
    1              0.002755 let s:emmet_settings = {
                            \    'variables': {
                            \      'lang': "en",
                            \      'locale': "en-US",
                            \      'charset': "UTF-8",
                            \      'newline': "\n",
                            \      'use_selection': 0,
                            \    },
                            \    'custom_expands' : {
                            \      '^\%(lorem\|lipsum\)\(\d*\)$' : function('emmet#lorem#en#expand'),
                            \    },
                            \    'css': {
                            \        'snippets': {
                            \           "@i": "@import url(|);",
                            \           "@import": "@import url(|);",
                            \           "@m": "@media ${1:screen} {\n\t|\n}",
                            \           "@media": "@media ${1:screen} {\n\t|\n}",
                            \           "@f": "@font-face {\n\tfont-family:|;\n\tsrc:url(|);\n}",
                            \           "@f+": "@font-face {\n\tfont-family: '${1:FontName}';\n\tsrc: url('${2:FileName}.eot');\n\tsrc: url('${2:FileName}.eot?#iefix') format('embedded-opentype'),\n\t\t url('${2:FileName}.woff') format('woff'),\n\t\t url('${2:FileName}.ttf') format('truetype'),\n\t\t url('${2:FileName}.svg#${1:FontName}') format('svg');\n\tfont-style: ${3:normal};\n\tfont-weight: ${4:normal};\n}",
                            \           "@kf": "@-webkit-keyframes ${1:identifier} {\n\t${2:from} { ${3} }${6}\n\t${4:to} { ${5} }\n}\n@-o-keyframes ${1:identifier} {\n\t${2:from} { ${3} }${6}\n\t${4:to} { ${5} }\n}\n@-moz-keyframes ${1:identifier} {\n\t${2:from} { ${3} }${6}\n\t${4:to} { ${5} }\n}\n@keyframes ${1:identifier} {\n\t${2:from} { ${3} }${6}\n\t${4:to} { ${5} }\n}",
                            \           "anim": "animation:|;",
                            \           "anim-": "animation:${1:name} ${2:duration} ${3:timing-function} ${4:delay} ${5:iteration-count} ${6:direction} ${7:fill-mode};",
                            \           "animdel": "animation-delay:${1:time};",
                            \           "animdir": "animation-direction:${1:normal};",
                            \           "animdir:n": "animation-direction:normal;",
                            \           "animdir:r": "animation-direction:reverse;",
                            \           "animdir:a": "animation-direction:alternate;",
                            \           "animdir:ar": "animation-direction:alternate-reverse;",
                            \           "animdur": "animation-duration:${1:0}s;",
                            \           "animfm": "animation-fill-mode:${1:both};",
                            \           "animfm:f": "animation-fill-mode:forwards;",
                            \           "animfm:b": "animation-fill-mode:backwards;",
                            \           "animfm:bt": "animation-fill-mode:both;",
                            \           "animfm:bh": "animation-fill-mode:both;",
                            \           "animic": "animation-iteration-count:${1:1};",
                            \           "animic:i": "animation-iteration-count:infinite;",
                            \           "animn": "animation-name:${1:none};",
                            \           "animps": "animation-play-state:${1:running};",
                            \           "animps:p": "animation-play-state:paused;",
                            \           "animps:r": "animation-play-state:running;",
                            \           "animtf": "animation-timing-function:${1:linear};",
                            \           "animtf:e": "animation-timing-function:ease;",
                            \           "animtf:ei": "animation-timing-function:ease-in;",
                            \           "animtf:eo": "animation-timing-function:ease-out;",
                            \           "animtf:eio": "animation-timing-function:ease-in-out;",
                            \           "animtf:l": "animation-timing-function:linear;",
                            \           "animtf:cb": "animation-timing-function:cubic-bezier(${1:0.1}, ${2:0.7}, ${3:1.0}, ${3:0.1});",
                            \           "ap": "appearance:${none};",
                            \           "!": "!important",
                            \           "pos": "position:${1:relative};",
                            \           "pos:s": "position:static;",
                            \           "pos:a": "position:absolute;",
                            \           "pos:r": "position:relative;",
                            \           "pos:f": "position:fixed;",
                            \           "t": "top:|;",
                            \           "t:a": "top:auto;",
                            \           "r": "right:|;",
                            \           "r:a": "right:auto;",
                            \           "b": "bottom:|;",
                            \           "b:a": "bottom:auto;",
                            \           "l": "left:|;",
                            \           "l:a": "left:auto;",
                            \           "z": "z-index:|;",
                            \           "z:a": "z-index:auto;",
                            \           "fl": "float:${1:left};",
                            \           "fl:n": "float:none;",
                            \           "fl:l": "float:left;",
                            \           "fl:r": "float:right;",
                            \           "cl": "clear:${1:both};",
                            \           "cl:n": "clear:none;",
                            \           "cl:l": "clear:left;",
                            \           "cl:r": "clear:right;",
                            \           "cl:b": "clear:both;",
                            \           "colm": "columns:|;",
                            \           "colmc": "column-count:|;",
                            \           "colmf": "column-fill:|;",
                            \           "colmg": "column-gap:|;",
                            \           "colmr": "column-rule:|;",
                            \           "colmrc": "column-rule-color:|;",
                            \           "colmrs": "column-rule-style:|;",
                            \           "colmrw": "column-rule-width:|;",
                            \           "colms": "column-span:|;",
                            \           "colmw": "column-width:|;",
                            \           "d": "display:${1:block};",
                            \           "d:n": "display:none;",
                            \           "d:b": "display:block;",
                            \           "d:f": "display:flex;",
                            \           "d:if": "display:inline-flex;",
                            \           "d:i": "display:inline;",
                            \           "d:ib": "display:inline-block;",
                            \           "d:ib+": "display: inline-block;\n*display: inline;\n*zoom: 1;",
                            \           "d:li": "display:list-item;",
                            \           "d:ri": "display:run-in;",
                            \           "d:cp": "display:compact;",
                            \           "d:tb": "display:table;",
                            \           "d:itb": "display:inline-table;",
                            \           "d:tbcp": "display:table-caption;",
                            \           "d:tbcl": "display:table-column;",
                            \           "d:tbclg": "display:table-column-group;",
                            \           "d:tbhg": "display:table-header-group;",
                            \           "d:tbfg": "display:table-footer-group;",
                            \           "d:tbr": "display:table-row;",
                            \           "d:tbrg": "display:table-row-group;",
                            \           "d:tbc": "display:table-cell;",
                            \           "d:rb": "display:ruby;",
                            \           "d:rbb": "display:ruby-base;",
                            \           "d:rbbg": "display:ruby-base-group;",
                            \           "d:rbt": "display:ruby-text;",
                            \           "d:rbtg": "display:ruby-text-group;",
                            \           "v": "visibility:${1:hidden};",
                            \           "v:v": "visibility:visible;",
                            \           "v:h": "visibility:hidden;",
                            \           "v:c": "visibility:collapse;",
                            \           "ov": "overflow:${1:hidden};",
                            \           "ov:v": "overflow:visible;",
                            \           "ov:h": "overflow:hidden;",
                            \           "ov:s": "overflow:scroll;",
                            \           "ov:a": "overflow:auto;",
                            \           "ovx": "overflow-x:${1:hidden};",
                            \           "ovx:v": "overflow-x:visible;",
                            \           "ovx:h": "overflow-x:hidden;",
                            \           "ovx:s": "overflow-x:scroll;",
                            \           "ovx:a": "overflow-x:auto;",
                            \           "ovy": "overflow-y:${1:hidden};",
                            \           "ovy:v": "overflow-y:visible;",
                            \           "ovy:h": "overflow-y:hidden;",
                            \           "ovy:s": "overflow-y:scroll;",
                            \           "ovy:a": "overflow-y:auto;",
                            \           "ovs": "overflow-style:${1:scrollbar};",
                            \           "ovs:a": "overflow-style:auto;",
                            \           "ovs:s": "overflow-style:scrollbar;",
                            \           "ovs:p": "overflow-style:panner;",
                            \           "ovs:m": "overflow-style:move;",
                            \           "ovs:mq": "overflow-style:marquee;",
                            \           "zoo": "zoom:1;",
                            \           "zm": "zoom:1;",
                            \           "cp": "clip:|;",
                            \           "cp:a": "clip:auto;",
                            \           "cp:r": "clip:rect(${1:top} ${2:right} ${3:bottom} ${4:left});",
                            \           "bxz": "box-sizing:${1:border-box};",
                            \           "bxz:cb": "box-sizing:content-box;",
                            \           "bxz:bb": "box-sizing:border-box;",
                            \           "bxsh": "box-shadow:${1:inset }${2:hoff} ${3:voff} ${4:blur} ${5:color};",
                            \           "bxsh:r": "box-shadow:${1:inset }${2:hoff} ${3:voff} ${4:blur} ${5:spread }rgb(${6:0}, ${7:0}, ${8:0});",
                            \           "bxsh:ra": "box-shadow:${1:inset }${2:h} ${3:v} ${4:blur} ${5:spread }rgba(${6:0}, ${7:0}, ${8:0}, .${9:5});",
                            \           "bxsh:n": "box-shadow:none;",
                            \           "m": "margin:|;",
                            \           "m:a": "margin:auto;",
                            \           "mt": "margin-top:|;",
                            \           "mt:a": "margin-top:auto;",
                            \           "mr": "margin-right:|;",
                            \           "mr:a": "margin-right:auto;",
                            \           "mb": "margin-bottom:|;",
                            \           "mb:a": "margin-bottom:auto;",
                            \           "ml": "margin-left:|;",
                            \           "ml:a": "margin-left:auto;",
                            \           "p": "padding:|;",
                            \           "pt": "padding-top:|;",
                            \           "pr": "padding-right:|;",
                            \           "pb": "padding-bottom:|;",
                            \           "pl": "padding-left:|;",
                            \           "w": "width:|;",
                            \           "w:a": "width:auto;",
                            \           "h": "height:|;",
                            \           "h:a": "height:auto;",
                            \           "maw": "max-width:|;",
                            \           "maw:n": "max-width:none;",
                            \           "mah": "max-height:|;",
                            \           "mah:n": "max-height:none;",
                            \           "miw": "min-width:|;",
                            \           "mih": "min-height:|;",
                            \           "mar": "max-resolution:${1:res};",
                            \           "mir": "min-resolution:${1:res};",
                            \           "ori": "orientation:|;",
                            \           "ori:l": "orientation:landscape;",
                            \           "ori:p": "orientation:portrait;",
                            \           "ol": "outline:|;",
                            \           "ol:n": "outline:none;",
                            \           "olo": "outline-offset:|;",
                            \           "olw": "outline-width:|;",
                            \           "olw:tn": "outline-width:thin;",
                            \           "olw:m": "outline-width:medium;",
                            \           "olw:tc": "outline-width:thick;",
                            \           "ols": "outline-style:|;",
                            \           "ols:n": "outline-style:none;",
                            \           "ols:dt": "outline-style:dotted;",
                            \           "ols:ds": "outline-style:dashed;",
                            \           "ols:s": "outline-style:solid;",
                            \           "ols:db": "outline-style:double;",
                            \           "ols:g": "outline-style:groove;",
                            \           "ols:r": "outline-style:ridge;",
                            \           "ols:i": "outline-style:inset;",
                            \           "ols:o": "outline-style:outset;",
                            \           "olc": "outline-color:#${1:000};",
                            \           "olc:i": "outline-color:invert;",
                            \           "bfv": "backface-visibility:|;",
                            \           "bfv:h": "backface-visibility:hidden;",
                            \           "bfv:v": "backface-visibility:visible;",
                            \           "bd": "border:|;",
                            \           "bd+": "border:${1:1px} ${2:solid} ${3:#000};",
                            \           "bd:n": "border:none;",
                            \           "bdbk": "border-break:${1:close};",
                            \           "bdbk:c": "border-break:close;",
                            \           "bdcl": "border-collapse:|;",
                            \           "bdcl:c": "border-collapse:collapse;",
                            \           "bdcl:s": "border-collapse:separate;",
                            \           "bdc": "border-color:#${1:000};",
                            \           "bdc:t": "border-color:transparent;",
                            \           "bdi": "border-image:url(|);",
                            \           "bdi:n": "border-image:none;",
                            \           "bdti": "border-top-image:url(|);",
                            \           "bdti:n": "border-top-image:none;",
                            \           "bdri": "border-right-image:url(|);",
                            \           "bdri:n": "border-right-image:none;",
                            \           "bdbi": "border-bottom-image:url(|);",
                            \           "bdbi:n": "border-bottom-image:none;",
                            \           "bdli": "border-left-image:url(|);",
                            \           "bdli:n": "border-left-image:none;",
                            \           "bdci": "border-corner-image:url(|);",
                            \           "bdci:n": "border-corner-image:none;",
                            \           "bdci:c": "border-corner-image:continue;",
                            \           "bdtli": "border-top-left-image:url(|);",
                            \           "bdtli:n": "border-top-left-image:none;",
                            \           "bdtli:c": "border-top-left-image:continue;",
                            \           "bdtri": "border-top-right-image:url(|);",
                            \           "bdtri:n": "border-top-right-image:none;",
                            \           "bdtri:c": "border-top-right-image:continue;",
                            \           "bdbri": "border-bottom-right-image:url(|);",
                            \           "bdbri:n": "border-bottom-right-image:none;",
                            \           "bdbri:c": "border-bottom-right-image:continue;",
                            \           "bdbli": "border-bottom-left-image:url(|);",
                            \           "bdbli:n": "border-bottom-left-image:none;",
                            \           "bdbli:c": "border-bottom-left-image:continue;",
                            \           "bdf": "border-fit:${1:repeat};",
                            \           "bdf:c": "border-fit:clip;",
                            \           "bdf:r": "border-fit:repeat;",
                            \           "bdf:sc": "border-fit:scale;",
                            \           "bdf:st": "border-fit:stretch;",
                            \           "bdf:ow": "border-fit:overwrite;",
                            \           "bdf:of": "border-fit:overflow;",
                            \           "bdf:sp": "border-fit:space;",
                            \           "bdlen": "border-length:|;",
                            \           "bdlen:a": "border-length:auto;",
                            \           "bdsp": "border-spacing:|;",
                            \           "bds": "border-style:|;",
                            \           "bds:n": "border-style:none;",
                            \           "bds:h": "border-style:hidden;",
                            \           "bds:dt": "border-style:dotted;",
                            \           "bds:ds": "border-style:dashed;",
                            \           "bds:s": "border-style:solid;",
                            \           "bds:db": "border-style:double;",
                            \           "bds:dtds": "border-style:dot-dash;",
                            \           "bds:dtdtds": "border-style:dot-dot-dash;",
                            \           "bds:w": "border-style:wave;",
                            \           "bds:g": "border-style:groove;",
                            \           "bds:r": "border-style:ridge;",
                            \           "bds:i": "border-style:inset;",
                            \           "bds:o": "border-style:outset;",
                            \           "bdw": "border-width:|;",
                            \           "bdtw": "border-top-width:|;",
                            \           "bdrw": "border-right-width:|;",
                            \           "bdbw": "border-bottom-width:|;",
                            \           "bdlw": "border-left-width:|;",
                            \           "bdt": "border-top:|;",
                            \           "bt": "border-top:|;",
                            \           "bdt+": "border-top:${1:1px} ${2:solid} ${3:#000};",
                            \           "bdt:n": "border-top:none;",
                            \           "bdts": "border-top-style:|;",
                            \           "bdts:n": "border-top-style:none;",
                            \           "bdtc": "border-top-color:#${1:000};",
                            \           "bdtc:t": "border-top-color:transparent;",
                            \           "bdr": "border-right:|;",
                            \           "br": "border-right:|;",
                            \           "bdr+": "border-right:${1:1px} ${2:solid} ${3:#000};",
                            \           "bdr:n": "border-right:none;",
                            \           "bdrst": "border-right-style:|;",
                            \           "bdrst:n": "border-right-style:none;",
                            \           "bdrc": "border-right-color:#${1:000};",
                            \           "bdrc:t": "border-right-color:transparent;",
                            \           "bdb": "border-bottom:|;",
                            \           "bb": "border-bottom:|;",
                            \           "bdb+": "border-bottom:${1:1px} ${2:solid} ${3:#000};",
                            \           "bdb:n": "border-bottom:none;",
                            \           "bdbs": "border-bottom-style:|;",
                            \           "bdbs:n": "border-bottom-style:none;",
                            \           "bdbc": "border-bottom-color:#${1:000};",
                            \           "bdbc:t": "border-bottom-color:transparent;",
                            \           "bdl": "border-left:|;",
                            \           "bl": "border-left:|;",
                            \           "bdl+": "border-left:${1:1px} ${2:solid} ${3:#000};",
                            \           "bdl:n": "border-left:none;",
                            \           "bdls": "border-left-style:|;",
                            \           "bdls:n": "border-left-style:none;",
                            \           "bdlc": "border-left-color:#${1:000};",
                            \           "bdlc:t": "border-left-color:transparent;",
                            \           "bdrs": "border-radius:|;",
                            \           "bdtrrs": "border-top-right-radius:|;",
                            \           "bdtlrs": "border-top-left-radius:|;",
                            \           "bdbrrs": "border-bottom-right-radius:|;",
                            \           "bdblrs": "border-bottom-left-radius:|;",
                            \           "bg": "background:#${1:000};",
                            \           "bg+": "background:${1:#fff} url(${2}) ${3:0} ${4:0} ${5:no-repeat};",
                            \           "bg:n": "background:none;",
                            \           "bg:ie": "filter:progid:DXImageTransform.Microsoft.AlphaImageLoader(src='${1:x}.png',sizingMethod='${2:crop}');",
                            \           "bgc": "background-color:#${1:fff};",
                            \           "bgc:t": "background-color:transparent;",
                            \           "bgi": "background-image:url(|);",
                            \           "bgi:n": "background-image:none;",
                            \           "bgr": "background-repeat:|;",
                            \           "bgr:n": "background-repeat:no-repeat;",
                            \           "bgr:x": "background-repeat:repeat-x;",
                            \           "bgr:y": "background-repeat:repeat-y;",
                            \           "bgr:sp": "background-repeat:space;",
                            \           "bgr:rd": "background-repeat:round;",
                            \           "bga": "background-attachment:|;",
                            \           "bga:f": "background-attachment:fixed;",
                            \           "bga:s": "background-attachment:scroll;",
                            \           "bgp": "background-position:${1:0} ${2:0};",
                            \           "bgpx": "background-position-x:|;",
                            \           "bgpy": "background-position-y:|;",
                            \           "bgbk": "background-break:|;",
                            \           "bgbk:bb": "background-break:bounding-box;",
                            \           "bgbk:eb": "background-break:each-box;",
                            \           "bgbk:c": "background-break:continuous;",
                            \           "bgcp": "background-clip:${1:padding-box};",
                            \           "bgcp:bb": "background-clip:border-box;",
                            \           "bgcp:pb": "background-clip:padding-box;",
                            \           "bgcp:cb": "background-clip:content-box;",
                            \           "bgcp:nc": "background-clip:no-clip;",
                            \           "bgo": "background-origin:|;",
                            \           "bgo:pb": "background-origin:padding-box;",
                            \           "bgo:bb": "background-origin:border-box;",
                            \           "bgo:cb": "background-origin:content-box;",
                            \           "bgsz": "background-size:|;",
                            \           "bgsz:a": "background-size:auto;",
                            \           "bgsz:ct": "background-size:contain;",
                            \           "bgsz:cv": "background-size:cover;",
                            \           "c": "color:#${1:000};",
                            \           "c:r": "color:rgb(${1:0}, ${2:0}, ${3:0});",
                            \           "c:ra": "color:rgba(${1:0}, ${2:0}, ${3:0}, .${4:5});",
                            \           "cm": "/* |${child} */",
                            \           "cnt": "content:'|';",
                            \           "cnt:n": "content:normal;",
                            \           "cnt:oq": "content:open-quote;",
                            \           "cnt:noq": "content:no-open-quote;",
                            \           "cnt:cq": "content:close-quote;",
                            \           "cnt:ncq": "content:no-close-quote;",
                            \           "cnt:a": "content:attr(|);",
                            \           "cnt:c": "content:counter(|);",
                            \           "cnt:cs": "content:counters(|);",
                            \           "tbl": "table-layout:|;",
                            \           "tbl:a": "table-layout:auto;",
                            \           "tbl:f": "table-layout:fixed;",
                            \           "cps": "caption-side:|;",
                            \           "cps:t": "caption-side:top;",
                            \           "cps:b": "caption-side:bottom;",
                            \           "ec": "empty-cells:|;",
                            \           "ec:s": "empty-cells:show;",
                            \           "ec:h": "empty-cells:hide;",
                            \           "lis": "list-style:|;",
                            \           "lis:n": "list-style:none;",
                            \           "lisp": "list-style-position:|;",
                            \           "lisp:i": "list-style-position:inside;",
                            \           "lisp:o": "list-style-position:outside;",
                            \           "list": "list-style-type:|;",
                            \           "list:n": "list-style-type:none;",
                            \           "list:d": "list-style-type:disc;",
                            \           "list:c": "list-style-type:circle;",
                            \           "list:s": "list-style-type:square;",
                            \           "list:dc": "list-style-type:decimal;",
                            \           "list:dclz": "list-style-type:decimal-leading-zero;",
                            \           "list:lr": "list-style-type:lower-roman;",
                            \           "list:ur": "list-style-type:upper-roman;",
                            \           "lisi": "list-style-image:|;",
                            \           "lisi:n": "list-style-image:none;",
                            \           "q": "quotes:|;",
                            \           "q:n": "quotes:none;",
                            \           "q:ru": "quotes:'\\00AB' '\\00BB' '\\201E' '\\201C';",
                            \           "q:en": "quotes:'\\201C' '\\201D' '\\2018' '\\2019';",
                            \           "ct": "content:|;",
                            \           "ct:n": "content:normal;",
                            \           "ct:oq": "content:open-quote;",
                            \           "ct:noq": "content:no-open-quote;",
                            \           "ct:cq": "content:close-quote;",
                            \           "ct:ncq": "content:no-close-quote;",
                            \           "ct:a": "content:attr(|);",
                            \           "ct:c": "content:counter(|);",
                            \           "ct:cs": "content:counters(|);",
                            \           "coi": "counter-increment:|;",
                            \           "cor": "counter-reset:|;",
                            \           "va": "vertical-align:${1:top};",
                            \           "va:sup": "vertical-align:super;",
                            \           "va:t": "vertical-align:top;",
                            \           "va:tt": "vertical-align:text-top;",
                            \           "va:m": "vertical-align:middle;",
                            \           "va:bl": "vertical-align:baseline;",
                            \           "va:b": "vertical-align:bottom;",
                            \           "va:tb": "vertical-align:text-bottom;",
                            \           "va:sub": "vertical-align:sub;",
                            \           "ta": "text-align:${1:left};",
                            \           "ta:l": "text-align:left;",
                            \           "ta:c": "text-align:center;",
                            \           "ta:r": "text-align:right;",
                            \           "ta:j": "text-align:justify;",
                            \           "ta-lst": "text-align-last:|;",
                            \           "tal:a": "text-align-last:auto;",
                            \           "tal:l": "text-align-last:left;",
                            \           "tal:c": "text-align-last:center;",
                            \           "tal:r": "text-align-last:right;",
                            \           "td": "text-decoration:${1:none};",
                            \           "td:n": "text-decoration:none;",
                            \           "td:u": "text-decoration:underline;",
                            \           "td:o": "text-decoration:overline;",
                            \           "td:l": "text-decoration:line-through;",
                            \           "te": "text-emphasis:|;",
                            \           "te:n": "text-emphasis:none;",
                            \           "te:ac": "text-emphasis:accent;",
                            \           "te:dt": "text-emphasis:dot;",
                            \           "te:c": "text-emphasis:circle;",
                            \           "te:ds": "text-emphasis:disc;",
                            \           "te:b": "text-emphasis:before;",
                            \           "te:a": "text-emphasis:after;",
                            \           "th": "text-height:|;",
                            \           "th:a": "text-height:auto;",
                            \           "th:f": "text-height:font-size;",
                            \           "th:t": "text-height:text-size;",
                            \           "th:m": "text-height:max-size;",
                            \           "ti": "text-indent:|;",
                            \           "ti:-": "text-indent:-9999px;",
                            \           "tj": "text-justify:|;",
                            \           "tj:a": "text-justify:auto;",
                            \           "tj:iw": "text-justify:inter-word;",
                            \           "tj:ii": "text-justify:inter-ideograph;",
                            \           "tj:ic": "text-justify:inter-cluster;",
                            \           "tj:d": "text-justify:distribute;",
                            \           "tj:k": "text-justify:kashida;",
                            \           "tj:t": "text-justify:tibetan;",
                            \           "tov": "text-overflow:${ellipsis};",
                            \           "tov:e": "text-overflow:ellipsis;",
                            \           "tov:c": "text-overflow:clip;",
                            \           "to": "text-outline:|;",
                            \           "to+": "text-outline:${1:0} ${2:0} ${3:#000};",
                            \           "to:n": "text-outline:none;",
                            \           "tr": "text-replace:|;",
                            \           "tr:n": "text-replace:none;",
                            \           "tt": "text-transform:${1:uppercase};",
                            \           "tt:n": "text-transform:none;",
                            \           "tt:c": "text-transform:capitalize;",
                            \           "tt:u": "text-transform:uppercase;",
                            \           "tt:l": "text-transform:lowercase;",
                            \           "tw": "text-wrap:|;",
                            \           "tw:n": "text-wrap:normal;",
                            \           "tw:no": "text-wrap:none;",
                            \           "tw:u": "text-wrap:unrestricted;",
                            \           "tw:s": "text-wrap:suppress;",
                            \           "tsh": "text-shadow:${1:hoff} ${2:voff} ${3:blur} ${4:#000};",
                            \           "tsh:r": "text-shadow:${1:h} ${2:v} ${3:blur} rgb(${4:0}, ${5:0}, ${6:0});",
                            \           "tsh:ra": "text-shadow:${1:h} ${2:v} ${3:blur} rgba(${4:0}, ${5:0}, ${6:0}, .${7:5});",
                            \           "tsh+": "text-shadow:${1:0} ${2:0} ${3:0} ${4:#000};",
                            \           "tsh:n": "text-shadow:none;",
                            \           "trf": "transform:|;",
                            \           "trf:skx": "transform: skewX(${1:angle});",
                            \           "trf:sky": "transform: skewY(${1:angle});",
                            \           "trf:sc": "transform: scale(${1:x}, ${2:y});",
                            \           "trf:scx": "transform: scaleX(${1:x});",
                            \           "trf:scy": "transform: scaleY(${1:y});",
                            \           "trf:scz": "transform: scaleZ(${1:z});",
                            \           "trf:sc3": "transform: scale3d(${1:x}, ${2:y}, ${3:z});",
                            \           "trf:r": "transform: rotate(${1:angle});",
                            \           "trf:rx": "transform: rotateX(${1:angle});",
                            \           "trf:ry": "transform: rotateY(${1:angle});",
                            \           "trf:rz": "transform: rotateZ(${1:angle});",
                            \           "trf:t": "transform: translate(${1:x}, ${2:y});",
                            \           "trf:tx": "transform: translateX(${1:x});",
                            \           "trf:ty": "transform: translateY(${1:y});",
                            \           "trf:tz": "transform: translateZ(${1:z});",
                            \           "trf:t3": "transform: translate3d(${1:tx}, ${2:ty}, ${3:tz});",
                            \           "trfo": "transform-origin:|;",
                            \           "trfs": "transform-style:${1:preserve-3d};",
                            \           "trs": "transition:${1:prop} ${2:time};",
                            \           "trsde": "transition-delay:${1:time};",
                            \           "trsdu": "transition-duration:${1:time};",
                            \           "trsp": "transition-property:${1:prop};",
                            \           "trstf": "transition-timing-function:${1:tfunc};",
                            \           "lh": "line-height:|;",
                            \           "whs": "white-space:|;",
                            \           "whs:n": "white-space:normal;",
                            \           "whs:p": "white-space:pre;",
                            \           "whs:nw": "white-space:nowrap;",
                            \           "whs:pw": "white-space:pre-wrap;",
                            \           "whs:pl": "white-space:pre-line;",
                            \           "whsc": "white-space-collapse:|;",
                            \           "whsc:n": "white-space-collapse:normal;",
                            \           "whsc:k": "white-space-collapse:keep-all;",
                            \           "whsc:l": "white-space-collapse:loose;",
                            \           "whsc:bs": "white-space-collapse:break-strict;",
                            \           "whsc:ba": "white-space-collapse:break-all;",
                            \           "wob": "word-break:|;",
                            \           "wob:n": "word-break:normal;",
                            \           "wob:k": "word-break:keep-all;",
                            \           "wob:ba": "word-break:break-all;",
                            \           "wos": "word-spacing:|;",
                            \           "wow": "word-wrap:|;",
                            \           "wow:nm": "word-wrap:normal;",
                            \           "wow:n": "word-wrap:none;",
                            \           "wow:u": "word-wrap:unrestricted;",
                            \           "wow:s": "word-wrap:suppress;",
                            \           "wow:b": "word-wrap:break-word;",
                            \           "wm": "writing-mode:${1:lr-tb};",
                            \           "wm:lrt": "writing-mode:lr-tb;",
                            \           "wm:lrb": "writing-mode:lr-bt;",
                            \           "wm:rlt": "writing-mode:rl-tb;",
                            \           "wm:rlb": "writing-mode:rl-bt;",
                            \           "wm:tbr": "writing-mode:tb-rl;",
                            \           "wm:tbl": "writing-mode:tb-lr;",
                            \           "wm:btl": "writing-mode:bt-lr;",
                            \           "wm:btr": "writing-mode:bt-rl;",
                            \           "lts": "letter-spacing:|;",
                            \           "lts-n": "letter-spacing:normal;",
                            \           "f": "font:|;",
                            \           "f+": "font:${1:1em} ${2:Arial,sans-serif};",
                            \           "fw": "font-weight:|;",
                            \           "fw:n": "font-weight:normal;",
                            \           "fw:b": "font-weight:bold;",
                            \           "fw:br": "font-weight:bolder;",
                            \           "fw:lr": "font-weight:lighter;",
                            \           "fs": "font-style:${italic};",
                            \           "fs:n": "font-style:normal;",
                            \           "fs:i": "font-style:italic;",
                            \           "fs:o": "font-style:oblique;",
                            \           "fv": "font-variant:|;",
                            \           "fv:n": "font-variant:normal;",
                            \           "fv:sc": "font-variant:small-caps;",
                            \           "fz": "font-size:|;",
                            \           "fza": "font-size-adjust:|;",
                            \           "fza:n": "font-size-adjust:none;",
                            \           "ff": "font-family:|;",
                            \           "ff:s": "font-family:serif;",
                            \           "ff:ss": "font-family:sans-serif;",
                            \           "ff:c": "font-family:cursive;",
                            \           "ff:f": "font-family:fantasy;",
                            \           "ff:m": "font-family:monospace;",
                            \           "ff:a": "font-family: Arial, \"Helvetica Neue\", Helvetica, sans-serif;",
                            \           "ff:t": "font-family: \"Times New Roman\", Times, Baskerville, Georgia, serif;",
                            \           "ff:v": "font-family: Verdana, Geneva, sans-serif;",
                            \           "fef": "font-effect:|;",
                            \           "fef:n": "font-effect:none;",
                            \           "fef:eg": "font-effect:engrave;",
                            \           "fef:eb": "font-effect:emboss;",
                            \           "fef:o": "font-effect:outline;",
                            \           "fem": "font-emphasize:|;",
                            \           "femp": "font-emphasize-position:|;",
                            \           "femp:b": "font-emphasize-position:before;",
                            \           "femp:a": "font-emphasize-position:after;",
                            \           "fems": "font-emphasize-style:|;",
                            \           "fems:n": "font-emphasize-style:none;",
                            \           "fems:ac": "font-emphasize-style:accent;",
                            \           "fems:dt": "font-emphasize-style:dot;",
                            \           "fems:c": "font-emphasize-style:circle;",
                            \           "fems:ds": "font-emphasize-style:disc;",
                            \           "fsm": "font-smooth:|;",
                            \           "fsm:a": "font-smooth:auto;",
                            \           "fsm:n": "font-smooth:never;",
                            \           "fsm:aw": "font-smooth:always;",
                            \           "fst": "font-stretch:|;",
                            \           "fst:n": "font-stretch:normal;",
                            \           "fst:uc": "font-stretch:ultra-condensed;",
                            \           "fst:ec": "font-stretch:extra-condensed;",
                            \           "fst:c": "font-stretch:condensed;",
                            \           "fst:sc": "font-stretch:semi-condensed;",
                            \           "fst:se": "font-stretch:semi-expanded;",
                            \           "fst:e": "font-stretch:expanded;",
                            \           "fst:ee": "font-stretch:extra-expanded;",
                            \           "fst:ue": "font-stretch:ultra-expanded;",
                            \           "op": "opacity:|;",
                            \           "op+": "opacity: $1;\nfilter: alpha(opacity=$2);",
                            \           "op:ie": "filter:progid:DXImageTransform.Microsoft.Alpha(Opacity=100);",
                            \           "op:ms": "-ms-filter:'progid:DXImageTransform.Microsoft.Alpha(Opacity=100)';",
                            \           "rsz": "resize:|;",
                            \           "rsz:n": "resize:none;",
                            \           "rsz:b": "resize:both;",
                            \           "rsz:h": "resize:horizontal;",
                            \           "rsz:v": "resize:vertical;",
                            \           "cur": "cursor:${pointer};",
                            \           "cur:a": "cursor:auto;",
                            \           "cur:d": "cursor:default;",
                            \           "cur:c": "cursor:crosshair;",
                            \           "cur:ha": "cursor:hand;",
                            \           "cur:he": "cursor:help;",
                            \           "cur:m": "cursor:move;",
                            \           "cur:p": "cursor:pointer;",
                            \           "cur:t": "cursor:text;",
                            \           "fxd": "flex-direction:|;",
                            \           "fxd:r": "flex-direction:row;",
                            \           "fxd:rr": "flex-direction:row-reverse;",
                            \           "fxd:c": "flex-direction:column;",
                            \           "fxd:cr": "flex-direction:column-reverse;",
                            \           "fxw": "flex-wrap: |;",
                            \           "fxw:n": "flex-wrap:nowrap;",
                            \           "fxw:w": "flex-wrap:wrap;",
                            \           "fxw:wr": "flex-wrap:wrap-reverse;",
                            \           "fxf": "flex-flow:|;",
                            \           "jc": "justify-content:|;",
                            \           "jc:fs": "justify-content:flex-start;",
                            \           "jc:fe": "justify-content:flex-end;",
                            \           "jc:c": "justify-content:center;",
                            \           "jc:sb": "justify-content:space-between;",
                            \           "jc:sa": "justify-content:space-around;",
                            \           "ai": "align-items:|;",
                            \           "ai:fs": "align-items:flex-start;",
                            \           "ai:fe": "align-items:flex-end;",
                            \           "ai:c": "align-items:center;",
                            \           "ai:b": "align-items:baseline;",
                            \           "ai:s": "align-items:stretch;",
                            \           "ac": "align-content:|;",
                            \           "ac:fs": "align-content:flex-start;",
                            \           "ac:fe": "align-content:flex-end;",
                            \           "ac:c": "align-content:center;",
                            \           "ac:sb": "align-content:space-between;",
                            \           "ac:sa": "align-content:space-around;",
                            \           "ac:s": "align-content:stretch;",
                            \           "ord": "order:|;",
                            \           "fxg": "flex-grow:|;",
                            \           "fxsh": "flex-shrink:|;",
                            \           "fxb": "flex-basis:|;",
                            \           "fx": "flex:|;",
                            \           "as": "align-self:|;",
                            \           "as:a": "align-self:auto;",
                            \           "as:fs": "align-self:flex-start;",
                            \           "as:fe": "align-self:flex-end;",
                            \           "as:c": "align-self:center;",
                            \           "as:b": "align-self:baseline;",
                            \           "as:s": "align-self:stretch;",
                            \           "pgbb": "page-break-before:|;",
                            \           "pgbb:au": "page-break-before:auto;",
                            \           "pgbb:al": "page-break-before:always;",
                            \           "pgbb:l": "page-break-before:left;",
                            \           "pgbb:r": "page-break-before:right;",
                            \           "pgbi": "page-break-inside:|;",
                            \           "pgbi:au": "page-break-inside:auto;",
                            \           "pgbi:av": "page-break-inside:avoid;",
                            \           "pgba": "page-break-after:|;",
                            \           "pgba:au": "page-break-after:auto;",
                            \           "pgba:al": "page-break-after:always;",
                            \           "pgba:l": "page-break-after:left;",
                            \           "pgba:r": "page-break-after:right;",
                            \           "orp": "orphans:|;",
                            \           "us": "user-select:${none};",
                            \           "wid": "widows:|;",
                            \           "wfsm": "-webkit-font-smoothing:${antialiased};",
                            \           "wfsm:a": "-webkit-font-smoothing:antialiased;",
                            \           "wfsm:s": "-webkit-font-smoothing:subpixel-antialiased;",
                            \           "wfsm:sa": "-webkit-font-smoothing:subpixel-antialiased;",
                            \           "wfsm:n": "-webkit-font-smoothing:none;"
                            \        },
                            \        'filters': 'fc',
                            \    },
                            \    'sass': {
                            \        'extends': 'css',
                            \        'snippets': {
                            \            '@if': "@if {\n\t|\n}",
                            \            '@e': "@else {\n\t|\n}",
                            \            '@in': "@include |",
                            \            '@ex': "@extend |",
                            \            '@mx': "@mixin {\n\t|\n}",
                            \            '@fn': "@function {\n\t|\n}",
                            \            '@r': "@return |",
                            \        },
                            \    },
                            \    'scss': {
                            \        'extends': 'css',
                            \    },
                            \    'less': {
                            \        'extends': 'css',
                            \    },
                            \    'css.drupal': {
                            \        'extends': 'css',
                            \    },
                            \    'html': {
                            \        'snippets': {
                            \            '!': "html:5",
                            \            '!!!': "<!DOCTYPE html>\n",
                            \            '!!!4t':  "<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\">\n",
                            \            '!!!4s':  "<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01//EN\" \"http://www.w3.org/TR/html4/strict.dtd\">\n",
                            \            '!!!xt':  "<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\">\n",
                            \            '!!!xs':  "<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Strict//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd\">\n",
                            \            '!!!xxs': "<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.1//EN\" \"http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd\">\n",
                            \            'c': "<!-- |${child} -->",
                            \            'cc:ie6': "<!--[if lte IE 6]>\n\t${child}|\n<![endif]-->",
                            \            'cc:ie': "<!--[if IE]>\n\t${child}|\n<![endif]-->",
                            \            'cc:noie': "<!--[if !IE]><!-->\n\t${child}|\n<!--<![endif]-->",
                            \            'html:4t': "<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\">\n"
                            \                    ."<html lang=\"${lang}\">\n"
                            \                    ."<head>\n"
                            \                    ."\t<meta http-equiv=\"Content-Type\" content=\"text/html;charset=${charset}\">\n"
                            \                    ."\t<title></title>\n"
                            \                    ."</head>\n"
                            \                    ."<body>\n\t${child}|\n</body>\n"
                            \                    ."</html>",
                            \            'html:4s': "<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01//EN\" \"http://www.w3.org/TR/html4/strict.dtd\">\n"
                            \                    ."<html lang=\"${lang}\">\n"
                            \                    ."<head>\n"
                            \                    ."\t<meta http-equiv=\"Content-Type\" content=\"text/html;charset=${charset}\">\n"
                            \                    ."\t<title></title>\n"
                            \                    ."</head>\n"
                            \                    ."<body>\n\t${child}|\n</body>\n"
                            \                    ."</html>",
                            \            'html:xt': "<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\">\n"
                            \                    ."<html xmlns=\"http://www.w3.org/1999/xhtml\" xml:lang=\"${lang}\">\n"
                            \                    ."<head>\n"
                            \                    ."\t<meta http-equiv=\"Content-Type\" content=\"text/html;charset=${charset}\" />\n"
                            \                    ."\t<title></title>\n"
                            \                    ."</head>\n"
                            \                    ."<body>\n\t${child}|\n</body>\n"
                            \                    ."</html>",
                            \            'html:xs': "<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Strict//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd\">\n"
                            \                    ."<html xmlns=\"http://www.w3.org/1999/xhtml\" xml:lang=\"${lang}\">\n"
                            \                    ."<head>\n"
                            \                    ."\t<meta http-equiv=\"Content-Type\" content=\"text/html;charset=${charset}\" />\n"
                            \                    ."\t<title></title>\n"
                            \                    ."</head>\n"
                            \                    ."<body>\n\t${child}|\n</body>\n"
                            \                    ."</html>",
                            \            'html:xxs': "<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.1//EN\" \"http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd\">\n"
                            \                    ."<html xmlns=\"http://www.w3.org/1999/xhtml\" xml:lang=\"${lang}\">\n"
                            \                    ."<head>\n"
                            \                    ."\t<meta http-equiv=\"Content-Type\" content=\"text/html;charset=${charset}\" />\n"
                            \                    ."\t<title></title>\n"
                            \                    ."</head>\n"
                            \                    ."<body>\n\t${child}|\n</body>\n"
                            \                    ."</html>",
                            \            'html:5': "<!DOCTYPE html>\n"
                            \                    ."<html lang=\"${lang}\">\n"
                            \                    ."<head>\n"
                            \                    ."\t<meta charset=\"${charset}\">\n"
                            \                    ."\t<title></title>\n"
                            \                    ."</head>\n"
                            \                    ."<body>\n\t${child}|\n</body>\n"
                            \                    ."</html>",
                            \        },
                            \        'default_attributes': {
                            \            'a': [{'href': ''}],
                            \            'a:link': [{'href': 'http://|'}],
                            \            'a:mail': [{'href': 'mailto:|'}],
                            \            'abbr': [{'title': ''}],
                            \            'acronym': [{'title': ''}],
                            \            'base': [{'href': ''}],
                            \            'bdo': [{'dir': ''}],
                            \            'bdo:r': [{'dir': 'rtl'}],
                            \            'bdo:l': [{'dir': 'ltr'}],
                            \            'del': [{'datetime': '${datetime}'}],
                            \            'ins': [{'datetime': '${datetime}'}],
                            \            'link:css': [{'rel': 'stylesheet'}, g:emmet_html5 ? {} : {'type': 'text/css'}, {'href': '|style.css'}, {'media': 'all'}],
                            \            'link:print': [{'rel': 'stylesheet'}, g:emmet_html5 ? {} : {'type': 'text/css'}, {'href': '|print.css'}, {'media': 'print'}],
                            \            'link:import': [{'rel': 'import'}, {'href': '|.html'}],
                            \            'link:im': [{'rel': 'import'}, {'href': '|.html'}],
                            \            'link:favicon': [{'rel': 'shortcut icon'}, {'type': 'image/x-icon'}, {'href': '|favicon.ico'}],
                            \            'link:touch': [{'rel': 'apple-touch-icon'}, {'href': '|favicon.png'}],
                            \            'link:rss': [{'rel': 'alternate'}, {'type': 'application/rss+xml'}, {'title': 'RSS'}, {'href': '|rss.xml'}],
                            \            'link:atom': [{'rel': 'alternate'}, {'type': 'application/atom+xml'}, {'title': 'Atom'}, {'href': 'atom.xml'}],
                            \            'meta:utf': [{'http-equiv': 'Content-Type'}, {'content': 'text/html;charset=UTF-8'}],
                            \            'meta:vp': [{'name': 'viewport'}, {'content': 'width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0'}],
                            \            'meta:win': [{'http-equiv': 'Content-Type'}, {'content': 'text/html;charset=Win-1251'}],
                            \            'meta:compat': [{'http-equiv': 'X-UA-Compatible'}, {'content': 'IE=7'}],
                            \            'style': g:emmet_html5 ? [] : [{'type': 'text/css'}],
                            \            'script': g:emmet_html5 ? [] : [{'type': 'text/javascript'}],
                            \            'script:src': (g:emmet_html5 ? [] : [{'type': 'text/javascript'}]) + [{'src': ''}],
                            \            'img': [{'src': ''}, {'alt': ''}],
                            \            'iframe': [{'src': ''}, {'frameborder': '0'}],
                            \            'embed': [{'src': ''}, {'type': ''}],
                            \            'object': [{'data': ''}, {'type': ''}],
                            \            'param': [{'name': ''}, {'value': ''}],
                            \            'map': {'name': ''},
                            \            'area': [{'shape': ''}, {'coords': ''}, {'href': ''}, {'alt': ''}],
                            \            'area:d': [{'shape': 'default'}, {'href': ''}, {'alt': ''}],
                            \            'area:c': [{'shape': 'circle'}, {'coords': ''}, {'href': ''}, {'alt': ''}],
                            \            'area:r': [{'shape': 'rect'}, {'coords': ''}, {'href': ''}, {'alt': ''}],
                            \            'area:p': [{'shape': 'poly'}, {'coords': ''}, {'href': ''}, {'alt': ''}],
                            \            'link': [{'rel': 'stylesheet'}, {'href': ''}],
                            \            'form': [{'action': ''}],
                            \            'form:get': [{'action': ''}, {'method': 'get'}],
                            \            'form:post': [{'action': ''}, {'method': 'post'}],
                            \            'form:upload': [{'action': ''}, {'method': 'post'}, {'enctype': 'multipart/form-data'}],
                            \            'label': [{'for': ''}],
                            \            'input': [{'type': ''}],
                            \            'input:hidden': [{'type': 'hidden'}, {'name': ''}],
                            \            'input:h': [{'type': 'hidden'}, {'name': ''}],
                            \            'input:text': [{'type': 'text'}, {'name': ''}, {'id': ''}],
                            \            'input:t': [{'type': 'text'}, {'name': ''}, {'id': ''}],
                            \            'input:search': [{'type': 'search'}, {'name': ''}, {'id': ''}],
                            \            'input:email': [{'type': 'email'}, {'name': ''}, {'id': ''}],
                            \            'input:url': [{'type': 'url'}, {'name': ''}, {'id': ''}],
                            \            'input:password': [{'type': 'password'}, {'name': ''}, {'id': ''}],
                            \            'input:p': [{'type': 'password'}, {'name': ''}, {'id': ''}],
                            \            'input:datetime': [{'type': 'datetime'}, {'name': ''}, {'id': ''}],
                            \            'input:date': [{'type': 'date'}, {'name': ''}, {'id': ''}],
                            \            'input:datetime-local': [{'type': 'datetime-local'}, {'name': ''}, {'id': ''}],
                            \            'input:month': [{'type': 'month'}, {'name': ''}, {'id': ''}],
                            \            'input:week': [{'type': 'week'}, {'name': ''}, {'id': ''}],
                            \            'input:time': [{'type': 'time'}, {'name': ''}, {'id': ''}],
                            \            'input:number': [{'type': 'number'}, {'name': ''}, {'id': ''}],
                            \            'input:color': [{'type': 'color'}, {'name': ''}, {'id': ''}],
                            \            'input:checkbox': [{'type': 'checkbox'}, {'name': ''}, {'id': ''}],
                            \            'input:c': [{'type': 'checkbox'}, {'name': ''}, {'id': ''}],
                            \            'input:radio': [{'type': 'radio'}, {'name': ''}, {'id': ''}],
                            \            'input:r': [{'type': 'radio'}, {'name': ''}, {'id': ''}],
                            \            'input:range': [{'type': 'range'}, {'name': ''}, {'id': ''}],
                            \            'input:file': [{'type': 'file'}, {'name': ''}, {'id': ''}],
                            \            'input:f': [{'type': 'file'}, {'name': ''}, {'id': ''}],
                            \            'input:submit': [{'type': 'submit'}, {'value': ''}],
                            \            'input:s': [{'type': 'submit'}, {'value': ''}],
                            \            'input:image': [{'type': 'image'}, {'src': ''}, {'alt': ''}],
                            \            'input:i': [{'type': 'image'}, {'src': ''}, {'alt': ''}],
                            \            'input:reset': [{'type': 'reset'}, {'value': ''}],
                            \            'input:button': [{'type': 'button'}, {'value': ''}],
                            \            'input:b': [{'type': 'button'}, {'value': ''}],
                            \            'select': [{'name': ''}, {'id': ''}],
                            \            'option': [{'value': ''}],
                            \            'textarea': [{'name': ''}, {'id': ''}, {'cols': '30'}, {'rows': '10'}],
                            \            'menu:context': [{'type': 'context'}],
                            \            'menu:c': [{'type': 'context'}],
                            \            'menu:toolbar': [{'type': 'toolbar'}],
                            \            'menu:t': [{'type': 'toolbar'}],
                            \            'video': [{'src': ''}],
                            \            'audio': [{'src': ''}],
                            \            'html:xml': [{'xmlns': 'http://www.w3.org/1999/xhtml'}, {'xml:lang': '${lang}'}],
                            \        },
                            \        'aliases': {
                            \            'link:*': 'link',
                            \            'meta:*': 'meta',
                            \            'area:*': 'area',
                            \            'bdo:*': 'bdo',
                            \            'form:*': 'form',
                            \            'input:*': 'input',
                            \            'script:*': 'script',
                            \            'html:*': 'html',
                            \            'a:*': 'a',
                            \            'menu:*': 'menu',
                            \            'bq': 'blockquote',
                            \            'acr': 'acronym',
                            \            'fig': 'figure',
                            \            'ifr': 'iframe',
                            \            'emb': 'embed',
                            \            'obj': 'object',
                            \            'src': 'source',
                            \            'cap': 'caption',
                            \            'colg': 'colgroup',
                            \            'fst': 'fieldset',
                            \            'btn': 'button',
                            \            'optg': 'optgroup',
                            \            'opt': 'option',
                            \            'tarea': 'textarea',
                            \            'leg': 'legend',
                            \            'sect': 'section',
                            \            'art': 'article',
                            \            'hdr': 'header',
                            \            'ftr': 'footer',
                            \            'adr': 'address',
                            \            'dlg': 'dialog',
                            \            'str': 'strong',
                            \            'sty': 'style',
                            \            'prog': 'progress',
                            \            'fset': 'fieldset',
                            \            'datag': 'datagrid',
                            \            'datal': 'datalist',
                            \            'kg': 'keygen',
                            \            'out': 'output',
                            \            'det': 'details',
                            \            'cmd': 'command',
                            \        },
                            \        'expandos': {
                            \            'ol': 'ol>li',
                            \            'ul': 'ul>li',
                            \            'dl': 'dl>dt+dd',
                            \            'map': 'map>area',
                            \            'table': 'table>tr>td',
                            \            'colgroup': 'colgroup>col',
                            \            'colg': 'colgroup>col',
                            \            'tr': 'tr>td',
                            \            'select': 'select>option',
                            \            'optgroup': 'optgroup>option',
                            \            'optg': 'optgroup>option',
                            \        },
                            \        'empty_elements': 'area,base,basefont,br,col,frame,hr,img,input,isindex,link,meta,param,embed,keygen,command',
                            \        'block_elements': 'address,applet,blockquote,button,center,dd,del,dir,div,dl,dt,fieldset,form,frameset,hr,iframe,ins,isindex,li,link,map,menu,noframes,noscript,object,ol,p,pre,script,table,tbody,td,tfoot,th,thead,tr,ul,h1,h2,h3,h4,h5,h6',
                            \        'inline_elements': 'a,abbr,acronym,applet,b,basefont,bdo,big,br,button,cite,code,del,dfn,em,font,i,iframe,img,input,ins,kbd,label,map,object,q,s,samp,script,small,span,strike,strong,sub,sup,textarea,tt,u,var',
                            \        'empty_element_suffix': g:emmet_html5 ? '>' : ' />',
                            \        'indent_blockelement': 0,
                            \        'block_all_childless': 0,
                            \    },
                            \    'elm': {
                            \        'indentation': '    ',
                            \        'extends': 'html',
                            \    },
                            \    'htmldjango': {
                            \        'extends': 'html',
                            \    },
                            \    'html.django_template': {
                            \        'extends': 'html',
                            \    },
                            \    'jade': {
                            \        'indentation': '  ',
                            \        'extends': 'html',
                            \        'snippets': {
                            \            '!': "html:5",
                            \            '!!!': "doctype html\n",
                            \            '!!!4t': "doctype HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\"\n",
                            \            '!!!4s': "doctype HTML PUBLIC \"-//W3C//DTD HTML 4.01//EN\" \"http://www.w3.org/TR/html4/strict.dtd\"\n",
                            \            '!!!xt': "doctype transitional\n",
                            \            '!!!xs': "doctype strict\n",
                            \            '!!!xxs': "doctype 1.1\n",
                            \            'c': "\/\/ |${child}",
                            \            'html:4t': "doctype HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\"\n"
                            \                    ."html(lang=\"${lang}\")\n"
                            \                    ."\thead\n"
                            \                    ."\t\tmeta(http-equiv=\"Content-Type\", content=\"text/html;charset=${charset}\")\n"
                            \                    ."\t\ttitle\n"
                            \                    ."\tbody\n\t\t${child}|",
                            \            'html:4s': "doctype HTML PUBLIC \"-//W3C//DTD HTML 4.01//EN\" \"http://www.w3.org/TR/html4/strict.dtd\"\n"
                            \                    ."html(lang=\"${lang}\")\n"
                            \                    ."\thead\n"
                            \                    ."\t\tmeta(http-equiv=\"Content-Type\", content=\"text/html;charset=${charset}\")\n"
                            \                    ."\t\ttitle\n"
                            \                    ."\tbody\n\t\t${child}|",
                            \            'html:xt': "doctype transitional\n"
                            \                    ."html(xmlns=\"http://www.w3.org/1999/xhtml\", xml:lang=\"${lang}\")\n"
                            \                    ."\thead\n"
                            \                    ."\t\tmeta(http-equiv=\"Content-Type\", content=\"text/html;charset=${charset}\")\n"
                            \                    ."\t\ttitle\n"
                            \                    ."\tbody\n\t\t${child}|",
                            \            'html:xs': "doctype strict\n"
                            \                    ."html(xmlns=\"http://www.w3.org/1999/xhtml\", xml:lang=\"${lang}\")\n"
                            \                    ."\thead\n"
                            \                    ."\t\tmeta(http-equiv=\"Content-Type\", content=\"text/html;charset=${charset}\")\n"
                            \                    ."\t\ttitle\n"
                            \                    ."\tbody\n\t\t${child}|",
                            \            'html:xxs': "doctype 1.1\n"
                            \                    ."html(xmlns=\"http://www.w3.org/1999/xhtml\", xml:lang=\"${lang}\")\n"
                            \                    ."\thead\n"
                            \                    ."\t\tmeta(http-equiv=\"Content-Type\", content=\"text/html;charset=${charset}\")\n"
                            \                    ."\t\ttitle\n"
                            \                    ."\tbody\n\t\t${child}|",
                            \            'html:5': "doctype html\n"
                            \                    ."html(lang=\"${lang}\")\n"
                            \                    ."\thead\n"
                            \                    ."\t\tmeta(charset=\"${charset}\")\n"
                            \                    ."\t\ttitle\n"
                            \                    ."\tbody\n\t\t${child}|",
                            \        },
                            \    },
                            \    'pug': {
                            \        'extends': 'jade',
                            \    },
                            \    'xsl': {
                            \        'extends': 'html',
                            \        'default_attributes': {
                            \            'tmatch': [{'match': ''}, {'mode': ''}],
                            \            'tname': [{'name': ''}],
                            \            'xsl:when': {'test': ''},
                            \            'var': [{'name': ''}, {'select': ''}],
                            \            'vari': {'name': ''},
                            \            'if': {'test': ''},
                            \            'call': {'name': ''},
                            \            'attr': {'name': ''},
                            \            'wp': [{'name': ''}, {'select': ''}],
                            \            'par': [{'name': ''}, {'select': ''}],
                            \            'val': {'select': ''},
                            \            'co': {'select': ''},
                            \            'each': {'select': ''},
                            \            'ap': [{'select': ''}, {'mode': ''}]
                            \        },
                            \        'aliases': {
                            \            'tmatch': 'xsl:template',
                            \            'tname': 'xsl:template',
                            \            'var': 'xsl:variable',
                            \            'vari': 'xsl:variable',
                            \            'if': 'xsl:if',
                            \            'choose': 'xsl:choose',
                            \            'call': 'xsl:call-template',
                            \            'wp': 'xsl:with-param',
                            \            'par': 'xsl:param',
                            \            'val': 'xsl:value-of',
                            \            'attr': 'xsl:attribute',
                            \            'co' : 'xsl:copy-of',
                            \            'each' : 'xsl:for-each',
                            \            'ap' : 'xsl:apply-templates',
                            \        },
                            \        'expandos': {
                            \            'choose': 'xsl:choose>xsl:when+xsl:otherwise',
                            \        }
                            \    },
                            \    'jsx': {
                            \        'extends': 'html',
                            \        'attribute_name': {'class': 'className', 'for': 'htmlFor'},
                            \        'empty_element_suffix': ' />',
                            \    },
                            \    'xslt': {
                            \        'extends': 'xsl',
                            \    },
                            \    'haml': {
                            \        'indentation': '  ',
                            \        'extends': 'html',
                            \        'snippets': {
                            \            'html:5': "!!! 5\n"
                            \                    ."%html{:lang => \"${lang}\"}\n"
                            \                    ."\t%head\n"
                            \                    ."\t\t%meta{:charset => \"${charset}\"}\n"
                            \                    ."\t\t%title\n"
                            \                    ."\t%body\n"
                            \                    ."\t\t${child}|\n",
                            \        },
                            \        'attribute_style': 'hash',
                            \    },
                            \    'slim': {
                            \        'indentation': '  ',
                            \        'extends': 'html',
                            \        'snippets': {
                            \            'html:5': "doctype 5\n"
                            \                    ."html lang=\"${lang}\"\n"
                            \                    ."\thead\n"
                            \                    ."\t\tmeta charset=\"${charset}\"\n"
                            \                    ."\t\ttitle\n"
                            \                    ."\tbody\n"
                            \                    ."\t\t${child}|\n",
                            \        },
                            \    },
                            \    'xhtml': {
                            \        'extends': 'html'
                            \    },
                            \    'mustache': {
                            \        'extends': 'html'
                            \    },
                            \    'xsd': {
                            \        'extends': 'html',
                            \        'snippets': {
                            \            'xsd:w3c': "<?xml version=\"1.0\"?>\n"
                            \                    ."<xsd:schema xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\">\n"
                            \                    ."\t<xsd:element name=\"\" type=\"\"/>\n"
                            \                    ."</xsd:schema>\n"
                            \        }
                            \    },
                            \}
                            
    1              0.000010 if exists('g:user_emmet_settings')
                              call emmet#mergeConfig(s:emmet_settings, g:user_emmet_settings)
                            endif
                            
    1              0.000015 let &cpoptions = s:save_cpo
    1              0.000005 unlet s:save_cpo
                            
                            " vim:set et:

SCRIPT  /home/pawelztef/.local/share/nvim/plugged/emmet-vim/autoload/emmet/lang.vim
Sourced 1 time
Total time:   0.000418
 Self time:   0.000418

count  total (s)   self (s)
    1              0.000022 let s:exists = {}
    1              0.000014 function! emmet#lang#exists(type) abort
                              if len(a:type) == 0
                                return 0
                              elseif has_key(s:exists, a:type)
                                return s:exists[a:type]
                              endif
                              let s:exists[a:type] = len(globpath(&rtp, 'autoload/emmet/lang/'.a:type.'.vim')) > 0
                              return s:exists[a:type]
                            endfunction
                            
    1              0.000010 function! emmet#lang#type(type) abort
                              let type = a:type
                              let base = type
                              let settings = emmet#getSettings()
                              while base != ''
                                for b in split(base, '\.')
                                  if emmet#lang#exists(b)
                                    return b
                                  endif
                                  if has_key(settings, b) && has_key(settings[b], 'extends')
                                    let base = settings[b].extends
                                    break
                                  else
                                    let base = ''
                                  endif
                                endfor
                              endwhile
                              return 'html'
                            endfunction

SCRIPT  /home/pawelztef/.local/share/nvim/plugged/emmet-vim/autoload/emmet/lang/scss.vim
Sourced 1 time
Total time:   0.000691
 Self time:   0.000691

count  total (s)   self (s)
    1              0.000020 function! emmet#lang#scss#findTokens(str) abort
                              return emmet#lang#css#findTokens(a:str)
                            endfunction
                            
    1              0.000013 function! emmet#lang#scss#parseIntoTree(abbr, type) abort
                              if a:abbr =~# '>'
                                return emmet#lang#html#parseIntoTree(a:abbr, a:type)
                              else
                                return emmet#lang#css#parseIntoTree(a:abbr, a:type)
                              endif
                            endfunction
                            
    1              0.000014 function! emmet#lang#scss#toString(settings, current, type, inline, filters, itemno, indent) abort
                              let settings = a:settings
                              let current = a:current
                              let type = a:type
                              let inline = a:inline
                              let filters = a:filters
                              let itemno = a:itemno
                              let indent = a:indent
                              let str = ''
                            
                              let current_name = substitute(current.name, '\$$', itemno+1, '')
                              if len(current.name) > 0
                                let str .= current_name
                                let tmp = ''
                                for attr in keys(current.attr)
                                  let val = current.attr[attr]
                                  while val =~# '\$\([^#{]\|$\)'
                                    let val = substitute(val, '\(\$\+\)\([^{]\|$\)', '\=printf("%0".len(submatch(1))."d", itemno+1).submatch(2)', 'g')
                                  endwhile
                                  let attr = substitute(attr, '\$$', itemno+1, '')
                                  if attr ==# 'id'
                                    let str .= '#' . val
                                  elseif attr ==# 'class'
                                    let str .= '.' . val
                                  else
                                    let tmp .= attr . ': ' . val . ';'
                                  endif
                                endfor
                                if len(tmp) > 0
                                  let str .= " {\n"
                                  for line in split(tmp, "\n")
                                    let str .= indent . line . "\n"
                                  endfor
                                else
                                  let str .= " {\n"
                                endif
                            
                                let inner = ''
                                for child in current.child
                                  let inner .= emmet#toString(child, type, inline, filters, itemno)
                                endfor
                                let inner = substitute(inner, "\n", "\n" . escape(indent, '\'), 'g')
                                let inner = substitute(inner, "\n" . escape(indent, '\') . '$', '', 'g')
                                let str .= indent . inner . "${cursor}\n}\n"
                              else
                                return emmet#lang#css#toString(settings, current, type, inline, filters, itemno, indent)
                              endif
                              return str
                            endfunction
                            
    1              0.000011 function! emmet#lang#scss#imageSize() abort
                              call emmet#lang#css#imageSize()
                            endfunction
                            
    1              0.000010 function! emmet#lang#scss#encodeImage() abort
                              return emmet#lang#css#encodeImage()
                            endfunction
                            
    1              0.000010 function! emmet#lang#scss#parseTag(tag) abort
                              return emmet#lang#css#parseTag(a:tag)
                            endfunction
                            
    1              0.000010 function! emmet#lang#scss#toggleComment() abort
                              call emmet#lang#css#toggleComment()
                            endfunction
                            
    1              0.000010 function! emmet#lang#scss#balanceTag(flag) range abort
                              if a:flag == -2 || a:flag == 2
                                let curpos = [0, line("'<"), col("'<"), 0]
                                call setpos('.', curpos)
                              else
                                let curpos = emmet#util#getcurpos()
                              endif
                              if a:flag < 0
                                let ret = searchpair('}', '', '.\zs{')
                              else
                                let ret = searchpair('{', '', '}', 'bW')
                              endif
                              if ret > 0
                                let pos1 = emmet#util#getcurpos()[1:2]
                                if a:flag < 0
                                  let pos2 = searchpairpos('{', '', '}')
                                else
                                  let pos2 = searchpairpos('{', '', '}')
                                endif
                                let block = [pos1, pos2]
                                if emmet#util#regionIsValid(block)
                                  call emmet#util#selectRegion(block)
                                  return
                                endif
                              endif
                              if a:flag == -2 || a:flag == 2
                                silent! exe 'normal! gv'
                              else
                                call setpos('.', curpos)
                              endif
                            endfunction
                            
    1              0.000007 function! emmet#lang#scss#moveNextPrevItem(flag) abort
                              return emmet#lang#scss#moveNextPrev(a:flag)
                            endfunction
                            
    1              0.000011 function! emmet#lang#scss#moveNextPrev(flag) abort
                              call emmet#lang#css#moveNextPrev(a:flag)
                            endfunction
                            
    1              0.000005 function! emmet#lang#scss#splitJoinTag() abort
                              call emmet#lang#css#splitJoinTag()
                            endfunction
                            
    1              0.000005 function! emmet#lang#scss#removeTag() abort
                              call emmet#lang#css#removeTag()
                            endfunction

SCRIPT  /home/pawelztef/.local/share/nvim/plugged/emmet-vim/autoload/emmet/lang/css.vim
Sourced 1 time
Total time:   0.001295
 Self time:   0.001295

count  total (s)   self (s)
    1              0.000020 function! emmet#lang#css#findTokens(str) abort
                              let tmp = substitute(substitute(a:str, '^.*[;{]\s*', '', ''), '}\s*$', '', '')
                              if tmp =~ '/' && tmp =~ '^[a-zA-Z0-9/_.]\+$'
                                " maybe path or something
                                return ''
                              endif
                              return substitute(substitute(a:str, '^.*[;{]\s*', '', ''), '}\s*$', '', '')
                            endfunction
                            
    1              0.000011 function! emmet#lang#css#parseIntoTree(abbr, type) abort
                              let abbr = a:abbr
                              let type = a:type
                              let prefix = 0
                              let value = ''
                            
                              let indent = emmet#getIndentation(type)
                              let aliases = emmet#getResource(type, 'aliases', {})
                              let snippets = emmet#getResource(type, 'snippets', {})
                              let use_pipe_for_cursor = emmet#getResource(type, 'use_pipe_for_cursor', 1)
                            
                              let root = emmet#newNode()
                            
                              " emmet
                              let tokens = split(abbr, '+\ze[^+)!]')
                              let block = emmet#util#searchRegion('{', '}')
                              if abbr !~# '^@' && emmet#getBaseType(type) ==# 'css' && type !=# 'sass' && block[0] ==# [0,0] && block[1] ==# [0,0]
                                let current = emmet#newNode()
                                let current.snippet = substitute(abbr, '\s\+$', '', '') . " {\n" . indent . "${cursor}\n}"
                                let current.name = ''
                                call add(root.child, deepcopy(current))
                              else
                                for n in range(len(tokens))
                                  let token = tokens[n]
                                  let prop = matchlist(token, '^\(-\{0,1}[a-zA-Z]\+\|[a-zA-Z0-9]\++\{0,1}\|([a-zA-Z0-9]\++\{0,1})\)\(\%([0-9.-]\+\%(p\|e\|em\|vh\|vw\|re\|rem\|%\)\{0,1}-\{0,1}\|-auto\)*\)$')
                                  if len(prop)
                                    let token = substitute(prop[1], '^(\(.*\))', '\1', '')
                                    if token =~# '^-'
                                      let prefix = 1
                                      let token = token[1:]
                                    endif
                                    let value = ''
                                    for v in split(prop[2], '\d\zs-')
                                      if len(value) > 0
                                        let value .= ' '
                                      endif
                                      if token =~# '^[z]'
                                        " TODO
                                        let value .= substitute(v, '[^0-9.]*$', '', '')
                                      elseif v =~# 'p$'
                                        let value .= substitute(v, 'p$', '%', '')
                                      elseif v =~# '%$'
                                        let value .= v
                                      elseif v =~# 'e$'
                                        let value .= substitute(v, 'e$', 'em', '')
                                      elseif v =~# 'em$'
                                        let value .= v
                                      elseif v =~# 'vh$'
                                        let value .= v
                                      elseif v =~# 'vw$'
                                        let value .= v
                                      elseif v =~# 're$'
                                        let value .= substitute(v, 're$', 'rem', '')
                                      elseif v =~# 'rem$'
                                        let value .= v
                                      elseif v =~# '\.'
                                        let value .= v . 'em'
                                      elseif v ==# 'auto'
                                        let value .= v
                                      elseif v ==# '0'
                                        let value .= '0'
                                      else
                                        let value .= v . 'px'
                                      endif
                                    endfor
                                  endif
                            
                                  let tag_name = token
                                  if tag_name =~# '.!$'
                                    let tag_name = tag_name[:-2]
                                    let important = 1
                                  else
                                    let important = 0
                                  endif
                                  " make default node
                                  let current = emmet#newNode()
                                  let current.important = important
                                  let current.name = tag_name
                            
                                  " aliases
                                  if has_key(aliases, tag_name)
                                    let current.name = aliases[tag_name]
                                  endif
                            
                                  " snippets
                                  if !empty(snippets)
                                    let snippet_name = tag_name
                                    if !has_key(snippets, snippet_name)
                                      let pat = '^' . join(split(tag_name, '\zs'), '\%(\|[^:-]\+-\)')
                                      let vv = filter(sort(keys(snippets)), 'snippets[v:val] =~ pat')
                                      if len(vv) == 0
                                        let vv = filter(sort(keys(snippets)), 'substitute(v:val, ":", "", "g") == snippet_name')
                                      endif
                                      if len(vv) > 0
                                        let snippet_name = vv[0]
                                      else
                                        let pat = '^' . join(split(tag_name, '\zs'), '\%(\|[^:-]\+-*\)')
                                        let vv = filter(sort(keys(snippets)), 'snippets[v:val] =~ pat')
                                        if len(vv) == 0
                                          let pat = '^' . join(split(tag_name, '\zs'), '[^:]\{-}')
                                          let vv = filter(sort(keys(snippets)), 'snippets[v:val] =~ pat')
                                          if len(vv) == 0
                                            let pat = '^' . join(split(tag_name, '\zs'), '.\{-}')
                                            let vv = filter(sort(keys(snippets)), 'snippets[v:val] =~ pat')
                                          endif
                                        endif
                                        let minl = -1
                                        for vk in vv
                                          let vvs = snippets[vk]
                                          if minl == -1 || len(vvs) < minl
                                            let snippet_name = vk
                                            let minl = len(vvs)
                                          endif
                                        endfor
                                      endif
                                    endif
                                    if has_key(snippets, snippet_name)
                                      let snippet = snippets[snippet_name]
                                      if use_pipe_for_cursor
                                        let snippet = substitute(snippet, '|', '${cursor}', 'g')
                                      endif
                                      let lines = split(snippet, "\n")
                                      call map(lines, 'substitute(v:val, "\\(    \\|\\t\\)", escape(indent, "\\\\"), "g")')
                                      let current.snippet = join(lines, "\n")
                                      let current.name = ''
                                      let current.snippet = substitute(current.snippet, ';', value . ';', '')
                                      if use_pipe_for_cursor && len(value) > 0
                                        let current.snippet = substitute(current.snippet, '\${cursor}', '', 'g')
                                      endif
                                      if n < len(tokens) - 1
                                        let current.snippet .= "\n"
                                      endif
                                    endif
                                  endif
                            
                                  let current.pos = 0
                                  let lg = matchlist(token, '^\%(linear-gradient\|lg\)(\s*\(\S\+\)\s*,\s*\([^,]\+\)\s*,\s*\([^)]\+\)\s*)$')
                                  if len(lg) == 0
                                    let lg = matchlist(token, '^\%(linear-gradient\|lg\)(\s*\(\S\+\)\s*,\s*\([^,]\+\)\s*)$')
                                    if len(lg)
                                      let [lg[1], lg[2], lg[3]] = ['linear', lg[1], lg[2]]
                                    endif
                                  endif
                                  if len(lg)
                                    let current.name = ''
                                    let current.snippet = printf("background-image:-webkit-gradient(%s, 0 0, 0 100%, from(%s), to(%s));\n", lg[1], lg[2], lg[3])
                                    call add(root.child, deepcopy(current))
                                    let current.snippet = printf("background-image:-webkit-linear-gradient(%s, %s);\n", lg[2], lg[3])
                                    call add(root.child, deepcopy(current))
                                    let current.snippet = printf("background-image:-moz-linear-gradient(%s, %s);\n", lg[2], lg[3])
                                    call add(root.child, deepcopy(current))
                                    let current.snippet = printf("background-image:-o-linear-gradient(%s, %s);\n", lg[2], lg[3])
                                    call add(root.child, deepcopy(current))
                                    let current.snippet = printf("background-image:linear-gradient(%s, %s);\n", lg[2], lg[3])
                                    call add(root.child, deepcopy(current))
                                  elseif prefix
                                    let snippet = current.snippet
                                    let current.snippet = '-webkit-' . snippet . "\n"
                                    call add(root.child, deepcopy(current))
                                    let current.snippet = '-moz-' . snippet . "\n"
                                    call add(root.child, deepcopy(current))
                                    let current.snippet = '-o-' . snippet . "\n"
                                    call add(root.child, deepcopy(current))
                                    let current.snippet = '-ms-' . snippet . "\n"
                                    call add(root.child, deepcopy(current))
                                    let current.snippet = snippet
                                    call add(root.child, current)
                                  elseif token =~# '^c#\([0-9a-fA-F]\{3}\|[0-9a-fA-F]\{6}\)\(\.[0-9]\+\)\?'
                                    let cs = split(token, '\.')
                                    let current.name = ''
                                    let [r,g,b] = [0,0,0]
                                    if len(cs[0]) == 5
                                      let rgb = matchlist(cs[0], 'c#\(.\)\(.\)\(.\)')
                                      let r = eval('0x'.rgb[1].rgb[1])
                                      let g = eval('0x'.rgb[2].rgb[2])
                                      let b = eval('0x'.rgb[3].rgb[3])
                                    elseif len(cs[0]) == 8
                                      let rgb = matchlist(cs[0], 'c#\(..\)\(..\)\(..\)')
                                      let r = eval('0x'.rgb[1])
                                      let g = eval('0x'.rgb[2])
                                      let b = eval('0x'.rgb[3])
                                    endif
                                    if len(cs) == 1
                                      let current.snippet = printf('color:rgb(%d, %d, %d);', r, g, b)
                                    else
                                      let current.snippet = printf('color:rgb(%d, %d, %d, %s);', r, g, b, string(str2float('0.'.cs[1])))
                                    endif
                                    call add(root.child, current)
                                  elseif token =~# '^c#'
                                    let current.name = ''
                                    let current.snippet = 'color:\${cursor};'
                                    call add(root.child, current)
                                  else
                                    call add(root.child, current)
                                  endif
                                endfor
                              endif
                              return root
                            endfunction
                            
    1              0.000014 function! emmet#lang#css#toString(settings, current, type, inline, filters, itemno, indent) abort
                              let current = a:current
                              let value = current.value[1:-2]
                              let tmp = substitute(value, '\${cursor}', '', 'g')
                              if tmp !~ '.*{[ \t\r\n]*}$'
                                if emmet#useFilter(a:filters, 'fc')
                                  let value = substitute(value, '\([^:]\+\):\([^;]*\)', '\1: \2', 'g')
                                else
                                  let value = substitute(value, '\([^:]\+\):\([^;]*\)', '\1:\2', 'g')
                                endif
                                if current.important
                                  let value = substitute(value, ';', ' !important;', '')
                                endif
                              endif
                              return value
                            endfunction
                            
    1              0.000006 function! emmet#lang#css#imageSize() abort
                              let img_region = emmet#util#searchRegion('{', '}')
                              if !emmet#util#regionIsValid(img_region) || !emmet#util#cursorInRegion(img_region)
                                return
                              endif
                              let content = emmet#util#getContent(img_region)
                              let fn = matchstr(content, '\<url(\zs[^)]\+\ze)')
                              let fn = substitute(fn, '[''" \t]', '', 'g')
                              if fn =~# '^\s*$'
                                return
                              elseif fn !~# '^\(/\|http\)'
                                let fn = simplify(expand('%:h') . '/' . fn)
                              endif
                              let [width, height] = emmet#util#getImageSize(fn)
                              if width == -1 && height == -1
                                return
                              endif
                              let indent = emmet#getIndentation('css')
                              if content =~# '.*\<width\s*:[^;]*;.*'
                                let content = substitute(content, '\<width\s*:[^;]*;', 'width: ' . width . 'px;', '')
                              else
                                let content = substitute(content, '}', indent . 'width: ' . width . "px;\n}", '')
                              endif
                              if content =~# '.*\<height\s*:[^;]*;.*'
                                let content = substitute(content, '\<height\s*:[^;]*;', 'height: ' . height . 'px;', '')
                              else
                                let content = substitute(content, '}', indent . 'height: ' . height . "px;\n}", '')
                              endif
                              call emmet#util#setContent(img_region, content)
                            endfunction
                            
    1              0.000006 function! emmet#lang#css#encodeImage() abort
                            endfunction
                            
    1              0.000005 function! emmet#lang#css#parseTag(tag) abort
                              return {}
                            endfunction
                            
    1              0.000005 function! emmet#lang#css#toggleComment() abort
                              let line = getline('.')
                              let mx = '^\(\s*\)/\*\s*\(.*\)\s*\*/\s*$'
                              if line =~# '{\s*$'
                                let block = emmet#util#searchRegion('/\*', '\*/\zs')
                                if emmet#util#regionIsValid(block)
                                  let content = emmet#util#getContent(block)
                                  let content = substitute(content, '/\*\s\(.*\)\s\*/', '\1', '')
                                  call emmet#util#setContent(block, content)
                                else
                                  let node = expand('<cword>')
                                  if len(node)
                                    exe "normal ciw\<c-r>='/* '.node.' */'\<cr>"
                                  endif
                                endif
                              else
                                if line =~# mx
                                  let space = substitute(matchstr(line, mx), mx, '\1', '')
                                  let line = substitute(matchstr(line, mx), mx, '\2', '')
                                  let line = space . substitute(line, '^\s*\|\s*$', '\1', 'g')
                                else
                                  let mx = '^\(\s*\)\(.*\)\s*$'
                                  let line = substitute(line, mx, '\1/* \2 */', '')
                                endif
                                call setline('.', line)
                              endif
                            endfunction
                            
    1              0.000006 function! emmet#lang#css#balanceTag(flag) range abort
                              if a:flag == -2 || a:flag == 2
                                let curpos = [0, line("'<"), col("'<"), 0]
                              else
                                let curpos = emmet#util#getcurpos()
                              endif
                              let block = emmet#util#getVisualBlock()
                              if !emmet#util#regionIsValid(block)
                                if a:flag > 0
                                  let block = emmet#util#searchRegion('^', ';')
                                  if emmet#util#regionIsValid(block)
                                    call emmet#util#selectRegion(block)
                                    return
                                  endif
                                endif
                              else
                                if a:flag > 0
                                  let content = emmet#util#getContent(block)
                                  if content !~# '^{.*}$'
                                    let block = emmet#util#searchRegion('{', '}')
                                    if emmet#util#regionIsValid(block)
                                      call emmet#util#selectRegion(block)
                                      return
                                    endif
                                  endif
                                else
                                  let pos = searchpos('.*;', 'nW')
                                  if pos[0] != 0
                                    call setpos('.', [0, pos[0], pos[1], 0])
                                    let block = emmet#util#searchRegion('^', ';')
                                    if emmet#util#regionIsValid(block)
                                      call emmet#util#selectRegion(block)
                                      return
                                    endif
                                  endif
                                endif
                              endif
                              if a:flag == -2 || a:flag == 2
                                silent! exe 'normal! gv'
                              else
                                call setpos('.', curpos)
                              endif
                            endfunction
                            
    1              0.000006 function! emmet#lang#css#moveNextPrevItem(flag) abort
                              return emmet#lang#css#moveNextPrev(a:flag)
                            endfunction
                            
    1              0.000008 function! emmet#lang#css#moveNextPrev(flag) abort
                              let pos = search('""\|()\|\(:\s*\zs$\)', a:flag ? 'Wbp' : 'Wp')
                              if pos == 2
                                startinsert!
                              else
                                silent! normal! l
                                startinsert
                              endif
                            endfunction
                            
    1              0.000006 function! emmet#lang#css#splitJoinTag() abort
                              " nothing to do
                            endfunction
                            
    1              0.000005 function! emmet#lang#css#removeTag() abort
                              " nothing to do
                            endfunction

FUNCTION  emmet#newNode()
Called 3 times
Total time:   0.000070
 Self time:   0.000070

count  total (s)   self (s)
    3              0.000055   return { 'name': '', 'attr': {}, 'child': [], 'snippet': '', 'basevalue': 0, 'basedirect': 1, 'multiplier': 1, 'parent': {}, 'value': '', 'pos': 0, 'important': 0, 'attrs_order': ['id', 'class'], 'block': 0, 'empty': 0 }

FUNCTION  2()
Called 6 times
Total time:   0.001652
 Self time:   0.000202

count  total (s)   self (s)
    6   0.000281   0.000095     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'autoloclist: refresh')
    6   0.001341   0.000078     call g:SyntasticAutoloclistNotifier.AutoToggle(a:loclist)

FUNCTION  5()
Called 6 times
Total time:   0.000099
 Self time:   0.000099

count  total (s)   self (s)
    6              0.000077     return has('balloon_eval') && syntastic#util#var('enable_balloons')

FUNCTION  8()
Called 35 times
Total time:   0.008707
 Self time:   0.008707

count  total (s)   self (s)
   35              0.000779     let newObj = copy(self)
                            
   35              0.000260     let newObj._filetype = a:args['filetype']
   35              0.000212     let newObj._name = a:args['name']
                            
   35              0.000118     if a:0
                                    " redirected checker
    9              0.000086         let newObj._exec_default = get(a:args, 'exec', a:1['_exec_default'])
                            
    9              0.000056         let filetype = a:1['_filetype']
    9              0.000049         let name = a:1['_name']
    9              0.000072         let prefix = 'SyntaxCheckers_' . filetype . '_' . name . '_'
                            
    9              0.000112         if exists('g:syntastic_' . filetype . '_' . name . '_sort') && !exists('g:syntastic_' . newObj._filetype . '_' . newObj._name . '_sort')
                                        let g:syntastic_{newObj._filetype}_{newObj._name}_sort = g:syntastic_{filetype}_{name}_sort
                                    endif
                            
    9              0.000050         if has_key(a:args, 'enable')
                                        let newObj._enable = a:args['enable']
                                    elseif has_key(a:1, '_enable')
                                        let newObj._enable = a:1['_enable']
                                    endif
    9              0.000020     else
   26              0.000279         let newObj._exec_default = get(a:args, 'exec', newObj._name)
   26              0.000161         if newObj._exec_default ==# ''
                                        let newObj._exec_default = '<dummy>'
                                    endif
   26              0.000260         let prefix = 'SyntaxCheckers_' . newObj._filetype . '_' . newObj._name . '_'
                            
   26              0.000139         if has_key(a:args, 'enable')
                                        let newObj._enable = a:args['enable']
                                    endif
   26              0.000060     endif
                            
   35              0.000369     let newObj._locListFunc = function(prefix . 'GetLocList')
                            
   35              0.000351     if exists('*' . prefix . 'IsAvailable')
   13              0.000130         let newObj._isAvailableFunc = function(prefix . 'IsAvailable')
   13              0.000035     else
   22              0.000233         let newObj._isAvailableFunc = function('s:_isAvailableDefault')
   22              0.000059     endif
                            
   35              0.000290     if exists('*' . prefix . 'GetHighlightRegex')
    5              0.000054         let newObj._highlightRegexFunc = function(prefix . 'GetHighlightRegex')
    5              0.000013     endif
                            
   35              0.000118     return newObj

FUNCTION  9()
Called 47 times
Total time:   0.000377
 Self time:   0.000377

count  total (s)   self (s)
   47              0.000236     return self._filetype

FUNCTION  <SNR>72_Disable()
Called 2 times
Total time:   0.000228
 Self time:   0.000095

count  total (s)   self (s)
    2              0.000016     if exists("b:indentLine_enabled") && b:indentLine_enabled
                                    return
                                elseif exists("b:indentLine_leadingSpaceEnabled") && b:indentLine_leadingSpaceEnabled
                                    return
                                elseif s:Filter() == 0
                                    call s:IndentLinesDisable()
                                    call s:LeadingSpaceDisable()
                                endif

FUNCTION  <SNR>84_on_complete_done()
Called 2 times
Total time:   0.000805
 Self time:   0.000216

count  total (s)   self (s)
    2              0.000040   if get(v:completed_item, 'word', '') !=# ''
                                let word = v:completed_item.word
                                if !has_key(g:deoplete#_rank, word)
                                  let g:deoplete#_rank[word] = 1
                                else
                                  let g:deoplete#_rank[word] += 1
                                endif
                              endif
                            
    2              0.000013   if !g:deoplete#enable_refresh_always
    2   0.000650   0.000061     call deoplete#handler#_skip_next_completion()
    2              0.000005   endif

FUNCTION  syntastic#log#debug()
Called 174 times
Total time:   0.005983
 Self time:   0.003937

count  total (s)   self (s)
  174   0.004596   0.002549     if !s:_isDebugEnabled(a:level)
  174              0.000531         return
                                endif
                            
                                let leader = s:_log_timestamp()
                                call s:_logRedirect(1)
                            
                                if a:0
                                    " filter out dictionary functions
                                    echomsg leader . a:msg . ' ' . strtrans(string(type(a:1) == type({}) || type(a:1) == type([]) ? filter(copy(a:1), 'type(v:val) != type(function("tr"))') : a:1))
                                else
                                    echomsg leader . a:msg
                                endif
                            
                                call s:_logRedirect(0)

FUNCTION  emmet#useFilter()
Called 2 times
Total time:   0.000113
 Self time:   0.000113

count  total (s)   self (s)
    4              0.000018   for f in a:filters
    2              0.000010     if a:filter ==# '/' && f =~# '^/'
                                  return 1
                                elseif f ==# a:filter
                                  return 1
                                endif
    2              0.000005   endfor
    2              0.000006   return 0

FUNCTION  remote#host#Require()
Called 1 time
Total time:   0.199290
 Self time:   0.000121

count  total (s)   self (s)
    1              0.000009   if !has_key(s:hosts, a:name)
                                throw 'No host named "'.a:name.'" is registered'
                              endif
    1              0.000006   let host = s:hosts[a:name]
    1              0.000005   if !host.channel && !host.initialized
    1              0.000012     let host_info = { 'name': a:name, 'orig_name': get(host, 'orig_name', a:name) }
    1   0.199220   0.000051     let host.channel = call(host.factory, [host_info])
    1              0.000007     let host.initialized = 1
    1              0.000003   endif
    1              0.000007   return host.channel

FUNCTION  gitgutter#utility#highlight_name_for_change()
Called 12 times
Total time:   0.000182
 Self time:   0.000182

count  total (s)   self (s)
   12              0.000066   if a:text ==# 'added'
   11              0.000039     return 'GitGutterLineAdded'
                              elseif a:text ==# 'removed'
                                return 'GitGutterLineRemoved'
                              elseif a:text ==# 'removed_first_line'
    1              0.000004     return 'GitGutterLineRemovedFirstLine'
                              elseif a:text ==# 'modified'
                                return 'GitGutterLineModified'
                              elseif a:text ==# 'modified_removed'
                                return 'GitGutterLineModifiedRemoved'
                              endif

FUNCTION  gitgutter#process_buffer()
Called 8 times
Total time:   0.062546
 Self time:   0.003053

count  total (s)   self (s)
    8   0.000809   0.000154   call gitgutter#utility#use_known_shell()
                            
    8   0.000557   0.000156   call gitgutter#utility#set_buffer(a:bufnr)
    8   0.001410   0.000112   if gitgutter#utility#is_active()
    6              0.000036     if g:gitgutter_sign_column_always
                                  call gitgutter#sign#add_dummy_sign()
                                endif
    6              0.000021     try
    6              0.000036       if !a:realtime || gitgutter#utility#has_fresh_changes()
    6   0.056564   0.000699         let diff = gitgutter#diff#run_diff(a:realtime || gitgutter#utility#has_unsaved_changes(), 0)
    6              0.000052         if diff != 'async'
                                      call gitgutter#handle_diff(diff)
                                    endif
    6              0.000016       endif
    6              0.000039     catch /diff failed/
                                  call gitgutter#debug#log('diff failed')
                                  call gitgutter#hunk#reset()
                                endtry
    6   0.001033   0.000819     execute "silent doautocmd" s:nomodeline "User GitGutter"
    6              0.000032   else
    2   0.000421   0.000029     call gitgutter#hunk#reset()
    2              0.000007   endif
                            
    8   0.000874   0.000206   call gitgutter#utility#restore_shell()

FUNCTION  <SNR>39__is_quitting()
Called 12 times
Total time:   0.000727
 Self time:   0.000727

count  total (s)   self (s)
   12              0.000078     let quitting = 0
   12              0.000095     if exists('w:syntastic_wid')
                                    let key = a:buf . '_' . getbufvar(a:buf, 'changetick') . '_' . w:syntastic_wid
                                    let idx = index(s:_quit_pre, key)
                                    if idx >= 0
                                        call remove(s:_quit_pre, idx)
                                        let quitting = 1
                                    endif
                                endif
                            
   12              0.000053     return quitting

FUNCTION  <SNR>74_expand()
Called 20 times
Total time:   0.015394
 Self time:   0.008823

count  total (s)   self (s)
   20              0.000121   let components = []
   20              0.000084   let expanded = []
   20              0.000087   let indices = []
   20              0.000091   let previndex = -1
   20   0.008269   0.001698   let xs = s:flatten_twice(s:map(deepcopy(a:components), 'map(v:val, "s:convert(v:val, ''" . v:key . "'')")'))
   99              0.000488   for [component, expand, index] in xs
   79              0.000370     if previndex != index
   44              0.000310       call add(indices, index)
   44              0.000289       call add(components, [])
   44              0.000224       call add(expanded, [])
   44              0.000167     endif
   79              0.000578     call extend(components[-1], component)
   79              0.000859     call extend(expanded[-1], repeat([expand], len(component)))
   79              0.000393     let previndex = index
   79              0.000221   endfor
   20              0.000352   call add(indices, string(len(a:components)))
   20              0.000129   return [components, expanded, indices]

FUNCTION  <SNR>15_splittable()
Called 1 time
Total time:   0.000069
 Self time:   0.000024

count  total (s)   self (s)
    1   0.000066   0.000021   return s:present(a:dict, 'up', 'down') && &lines > 15 || s:present(a:dict, 'left', 'right') && &columns > 40

FUNCTION  <SNR>43_buffer()
Called 2 times
Total time:   0.000162
 Self time:   0.000136

count  total (s)   self (s)
    2              0.000026   let buffer = {'#': bufnr(a:0 ? a:1 : '%')}
    2              0.000042   call extend(extend(buffer,s:buffer_prototype,'keep'),s:abstract_prototype,'keep')
    2   0.000071   0.000044   if !empty(buffer.getvar('bundler_lock'))
    2              0.000008     return buffer
                              endif
                              call s:throw('not a Bundler project: '.(a:0 ? a:1 : expand('%')))

FUNCTION  <SNR>85_wrap()
Called 1 time
Total time:   0.002470
 Self time:   0.000240

count  total (s)   self (s)
                              " fzf#wrap does not append --expect if sink or sink* is found
    1              0.000014   let opts = copy(a:opts)
    1              0.000007   let options = ''
    1              0.000009   if has_key(opts, 'options')
    1              0.000024     let options = type(opts.options) == s:TYPE.list ? join(opts.options) : opts.options
    1              0.000005   endif
    1              0.000085   if options !~ '--expect' && has_key(opts, 'sink*')
                                let Sink = remove(opts, 'sink*')
                                let wrapped = fzf#wrap(a:name, opts, a:bang)
                                let wrapped['sink*'] = Sink
                              else
    1   0.002271   0.000042     let wrapped = fzf#wrap(a:name, opts, a:bang)
    1              0.000003   endif
    1              0.000003   return wrapped

FUNCTION  gitgutter#sign#remove_signs()
Called 6 times
Total time:   0.070895
 Self time:   0.070588

count  total (s)   self (s)
    6   0.000120   0.000076   let bufnr = gitgutter#utility#bufnr()
    6   0.000219   0.000084   if a:all_signs && s:supports_star && empty(gitgutter#utility#getbufvar(bufnr, 'other_signs'))
    5   0.000198   0.000071     let dummy_sign_present = gitgutter#utility#getbufvar(bufnr, 'dummy_sign')
    5              0.000053     execute "sign unplace * buffer=" . bufnr
    5              0.000019     if dummy_sign_present
    3              0.070027       execute "sign place" s:dummy_sign_id "line=" . 9999 "name=GitGutterDummy buffer=" . bufnr
    3              0.000030     endif
    5              0.000012   else
    1              0.000005     for id in a:sign_ids
                                  execute "sign unplace" id
                                endfor
    1              0.000002   endif

FUNCTION  gitgutter#diff#process_hunk()
Called 4 times
Total time:   0.001842
 Self time:   0.000797

count  total (s)   self (s)
    4              0.000022   let modifications = []
    4              0.000024   let from_line  = a:hunk[0]
    4              0.000021   let from_count = a:hunk[1]
    4              0.000020   let to_line    = a:hunk[2]
    4              0.000020   let to_count   = a:hunk[3]
                            
    4   0.000093   0.000055   if gitgutter#diff#is_added(from_count, to_count)
    3   0.000464   0.000057     call gitgutter#diff#process_added(modifications, from_count, to_count, to_line)
    3   0.000473   0.000053     call gitgutter#hunk#increment_lines_added(to_count)
                            
    3              0.000018   elseif gitgutter#diff#is_removed(from_count, to_count)
    1   0.000057   0.000027     call gitgutter#diff#process_removed(modifications, from_count, to_count, to_line)
    1   0.000167   0.000028     call gitgutter#hunk#increment_lines_removed(from_count)
                            
    1              0.000006   elseif gitgutter#diff#is_modified(from_count, to_count)
                                call gitgutter#diff#process_modified(modifications, from_count, to_count, to_line)
                                call gitgutter#hunk#increment_lines_modified(to_count)
                            
                              elseif gitgutter#diff#is_modified_and_added(from_count, to_count)
                                call gitgutter#diff#process_modified_and_added(modifications, from_count, to_count, to_line)
                                call gitgutter#hunk#increment_lines_added(to_count - from_count)
                                call gitgutter#hunk#increment_lines_modified(from_count)
                            
                              elseif gitgutter#diff#is_modified_and_removed(from_count, to_count)
                                call gitgutter#diff#process_modified_and_removed(modifications, from_count, to_count, to_line)
                                call gitgutter#hunk#increment_lines_modified(to_count)
                                call gitgutter#hunk#increment_lines_removed(from_count - to_count)
                            
                              endif
    4              0.000014   return modifications

FUNCTION  <SNR>15_upgrade()
Called 1 time
Total time:   0.000058
 Self time:   0.000058

count  total (s)   self (s)
    1              0.000010   let copy = copy(a:dict)
    1              0.000006   if has_key(copy, 'tmux')
                                let copy.down = remove(copy, 'tmux')
                              endif
    1              0.000005   if has_key(copy, 'tmux_height')
                                let copy.down = remove(copy, 'tmux_height')
                              endif
    1              0.000004   if has_key(copy, 'tmux_width')
                                let copy.right = remove(copy, 'tmux_width')
                              endif
    1              0.000003   return copy

FUNCTION  <SNR>39_ClearCache()
Called 6 times
Total time:   0.008305
 Self time:   0.000394

count  total (s)   self (s)
    6   0.000878   0.000158     let loclist = g:SyntasticLoclist.current(a:buf)
    6   0.005630   0.000105     call s:notifiers.reset(loclist)
    6   0.001757   0.000092     call loclist.destroy()

FUNCTION  deoplete#handler#_async_timer_stop()
Called 9 times
Total time:   0.000359
 Self time:   0.000359

count  total (s)   self (s)
    9              0.000174   if exists('s:async_timer')
                                call timer_stop(s:async_timer.id)
                                unlet s:async_timer
                              endif

FUNCTION  63()
Called 6 times
Total time:   0.001200
 Self time:   0.000887

count  total (s)   self (s)
    6              0.000050     if !exists('w:syntastic_loclist_set')
    1              0.000007         let w:syntastic_loclist_set = []
    1              0.000003     endif
    6              0.000060     if a:new || empty(w:syntastic_loclist_set) || w:syntastic_loclist_set != [self._owner, getbufvar(self._owner, 'changedtick')]
    6              0.000050         let replace = !a:new && g:syntastic_reuse_loc_lists && !empty(w:syntastic_loclist_set)
    6   0.000271   0.000094         call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'loclist: setloclist ' . (replace ? '(replace)' : '(new)'))
    6   0.000184   0.000136         call setloclist(0, self.getRaw(), replace ? 'r' : ' ')
    6              0.000023         try
                                        " Vim 7.4.2200 or later
    6              0.000072             call setloclist(0, [], 'r', { 'title': ':SyntasticCheck ' . self._name })
    6              0.000023         catch /\m^Vim\%((\a\+)\)\=:E\%(118\|731\)/
                                        " do nothing
                                    endtry
    6   0.000154   0.000068         call syntastic#util#setLastTick(self._owner)
    6              0.000079         let w:syntastic_loclist_set = [self._owner, getbufvar(self._owner, 'syntastic_lasttick')]
    6              0.000018     endif

FUNCTION  syntastic#log#debugShowOptions()
Called 6 times
Total time:   0.000245
 Self time:   0.000171

count  total (s)   self (s)
    6   0.000189   0.000115     if !s:_isDebugEnabled(a:level)
    6              0.000024         return
                                endif
                            
                                let leader = s:_log_timestamp()
                                call s:_logRedirect(1)
                            
                                let vlist = copy(type(a:names) == type('') ? [a:names] : a:names)
                                let add_shell = index(vlist, 'shell') >= 0 && &shell !=# syntastic#util#var('shell')
                                if !empty(vlist)
                                    call map(vlist, "'&' . v:val . ' = ' . strtrans(string(eval('&' . v:val))) . (s:_is_modified(v:val) ? ' (!)' : '')")
                                    if add_shell
                                        call add(vlist, 'u:shell = ' . strtrans(string(syntastic#util#var('shell'))) . ' (!)')
                                    endif
                                    echomsg leader . join(vlist, ', ')
                                endif
                                call s:_logRedirect(0)

FUNCTION  3()
Called 6 times
Total time:   0.001264
 Self time:   0.000828

count  total (s)   self (s)
    6   0.000253   0.000077     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'autoloclist: toggle')
    6   0.000280   0.000077     let auto_loc_list = syntastic#util#var('auto_loc_list')
    6   0.000130   0.000072     if !a:loclist.isEmpty()
    6              0.000036         if auto_loc_list == 1 || auto_loc_list == 3
                                        call a:loclist.show()
                                    endif
    6              0.000014     else
                                    if (auto_loc_list == 1 || auto_loc_list == 2) && !empty(get(w:, 'syntastic_loclist_set', []))
                                        try
                                            " Vim 7.4.2200 or later
                                            let title = get(getloclist(0, { 'title': 1 }), 'title', ':SyntasticCheck ')
                                        catch /\m^Vim\%((\a\+)\)\=:E\%(118\|731\)/
                                            let title = ':SyntasticCheck '
                                        endtry
                            
                                        if strpart(title, 0, 16) ==# ':SyntasticCheck '
                                            " TODO: this will close the loc list window if one was opened
                                            " by something other than syntastic
                                            call SyntasticLoclistHide()
                            
                                            try
                                                " Vim 7.4.2200 or later
                                                call setloclist(0, [], 'r', { 'title': '' })
                                            catch /\m^Vim\%((\a\+)\)\=:E\%(118\|731\)/
                                                " do nothing
                                            endtry
                                            let w:syntastic_loclist_set = []
                                        endif
                                    endif
                                endif

FUNCTION  <SNR>15_dopopd()
Called 3 times
Total time:   0.004028
 Self time:   0.000139

count  total (s)   self (s)
    3   0.000079   0.000050   if !exists('w:fzf_dir') || s:fzf_getcwd() != w:fzf_dir[1]
    2              0.000008     return
                              endif
    1   0.003911   0.000051   execute 'lcd' s:escape(w:fzf_dir[0])
    1              0.000006   unlet w:fzf_dir

FUNCTION  syntastic#util#tmpdir()
Called 1 time
Total time:   0.009368
 Self time:   0.000419

count  total (s)   self (s)
    1              0.000011     let tempdir = ''
                            
    1              0.000225     if (has('unix') || has('mac')) && executable('mktemp') && !has('win32unix')
                                    " TODO: option "-t" to mktemp(1) is not portable
    1              0.000011         let tmp = $TMPDIR !=# '' ? $TMPDIR : $TMP !=# '' ? $TMP : '/tmp'
    1   0.008993   0.000044         let out = split(syntastic#util#system('mktemp -q -d ' . tmp . '/vim-syntastic-' . s:_fuzz() . '-XXXXXXXX'), "\n")
    1              0.000009         if v:shell_error == 0 && len(out) == 1
    1              0.000006             let tempdir = out[0]
    1              0.000003         endif
    1              0.000002     endif
                            
    1              0.000004     if tempdir ==# ''
                                    if has('win32') || has('win64')
                                        let tempdir = $TEMP . syntastic#util#Slash() . 'vim-syntastic-' . s:_fuzz()
                                    elseif has('win32unix')
                                        let tempdir = syntastic#util#CygwinPath('/tmp/vim-syntastic-'  . s:_fuzz())
                                    elseif $TMPDIR !=# ''
                                        let tempdir = $TMPDIR . '/vim-syntastic-' . s:_fuzz()
                                    else
                                        let tempdir = '/tmp/vim-syntastic-' . s:_fuzz()
                                    endif
                            
                                    try
                                        call mkdir(tempdir, 'p', 0700)
                                    catch /\m^Vim\%((\a\+)\)\=:E739/
                                        call syntastic#log#error(v:exception)
                                        let tempdir = '.'
                                    endtry
                                endif
                            
    1              0.000007     return tempdir

FUNCTION  <SNR>15_evaluate_opts()
Called 2 times
Total time:   0.000250
 Self time:   0.000075

count  total (s)   self (s)
    2   0.000243   0.000068   return type(a:options) == type([]) ? join(map(copy(a:options), 'fzf#shellescape(v:val)')) : a:options

FUNCTION  <SNR>15_fzf_getcwd()
Called 4 times
Total time:   0.000135
 Self time:   0.000069

count  total (s)   self (s)
    4   0.000123   0.000057   return s:fzf_call('getcwd')

FUNCTION  emmet#lang#scss#findTokens()
Called 1 time
Total time:   0.001547
 Self time:   0.000143

count  total (s)   self (s)
    1   0.001542   0.000137   return emmet#lang#css#findTokens(a:str)

FUNCTION  <SNR>15_pushd()
Called 1 time
Total time:   0.004819
 Self time:   0.000161

count  total (s)   self (s)
    1   0.000050   0.000017   if s:present(a:dict, 'dir')
    1   0.000060   0.000015     let cwd = s:fzf_getcwd()
    1              0.000011     if get(a:dict, 'prev_dir', '') ==# cwd
                                  return 1
                                endif
    1              0.000008     let a:dict.prev_dir = cwd
    1   0.004609   0.000063     execute 'lcd' s:escape(a:dict.dir)
    1   0.000055   0.000020     let a:dict.dir = s:fzf_getcwd()
    1              0.000005     return 1
                              endif
                              return 0

FUNCTION  <SNR>39__skip_file()
Called 12 times
Total time:   0.003403
 Self time:   0.001768

count  total (s)   self (s)
   12              0.000131     let fname = bufname(a:buf)
   12   0.002837   0.001202     let skip = s:_is_quitting(a:buf) || getbufvar(a:buf, 'syntastic_skip_checks') || (getbufvar(a:buf, '&buftype') !=# '') || !filereadable(fname) || getwinvar(0, '&diff') || getwinvar(0, '&previewwindow') || s:_ignore_file(fname) || fnamemodify(fname, ':e') =~? g:syntastic_ignore_extensions
   12              0.000064     if skip
                                    call syntastic#log#debug(g:_SYNTASTIC_DEBUG_TRACE, '_skip_file: skipping checks')
                                endif
   12              0.000046     return skip

FUNCTION  <SNR>15_split()
Called 1 time
Total time:   0.023414
 Self time:   0.000780

count  total (s)   self (s)
    1              0.000019   let directions = { 'up':    ['topleft', 'resize', &lines], 'down':  ['botright', 'resize', &lines], 'left':  ['vertical topleft', 'vertical resize', &columns], 'right': ['vertical botright', 'vertical resize', &columns] }
    1   0.000041   0.000022   let ppos = s:getpos()
    1              0.000004   try
    1   0.000066   0.000016     if s:present(a:dict, 'window')
                                  execute 'keepalt' a:dict.window
                                elseif !s:splittable(a:dict)
                                  execute (tabpagenr()-1).'tabnew'
                                else
    4              0.000023       for [dir, triple] in items(directions)
    4              0.000028         let val = get(a:dict, dir, '')
    4              0.000018         if !empty(val)
    1              0.000006           let [cmd, resz, max] = triple
    1              0.000007           if (dir == 'up' || dir == 'down') && val[0] == '~'
    1   0.000158   0.000029             let sz = s:calc_size(max, val, a:dict)
    1              0.000003           else
                                        let sz = s:calc_size(max, val, {})
                                      endif
    1   0.022722   0.000354           execute cmd sz.'new'
    1              0.000010           execute resz sz
    1              0.000005           return [ppos, {}]
                                    endif
    3              0.000007       endfor
                                endif
                                return [ppos, { '&l:wfw': &l:wfw, '&l:wfh': &l:wfh }]
                              finally
    1              0.000017     setlocal winfixwidth winfixheight
    1              0.000004   endtry

FUNCTION  <SNR>84_completion_timer_stop()
Called 9 times
Total time:   0.000312
 Self time:   0.000312

count  total (s)   self (s)
    9              0.000069   if !exists('s:completion_timer')
                                return
                              endif
                            
    9              0.000066   call timer_stop(s:completion_timer)
    9              0.000039   unlet s:completion_timer

FUNCTION  deoplete#custom#get()
Called 19 times
Total time:   0.000682
 Self time:   0.000682

count  total (s)   self (s)
   19              0.000223   if !exists('s:custom')
                                call deoplete#custom#init()
                              endif
                            
   19              0.000086   return s:custom

FUNCTION  syntastic#util#shescape()
Called 13 times
Total time:   0.000606
 Self time:   0.000606

count  total (s)   self (s)
   13              0.000557     return a:string =~# '\m^[A-Za-z0-9_/.-]\+$' ? a:string : shellescape(a:string)

FUNCTION  deoplete#util#get_input()
Called 52 times
Total time:   0.008261
 Self time:   0.008261

count  total (s)   self (s)
   52              0.000465   let mode = mode()
   52              0.000311   if a:event ==# 'InsertEnter'
    6              0.000040     let mode = 'i'
    6              0.000022   endif
   52              0.001847   let input = (mode ==# 'i' ? (col('.')-1) : col('.')) >= len(getline('.')) ?      getline('.') :      matchstr(getline('.'),         '^.*\%' . (mode ==# 'i' ? col('.') : col('.') - 1)         . 'c' . (mode ==# 'i' ? '' : '.'))
                            
   52              0.001154   if input =~# '^.\{-}\ze\S\+$'
   24              0.000522     let complete_str = matchstr(input, '\S\+$')
   24              0.000506     let input = matchstr(input, '^.\{-}\ze\S\+$')
   24              0.000085   else
   28              0.000152     let complete_str = ''
   28              0.000078   endif
                            
   52              0.000271   if a:event ==# 'InsertCharPre'
                                let complete_str .= v:char
                              endif
                            
   52              0.000311   return input . complete_str

FUNCTION  <SNR>31__isAvailableDefault()
Called 1 time
Total time:   0.000045
 Self time:   0.000038

count  total (s)   self (s)
    1   0.000041   0.000034     return executable(self.getExec())

FUNCTION  fugitive#buffer()
Called 2 times
Total time:   0.000212
 Self time:   0.000040

count  total (s)   self (s)
    2   0.000206   0.000034   return s:buffer(a:0 ? a:1 : '%')

FUNCTION  <SNR>130_buffer_exec()
Called 12 times
Total time:   0.134461
 Self time:   0.001083

count  total (s)   self (s)
   12   0.000342   0.000242   let current_buffer = gitgutter#utility#bufnr()
   12   0.000756   0.000149   call gitgutter#utility#set_buffer(a:buffer)
                            
   12   0.002506   0.000142   if gitgutter#utility#is_active()
   12   0.130020   0.000186     call a:fn()
   12              0.000035   endif
                            
   12   0.000609   0.000137   call gitgutter#utility#set_buffer(current_buffer)

FUNCTION  <SNR>84_do_complete()
Called 8 times
Total time:   0.002514
 Self time:   0.001594

count  total (s)   self (s)
    8              0.000238   let context = g:deoplete#_context
    8              0.000152   let event = get(context, 'event', '')
    8              0.000118   let modes = (event == 'InsertEnter') ? ['n', 'i'] : ['i']
    8   0.000528   0.000336   if s:is_exiting() || index(modes, mode()) < 0
                                call s:completion_timer_stop()
                                return
                              endif
                            
    8   0.000670   0.000156   if empty(get(context, 'candidates', [])) || deoplete#util#get_input(context.event) !=# context.input
    6              0.000018     return
                              endif
                            
    2              0.000023   if context.event !=# 'Manual' && s:prev_completion.complete_position == getpos('.') && s:prev_completion.candidates ==# context.candidates
                                return
                              endif
                            
    2              0.000013   let s:prev_completion.event = context.event
    2              0.000012   let s:prev_completion.candidates = context.candidates
    2              0.000014   let s:prev_completion.complete_position = getpos('.')
                            
    2              0.000009   if context.event ==# 'Manual'
                                let context.event = ''
                              elseif !exists('g:deoplete#_saved_completeopt')
    2   0.000256   0.000042     call deoplete#mapping#_set_completeopt()
    2              0.000004   endif
                            
    2              0.000011   if g:deoplete#complete_method ==# 'complete'
    2              0.000028     call feedkeys("\<Plug>_", 'i')
    2              0.000009   elseif g:deoplete#complete_method ==# 'completefunc'
                                let &l:completefunc = 'deoplete#mapping#_completefunc'
                                call feedkeys("\<C-x>\<C-u>", 'in')
                              elseif g:deoplete#complete_method ==# 'omnifunc'
                                let &l:omnifunc = 'deoplete#mapping#_completefunc'
                                call feedkeys("\<C-x>\<C-o>", 'in')
                              endif

FUNCTION  emmet#expandCursorExpr()
Called 1 time
Total time:   0.000113
 Self time:   0.000113

count  total (s)   self (s)
    1              0.000006   let expand = a:expand
    1              0.000009   if expand !~# '\${cursor}'
                                if a:mode ==# 2
                                  let expand = '${cursor}' . expand
                                else
                                  let expand .= '${cursor}'
                                endif
                              endif
    1              0.000018   let expand = substitute(expand, '\${\d\+:\?\([^}]\+\)}', '$select$$cursor$\1$select$', 'g')
    1              0.000013   let expand = substitute(expand, '\${\d\+}', '$select$$cursor$$select$', 'g')
    1              0.000013   let expand = substitute(expand, '\${cursor}', '$cursor$', '')
    1              0.000010   let expand = substitute(expand, '\${cursor}', '', 'g')
    1              0.000010   let expand = substitute(expand, '\${cursor}', '', 'g')
    1              0.000004   return expand

FUNCTION  gitgutter#sign#find_current_signs()
Called 6 times
Total time:   0.004374
 Self time:   0.003756

count  total (s)   self (s)
    6   0.000115   0.000072   let bufnr = gitgutter#utility#bufnr()
    6              0.000030   let gitgutter_signs = {}  " <line_number (string)>: {'id': <id (number)>, 'name': <name (string)>}
    6              0.000025   let other_signs = []      " [<line_number (number),...]
    6              0.000027   let dummy_sign_placed = 0
                            
    6              0.000034   redir => signs
    6              0.000219     silent execute "sign place buffer=" . bufnr
    6              0.000064   redir END
                            
   18              0.000203   for sign_line in filter(split(signs, '\n')[2:], 'v:val =~# "="')
                                " Typical sign line:  line=88 id=1234 name=GitGutterLineAdded
                                " We assume splitting is faster than a regexp.
   12              0.000380     let components  = split(sign_line)
   12              0.000149     let name        = split(components[2], '=')[1]
   12              0.000116     if name =~# 'GitGutterDummy'
                                  let dummy_sign_placed = 1
                                else
   12              0.000181       let line_number = str2nr(split(components[0], '=')[1])
   12              0.000094       if name =~# 'GitGutter'
   12              0.000147         let id = str2nr(split(components[1], '=')[1])
                                    " Remove orphaned signs (signs placed on lines which have been deleted).
                                    " (When a line is deleted its sign lingers.  Subsequent lines' signs'
                                    " line numbers are decremented appropriately.)
   12              0.000091         if has_key(gitgutter_signs, line_number)
    4              0.000328           execute "sign unplace" gitgutter_signs[line_number].id
    4              0.000013         endif
   12              0.000134         let gitgutter_signs[line_number] = {'id': id, 'name': name}
   12              0.000035       else
                                    call add(other_signs, line_number)
                                  endif
   12              0.000026     end
   12              0.000032   endfor
                            
    6   0.000279   0.000093   call gitgutter#utility#setbufvar(bufnr, 'dummy_sign', dummy_sign_placed)
    6   0.000302   0.000082   call gitgutter#utility#setbufvar(bufnr, 'gitgutter_signs', gitgutter_signs)
    6   0.000247   0.000078   call gitgutter#utility#setbufvar(bufnr, 'other_signs', other_signs)

FUNCTION  <SNR>72_InitColor()
Called 5 times
Total time:   0.001691
 Self time:   0.001691

count  total (s)   self (s)
    5              0.000101     if !g:indentLine_setColors
                                    return
                                endif
                            
    5              0.000035     if !exists("g:indentLine_color_term")
    5              0.000023         if &background ==# "light"
    5              0.000028             let term_color = 249
    5              0.000012         else
                                        let term_color = 239
                                    endif
    5              0.000011     else
                                    let term_color = g:indentLine_color_term
                                endif
                            
    5              0.000032     if !exists("g:indentLine_bgcolor_term")
    5              0.000024         let term_bgcolor = "NONE"
    5              0.000012     else
                                    let term_bgcolor = g:indentLine_bgcolor_term
                                endif
                            
    5              0.000028     if !exists("g:indentLine_color_gui")
    5              0.000019         if &background ==# "light"
    5              0.000022             let gui_color = "Grey70"
    5              0.000012         else
                                        let gui_color = "Grey30"
                                    endif
    5              0.000012     else
                                    let gui_color = g:indentLine_color_gui
                                endif
                            
    5              0.000028     if !exists("g:indentLine_bgcolor_gui")
    5              0.000022         let gui_bgcolor = "NONE"
    5              0.000011     else
                                    let gui_bgcolor = g:indentLine_bgcolor_gui
                                endif
                            
    5              0.000238     execute "highlight Conceal cterm=NONE ctermfg=" . term_color . " ctermbg=" . term_bgcolor
    5              0.000153     execute "highlight Conceal gui=NONE guifg=" . gui_color .  " guibg=" . gui_bgcolor
                            
    5              0.000020     if &term ==# "linux"
                                    if &background ==# "light"
                                        let tty_color = exists("g:indentLine_color_tty_light") ? g:indentLine_color_tty_light : 4
                                    else
                                        let tty_color = exists("g:indentLine_color_tty_dark") ? g:indentLine_color_tty_dark : 2
                                    endif
                                    execute "highlight Conceal cterm=bold ctermfg=" . tty_color .  " ctermbg=NONE"
                                endif

FUNCTION  lightline#update()
Called 7 times
Total time:   0.042274
 Self time:   0.001179

count  total (s)   self (s)
    7              0.000037   if s:_
                                call lightline#init()
                                call lightline#colorscheme()
                              endif
    7              0.000050   if !s:lightline.enable.statusline
                                return
                              endif
    7              0.000046   let w = winnr()
    7   0.041289   0.000194   let s = winnr('$') == 1 ? [lightline#statusline(0)] : [lightline#statusline(0), lightline#statusline(1)]
   17              0.000097   for n in range(1, winnr('$'))
   10              0.000277     call setwinvar(n, '&statusline', s[n!=w])
   10              0.000101     call setwinvar(n, 'lightline', n!=w)
   10              0.000030   endfor

FUNCTION  <SNR>72_Filter()
Called 8 times
Total time:   0.000499
 Self time:   0.000499

count  total (s)   self (s)
    8              0.000070     if index(g:indentLine_fileTypeExclude, &filetype) != -1
                                    return 0
                                endif
                            
    8              0.000063     if len(g:indentLine_fileType) != 0 && index(g:indentLine_fileType, &filetype) == -1
                                    return 0
                                endif
                            
    8              0.000043     for name in g:indentLine_bufNameExclude
                                    if matchstr(bufname(''), name) == bufname('')
                                        return 0
                                    endif
                                endfor
                            
    8              0.000022     return 1

FUNCTION  deoplete#mapping#_set_completeopt()
Called 2 times
Total time:   0.000214
 Self time:   0.000214

count  total (s)   self (s)
    2              0.000015   if exists('g:deoplete#_saved_completeopt')
                                return
                              endif
    2              0.000031   let g:deoplete#_saved_completeopt = &completeopt
    2              0.000041   set completeopt-=longest
    2              0.000017   set completeopt+=menuone
    2              0.000014   set completeopt-=menu
    2              0.000035   if &completeopt !~# 'noinsert\|noselect'
    2              0.000018     set completeopt+=noselect
    2              0.000005   endif

FUNCTION  GetCSSIndent()
Called 1 time
Total time:   0.001021
 Self time:   0.000303

count  total (s)   self (s)
    1              0.000033   let line = getline(v:lnum)
    1              0.000035   if line =~ '^\s*\*'
                                return cindent(v:lnum)
                              endif
                            
    1   0.000245   0.000085   let pnum = s:prevnonblanknoncomment(v:lnum - 1)
    1              0.000007   if pnum == 0
                                return 0
                              endif
                            
    1   0.000652   0.000094   return indent(pnum) + s:count_braces(pnum, 1) * shiftwidth() - s:count_braces(v:lnum, 0) * shiftwidth()

FUNCTION  <SNR>28_shellslash()
Called 10 times
Total time:   0.000453
 Self time:   0.000289

count  total (s)   self (s)
   10   0.000273   0.000108   if s:winshell()
                                return s:gsub(a:path,'\\','/')
                              else
   10              0.000039     return a:path
                              endif

FUNCTION  gitgutter#utility#use_known_shell()
Called 8 times
Total time:   0.000655
 Self time:   0.000655

count  total (s)   self (s)
    8              0.000073   if has('unix')
    8              0.000053     if &shell !=# 'sh'
    7              0.000060       let s:shell = &shell
    7              0.000062       let s:shellcmdflag = &shellcmdflag
    7              0.000042       let s:shellredir = &shellredir
    7              0.000073       let &shell = 'sh'
    7              0.000065       set shellcmdflag=-c
    7              0.000045       set shellredir=>%s\ 2>&1
    7              0.000019     endif
    8              0.000019   endif

FUNCTION  syntastic#util#Slash()
Called 1 time
Total time:   0.000026
 Self time:   0.000026

count  total (s)   self (s)
    1              0.000019     return (!exists('+shellslash') || &shellslash) ? '/' : '\'

FUNCTION  gitgutter#async#execute()
Called 6 times
Total time:   0.041082
 Self time:   0.040927

count  total (s)   self (s)
    6   0.000165   0.000114   let options = {   'stdoutbuffer': [],   'buffer': gitgutter#utility#bufnr() }
    6   0.000212   0.000108   let command = s:build_command(a:cmd)
                            
    6              0.000044   if has('nvim')
    6              0.040138     call jobstart(command, extend(options, {   'on_stdout': function('s:on_stdout_nvim'),   'on_stderr': function('s:on_stderr_nvim'),   'on_exit':   function('s:on_exit_nvim') }))
    6              0.000099   else
                                call job_start(command, {   'out_cb':   function('s:on_stdout_vim', options),   'err_cb':   function('s:on_stderr_vim', options),   'close_cb': function('s:on_exit_vim', options) })
                              endif

FUNCTION  SyntasticRefreshCursor()
Called 18 times
Total time:   0.000474
 Self time:   0.000474

count  total (s)   self (s)
   18              0.000266     if !exists('b:syntastic_private_messages') || empty(b:syntastic_private_messages)
                                    " file not checked
   18              0.000062         return
                                endif
                            
                                if !exists('b:syntastic_private_line')
                                    let b:syntastic_private_line = -1
                                endif
                                let l = line('.')
                                let current_messages = get(b:syntastic_private_messages, l, {})
                            
                                if !exists('b:syntastic_cursor_columns')
                                    let b:syntastic_cursor_columns = g:syntastic_cursor_columns
                                endif
                            
                                if b:syntastic_cursor_columns
                                    let c = virtcol('.')
                                    if !exists('b:syntastic_private_idx')
                                        let b:syntastic_private_idx = -1
                                    endif
                            
                                    if s:_is_same_index(l, b:syntastic_private_line, c, b:syntastic_private_idx, current_messages)
                                        return
                                    else
                                        let b:syntastic_private_line = l
                                    endif
                            
                                    if !empty(current_messages)
                                        let b:syntastic_private_idx = s:_find_index(c, current_messages)
                                        call syntastic#util#wideMsg(current_messages[b:syntastic_private_idx].text)
                                    else
                                        let b:syntastic_private_idx = -1
                                        echo
                                    endif
                                else
                                    if l == b:syntastic_private_line
                                        return
                                    endif
                                    let b:syntastic_private_line = l
                            
                                    if !empty(current_messages)
                                        call syntastic#util#wideMsg(current_messages[0].text)
                                    else
                                        echo
                                    endif
                                endif

FUNCTION  <SNR>28_buffer_spec()
Called 8 times
Total time:   0.000761
 Self time:   0.000404

count  total (s)   self (s)
    8              0.000070     let bufname = bufname(self['#'])
    8   0.000655   0.000298     return s:shellslash(bufname == '' ? '' : fnamemodify(bufname,':p'))

FUNCTION  deoplete#util#get_next_input()
Called 19 times
Total time:   0.003246
 Self time:   0.000462

count  total (s)   self (s)
   19   0.003179   0.000395   return getline('.')[len(deoplete#util#get_input(a:event)) :]

FUNCTION  <SNR>15_escape()
Called 4 times
Total time:   0.000113
 Self time:   0.000113

count  total (s)   self (s)
    4              0.000062   let path = fnameescape(a:path)
    4              0.000031   return s:is_win ? escape(path, '$') : path

FUNCTION  provider#python3#Call()
Called 24 times
Total time:   0.473563
 Self time:   0.274273

count  total (s)   self (s)
   24              0.000217   if s:err != ''
                                return
                              endif
   24              0.000199   if !exists('s:host')
    1              0.000011     let s:rpcrequest = function('rpcrequest')
                            
                                " Ensure that we can load the Python3 host before bootstrapping
    1              0.000004     try
    1   0.199331   0.000040       let s:host = remote#host#Require('legacy-python3-provider')
    1              0.000004     catch
                                  let s:err = v:exception
                                  echohl WarningMsg
                                  echomsg v:exception
                                  echohl None
                                  return
                                endtry
    1              0.000003   endif
   24              0.272083   return call(s:rpcrequest, insert(insert(a:args, 'python_'.a:method), s:host))

FUNCTION  gitgutter#sign#next_sign_id()
Called 9 times
Total time:   0.000187
 Self time:   0.000187

count  total (s)   self (s)
    9              0.000059   let next_id = s:next_sign_id
    9              0.000046   let s:next_sign_id += 1
    9              0.000031   return next_id

FUNCTION  gitgutter#utility#not_git_dir()
Called 18 times
Total time:   0.002039
 Self time:   0.001282

count  total (s)   self (s)
   18   0.001971   0.001214   return gitgutter#utility#full_path_to_directory_of_file() !~ '[/\\]\.git\($\|[/\\]\)'

FUNCTION  fugitive#detect()
Called 1 time
Total time:   0.007136
 Self time:   0.000465

count  total (s)   self (s)
    1              0.000009   if exists('b:git_dir') && (b:git_dir ==# '' || b:git_dir =~# '/$')
                                unlet b:git_dir
                              endif
    1              0.000005   if !exists('b:git_dir')
    1   0.002640   0.000025     let dir = fugitive#extract_git_dir(a:path)
    1              0.000004     if dir !=# ''
    1              0.000005       let b:git_dir = dir
    1   0.002048   0.000036       if empty(fugitive#buffer().path())
                                    silent! exe haslocaldir() ? 'lcd .' : 'cd .'
                                  endif
    1              0.000002     endif
    1              0.000002   endif
    1              0.000006   if exists('b:git_dir')
    1              0.000009     if exists('#User#FugitiveBoot')
                                  try
                                    let [save_mls, &modelines] = [&mls, 0]
                                    doautocmd User FugitiveBoot
                                  finally
                                    let &mls = save_mls
                                  endtry
                                endif
    1              0.000006     if !exists('g:fugitive_no_maps')
    1              0.000029       cnoremap <buffer> <expr> <C-R><C-G> fnameescape(<SID>recall())
    1              0.000016       nnoremap <buffer> <silent> y<C-G> :call setreg(v:register, <SID>recall())<CR>
    1              0.000002     endif
    1   0.000097   0.000011     let buffer = fugitive#buffer()
    1              0.000033     if expand('%:p') =~# '://'
                                  call buffer.setvar('&path', s:sub(buffer.getvar('&path'), '^\.%(,|$)', ''))
                                endif
    1   0.000034   0.000020     if stridx(buffer.getvar('&tags'), escape(b:git_dir, ', ')) == -1
    1              0.000017       if filereadable(b:git_dir.'/tags')
                                    call buffer.setvar('&tags', escape(b:git_dir.'/tags', ', ').','.buffer.getvar('&tags'))
                                  endif
    1              0.000026       if &filetype !=# '' && filereadable(b:git_dir.'/'.&filetype.'.tags')
                                    call buffer.setvar('&tags', escape(b:git_dir.'/'.&filetype.'.tags', ', ').','.buffer.getvar('&tags'))
                                  endif
    1              0.000002     endif
    1              0.000003     try
    1              0.000023       let [save_mls, &modelines] = [&mls, 0]
    1   0.000861   0.000024       call s:define_commands()
    1   0.001120   0.000013       doautocmd User Fugitive
    1              0.000003     finally
    1              0.000015       let &mls = save_mls
    1              0.000003     endtry
    1              0.000002   endif

FUNCTION  gitgutter#diff#is_added()
Called 4 times
Total time:   0.000038
 Self time:   0.000038

count  total (s)   self (s)
    4              0.000026   return a:from_count == 0 && a:to_count > 0

FUNCTION  deoplete#init#_context()
Called 19 times
Total time:   0.081700
 Self time:   0.045650

count  total (s)   self (s)
   19   0.003511   0.000398   let input = deoplete#util#get_input(a:event)
                            
   19   0.007359   0.000473   let [filetype, filetypes, same_filetypes] = deoplete#util#get_context_filetype(input, a:event)
                            
   19   0.000661   0.000363   let sources = deoplete#util#convert2list(a:sources)
   19              0.000162   if a:event !=# 'Manual' && empty(sources)
                                " Use default sources
   19   0.002002   0.000391     let sources = deoplete#util#get_buffer_config( filetype, 'b:deoplete_sources', 'g:deoplete#sources', '{}', [])
   19              0.000061   endif
                            
   19   0.002500   0.000665   let keyword_patterns = join(deoplete#util#convert2list(   deoplete#util#get_buffer_config(   filetype, 'b:deoplete_keyword_patterns',   'g:deoplete#keyword_patterns',   'g:deoplete#_keyword_patterns')), '|')
                            
                              " Convert keyword pattern.
   19   0.018529   0.000418   let pattern = deoplete#util#vimoption2python( &l:iskeyword . (&l:lisp ? ',-' : ''))
   19              0.000414   let keyword_patterns = substitute(keyword_patterns, '\\k', '\=pattern', 'g')
                            
   19   0.000680   0.000415   let event = (deoplete#util#get_prev_event() ==# 'Refresh') ? 'Manual' : a:event
                            
   19              0.000469   let width = winwidth(0) - col('.') + len(matchstr(input, '\w*$'))
                            
   19              0.000175   let bufname = bufname('%')
   19              0.001022   let bufpath = fnamemodify(bufname, ':p')
   19              0.000622   if &l:buftype =~# 'nofile' || !filereadable(bufpath)
    3              0.000018     let bufpath = ''
    3              0.000009   endif
                            
   19   0.042318   0.038389   return { 'changedtick': b:changedtick, 'event': event, 'input': input, 'is_windows': ((has('win32') || has('win64')) ? v:true : v:false), 'next_input': deoplete#util#get_next_input(a:event), 'complete_str': '', 'encoding': &encoding, 'position': getpos('.'), 'filetype': filetype, 'filetypes': filetypes, 'same_filetypes': same_filetypes, 'ignorecase': g:deoplete#enable_ignore_case, 'smartcase': g:deoplete#enable_smart_case, 'camelcase': g:deoplete#enable_camel_case, 'delay': g:deoplete#auto_complete_delay, 'sources': sources, 'keyword_patterns': keyword_patterns, 'max_abbr_width': (width * 2 / 3), 'max_kind_width': (width * 2 / 3), 'max_menu_width': (width * 2 / 3), 'runtimepath': &runtimepath, 'bufnr': bufnr('%'), 'bufname': bufname, 'bufpath': bufpath, 'bufsize': wordcount().bytes, 'cwd': getcwd(), 'vars': filter(copy(g:),       "stridx(v:key, 'deoplete#') == 0        && v:key !=# 'deoplete#_yarp'"), 'bufvars': filter(copy(b:), "stridx(v:key, 'deoplete_') == 0"), 'custom': deoplete#custom#get(), 'omni__omnifunc': &l:omnifunc, 'dict__dictionary': &l:dictionary, }

FUNCTION  77()
Called 6 times
Total time:   0.005525
 Self time:   0.003651

count  total (s)   self (s)
    6   0.000342   0.000104     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'notifiers: reset')
   36              0.000180     for type in self._enabled_types
   30              0.000772         let class = substitute(type, '\m.*', 'Syntastic\u&Notifier', '')
                            
                                    " reset notifiers regardless if they are enabled or not, since
                                    " the user might have disabled them since the last refresh();
                                    " notifiers MUST be prepared to deal with reset() when disabled
   30              0.000366         if has_key(g:{class}, 'reset')
   18   0.002029   0.000394             call self._notifier[type].reset(a:loclist)
   18              0.000052         endif
                            
                                    " also reset stamps
   30              0.000278         if index(s:_PERSISTENT_NOTIFIERS, type) > -1
   12              0.000153             let b:syntastic_private_{type}_stamp = []
   12              0.000036         endif
   30              0.000090     endfor

FUNCTION  10()
Called 35 times
Total time:   0.000264
 Self time:   0.000264

count  total (s)   self (s)
   35              0.000158     return self._name

FUNCTION  11()
Called 12 times
Total time:   0.000142
 Self time:   0.000142

count  total (s)   self (s)
   12              0.000101     return self._filetype . '/' . self._name

FUNCTION  12()
Called 6 times
Total time:   0.000943
 Self time:   0.000474

count  total (s)   self (s)
    6              0.000043     if a:0
                                    let self._exec = a:1
                                else
    6              0.000042         let suffix = self._name . '_exec'
    6   0.000737   0.000268         let self._exec = expand( syntastic#util#var(self._filetype . '_' . suffix, syntastic#util#var(suffix, self._exec_default)), 1 )
    6              0.000023     endif

FUNCTION  13()
Called 1 time
Total time:   0.000007
 Self time:   0.000007

count  total (s)   self (s)
    1              0.000005     return self._exec

FUNCTION  14()
Called 6 times
Total time:   0.000354
 Self time:   0.000115

count  total (s)   self (s)
    6   0.000335   0.000097     return syntastic#util#shescape(self._exec)

FUNCTION  15()
Called 6 times
Total time:   7.223615
 Self time:   0.001945

count  total (s)   self (s)
    6              0.000077     let checker_start = reltime()
    6   0.000164   0.000100     let name = self.getCName()
                            
    6              0.000038     if has_key(self, '_enable')
                                    let status = syntastic#util#var(self._enable, -1)
                                    if type(status) != type(0)
                                        call syntastic#log#error('checker ' . name . ': invalid value ' . strtrans(string(status)) . ' for g:syntastic_' . self._enable . '; try 0 or 1 instead')
                                        return []
                                    endif
                                    if status < 0
                                        call syntastic#log#error('checker ' . name . ': checks disabled for security reasons; ' . 'set g:syntastic_' . self._enable . ' to 1 to override')
                                    endif
                                    if status <= 0
                                        call syntastic#log#debug(g:_SYNTASTIC_DEBUG_TRACE, 'getLocList: checker ' . name . ' enabled but not forced')
                                        return []
                                    else
                                        call syntastic#log#debug(g:_SYNTASTIC_DEBUG_TRACE, 'getLocList: checker ' . name . ' forced')
                                    endif
                                endif
                            
    6              0.000022     try
    6   7.219480   0.000201         let list = self._locListFunc()
    6              0.000045         if self._exec !=# ''
    6   0.000322   0.000124             call syntastic#log#debug(g:_SYNTASTIC_DEBUG_TRACE, 'getLocList: checker ' . name . ' returned ' . v:shell_error)
    6              0.000015         endif
    6              0.000019     catch /\m\C^Syntastic: checker error$/
                                    let list = []
                                    if self._exec !=# ''
                                        call syntastic#log#error('checker ' . name . ' returned abnormal status ' . v:shell_error)
                                    else
                                        call syntastic#log#error('checker ' . name . ' aborted')
                                    endif
                                endtry
    6   0.000322   0.000082     call self._populateHighlightRegexes(list)
    6   0.000290   0.000089     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_LOCLIST, name . ' raw:', list)
    6   0.001593   0.000087     call self._quietMessages(list)
    6   0.000443   0.000261     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_TRACE, 'getLocList: checker ' . name . ' run in ' . split(reltimestr(reltime(checker_start)))[0] . 's')
    6              0.000041     return list

FUNCTION  16()
Called 6 times
Total time:   7.224745
 Self time:   0.000251

count  total (s)   self (s)
    6   7.224713   0.000219     return g:SyntasticLoclist.New(self.getLocListRaw())

FUNCTION  <SNR>39_BufWritePostHook()
Called 5 times
Total time:   6.056573
 Self time:   0.000507

count  total (s)   self (s)
    5   0.001648   0.000159     let buf = syntastic#util#fname2buf(a:fname)
    5   0.000454   0.000189     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_AUTOCOMMANDS, 'autocmd: BufWritePost, buffer ' . buf . ' = ' . string(a:fname))
    5   6.054429   0.000116     call s:UpdateErrors(buf, 1, [])

FUNCTION  syntastic#util#stamp()
Called 12 times
Total time:   0.000460
 Self time:   0.000460

count  total (s)   self (s)
   12              0.000417     return split( split(reltimestr(reltime(g:_SYNTASTIC_START)))[0], '\.' )

FUNCTION  100()
Called 1 time
Total time:   1.421469
 Self time:   0.000050

count  total (s)   self (s)
    1   1.421466   0.000046       return s:common_sink(self._action, a:lines)

FUNCTION  101()
Called 1 time
Total time:   0.000038
 Self time:   0.000038

count  total (s)   self (s)
    1              0.000010     if a:inplace && bufnr('') == self.buf
                                  if bufexists(self.pbuf)
                                    execute 'keepalt b' self.pbuf
                                  endif
                                  " No other listed buffer
                                  if bufnr('') == self.buf
                                    enew
                                  endif
                                endif

FUNCTION  102()
Called 1 time
Total time:   1.440466
 Self time:   0.000674

count  total (s)   self (s)
    1   0.000073   0.000041     if s:getpos() == self.ppos " {'window': 'enew'}
                                  for [opt, val] in items(self.winopts)
                                    execute 'let' opt '=' val
                                  endfor
                                  call self.switch_back(1)
                                else
    1              0.000009       if bufnr('') == self.buf
                                    " We use close instead of bd! since Vim does not close the split when
                                    " there's no other listed buffer (nvim +'set nobuflisted')
    1   0.009068   0.000286         close
    1              0.000003       endif
    1              0.000016       execute 'tabnext' self.ppos.tab
    1              0.000014       execute self.ppos.win.'wincmd w'
    1              0.000003     endif
                            
    1              0.000008     if bufexists(self.buf)
                                  execute 'bd!' self.buf
                                endif
                            
    1   0.000046   0.000024     if &lines == self.lines && &columns == self.columns && s:getpos() == self.ppos
    1              0.000015       execute self.winrest
    1              0.000003     endif
                            
    1   0.000092   0.000038     if !s:exit_handler(a:code, self.command, 1)
                                  return
                                endif
                            
    1   0.004842   0.000023     call s:pushd(self.dict)
    1   0.000384   0.000030     let lines = s:collect(self.temps)
    1   1.425706   0.000032     call s:callback(self.dict, lines)
    1   0.000088   0.000033     call self.switch_back(s:getpos() == self.ppos)

FUNCTION  gitgutter#sign#upsert_new_gitgutter_signs()
Called 6 times
Total time:   0.007906
 Self time:   0.007145

count  total (s)   self (s)
    6   0.000140   0.000092   let bufnr = gitgutter#utility#bufnr()
    6   0.000280   0.000090   let other_signs         = gitgutter#utility#getbufvar(bufnr, 'other_signs')
    6   0.000239   0.000084   let old_gitgutter_signs = gitgutter#utility#getbufvar(bufnr, 'gitgutter_signs')
                            
   18              0.000077   for line in a:modified_lines
   12              0.000075     let line_number = line[0]  " <number>
   12              0.000088     if index(other_signs, line_number) == -1  " don't clobber others' signs
   12   0.000384   0.000203       let name = gitgutter#utility#highlight_name_for_change(line[1])
   12              0.000090       if !has_key(old_gitgutter_signs, line_number)  " insert
    9   0.000306   0.000118         let id = gitgutter#sign#next_sign_id()
    9              0.005305         execute "sign place" id "line=" . line_number "name=" . name "buffer=" . bufnr
    9              0.000036       else  " update if sign has changed
    3              0.000020         let old_sign = old_gitgutter_signs[line_number]
    3              0.000014         if old_sign.name !=# name
                                      execute "sign place" old_sign.id "name=" . name "buffer=" . bufnr
                                    end
    3              0.000007       endif
   12              0.000026     endif
   12              0.000041   endfor
                              " At this point b:gitgutter_gitgutter_signs is out of date.

FUNCTION  deoplete#util#uniq()
Called 40 times
Total time:   0.018319
 Self time:   0.018319

count  total (s)   self (s)
   40              0.001157   let list = map(copy(a:list), '[v:val, v:val]')
   40              0.000282   let i = 0
   40              0.000206   let seen = {}
  278              0.001485   while i < len(list)
  238              0.001955     let key = string(list[i][1])
  238              0.001426     if has_key(seen, key)
   21              0.000147       call remove(list, i)
   21              0.000054     else
  217              0.001217       let seen[key] = 1
  217              0.000860       let i += 1
  217              0.000515     endif
  238              0.000600   endwhile
   40              0.000711   return map(list, 'v:val[0]')

FUNCTION  <SNR>130_on_exit_nvim()
Called 6 times
Total time:   0.131776
 Self time:   0.000567

count  total (s)   self (s)
                              " Backward compatibility for nvim < 0.2.0
    6              0.000091   if !has('nvim-0.2.0')
                                let current_buffer = gitgutter#utility#bufnr()
                                call gitgutter#utility#set_buffer(self.buffer)
                                if gitgutter#utility#is_active()
                                  call gitgutter#handle_diff(gitgutter#utility#stringify(self.stdoutbuffer))
                                endif
                                call gitgutter#utility#set_buffer(current_buffer)
                                return
                              endif
                            
    6   0.131420   0.000211   call s:buffer_exec(self.buffer, function('gitgutter#handle_diff', [gitgutter#utility#stringify(self.stdoutbuffer)]))

FUNCTION  20()
Called 6 times
Total time:   0.008723
 Self time:   0.000955

count  total (s)   self (s)
    6              0.000056     let basename = self._filetype . '_' . self._name . '_'
                            
    6              0.000028     let parts = []
    6   0.002002   0.000180     call extend(parts, self._getOpt(a:opts, basename, 'exe', self.getExecEscaped()))
    6   0.001437   0.000118     call extend(parts, self._getOpt(a:opts, basename, 'args', ''))
    6   0.002018   0.000181     call extend(parts, self._getOpt(a:opts, basename, 'fname', syntastic#util#shexpand('%')))
    6   0.001489   0.000109     call extend(parts, self._getOpt(a:opts, basename, 'post_args', ''))
    6   0.001520   0.000110     call extend(parts, self._getOpt(a:opts, basename, 'tail', ''))
                            
    6              0.000063     return join(parts)

FUNCTION  21()
Called 6 times
Total time:   0.001380
 Self time:   0.000391

count  total (s)   self (s)
    6   0.001013   0.000070     call self.syncExec()
                            
    6              0.000043     if !has_key(self, '_available')
    1              0.000005         let self._available = {}
    1              0.000002     endif
    6              0.000041     if !has_key(self._available, self._exec)
    1   0.000077   0.000032         let self._available[self._exec] = self._isAvailableFunc()
    1              0.000003     endif
                            
    6              0.000035     return self._available[self._exec]

FUNCTION  23()
Called 6 times
Total time:   0.000324
 Self time:   0.000111

count  total (s)   self (s)
    6   0.000305   0.000092     return syntastic#util#var(self._filetype . '_' . self._name . '_sort', 0)

FUNCTION  25()
Called 6 times
Total time:   0.001506
 Self time:   0.000883

count  total (s)   self (s)
                                " wildcard quiet_messages
    6   0.000336   0.000103     let quiet_filters = copy(syntastic#util#var('quiet_messages', {}))
    6              0.000047     if type(quiet_filters) != type({})
                                    call syntastic#log#warn('ignoring invalid syntastic_quiet_messages')
                                    unlet quiet_filters
                                    let quiet_filters = {}
                                endif
                            
                                " per checker quiet_messages
    6              0.000051     let name = self._filetype . '_' . self._name
    6              0.000022     try
    6   0.000347   0.000142         call extend( quiet_filters, copy(syntastic#util#var(name . '_quiet_messages', {})), 'force' )
    6              0.000023     catch /\m^Vim\%((\a\+)\)\=:E712/
                                    call syntastic#log#warn('ignoring invalid syntastic_' . name . '_quiet_messages')
                                endtry
                            
    6   0.000278   0.000092     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_LOCLIST, 'quiet_messages filter:', quiet_filters)
                            
    6              0.000031     if !empty(quiet_filters)
                                    call syntastic#util#dictFilter(a:errors, quiet_filters)
                                    call syntastic#log#debug(g:_SYNTASTIC_DEBUG_LOCLIST, 'filtered by quiet_messages:', a:errors)
                                endif

FUNCTION  26()
Called 6 times
Total time:   0.000240
 Self time:   0.000240

count  total (s)   self (s)
    6              0.000043     if has_key(self, '_highlightRegexFunc')
                                    for e in a:errors
                                        if e['valid']
                                            let term = self._highlightRegexFunc(e)
                                            if term !=# ''
                                                let e['hl'] = term
                                            endif
                                        endif
                                    endfor
                                endif

FUNCTION  29()
Called 12 times
Total time:   0.000585
 Self time:   0.000169

count  total (s)   self (s)
   12   0.000548   0.000132     return syntastic#util#var('echo_current_error')

FUNCTION  30()
Called 6 times
Total time:   0.004907
 Self time:   0.000732

count  total (s)   self (s)
    6   0.000455   0.000109     if self.enabled() && !a:loclist.isEmpty()
    6   0.000300   0.000118         call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'cursor: refresh')
    6   0.003737   0.000140         let b:syntastic_private_messages = copy(a:loclist.messages(bufnr('')))
    6              0.000040         let b:syntastic_private_line = -1
    6   0.000137   0.000088         let b:syntastic_cursor_columns = a:loclist.getCursorColumns()
    6              0.000068         autocmd! syntastic CursorMoved
    6              0.000068         autocmd syntastic CursorMoved * call SyntasticRefreshCursor()
    6              0.000017     endif

FUNCTION  31()
Called 6 times
Total time:   0.000548
 Self time:   0.000333

count  total (s)   self (s)
    6   0.000320   0.000104     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'cursor: reset')
    6              0.000074     autocmd! syntastic CursorMoved
    6              0.000055     unlet! b:syntastic_private_messages
    6              0.000048     let b:syntastic_private_line = -1

FUNCTION  33()
Called 12 times
Total time:   0.000738
 Self time:   0.000303

count  total (s)   self (s)
   12   0.000698   0.000264     return s:has_highlighting && syntastic#util#var('enable_highlighting')

FUNCTION  34()
Called 6 times
Total time:   0.001818
 Self time:   0.000975

count  total (s)   self (s)
    6   0.000492   0.000079     if self.enabled()
    6   0.000276   0.000092         call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'highlighting: refresh')
    6   0.000257   0.000071         call self._reset()
    6              0.000040         let buf = bufnr('')
    6   0.000187   0.000126         let issues = filter(a:loclist.copyRaw(), 'v:val["bufnr"] == buf')
    6              0.000030         for item in issues
                                        let group = 'Syntastic' . get(item, 'subtype', '') . ( item['type'] ==? 'E' ? 'Error' : 'Warning' )
                            
                                        " The function `Syntastic_{filetype}_{checker}_GetHighlightRegex` is
                                        " used to override default highlighting.
                                        if has_key(item, 'hl')
                                            call matchadd(group, '\%' . item['lnum'] . 'l' . item['hl'])
                                        elseif get(item, 'col', 0)
                                            if get(item, 'vcol', 0)
                                                let lastcol = virtcol([item['lnum'], '$'])
                                                let coltype = 'v'
                                            else
                                                let lastcol = col([item['lnum'], '$'])
                                                let coltype = 'c'
                                            endif
                                            let lcol = min([lastcol, item['col']])
                            
                                            call matchadd(group, '\%' . item['lnum'] . 'l\%' . lcol . coltype)
                                        endif
                                    endfor
    6              0.000016     endif

FUNCTION  35()
Called 6 times
Total time:   0.000774
 Self time:   0.000300

count  total (s)   self (s)
    6              0.000039     if s:has_highlighting
    6   0.000371   0.000101         call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'highlighting: reset')
    6   0.000295   0.000091         call self._reset()
    6              0.000018     endif

FUNCTION  38()
Called 13 times
Total time:   0.001786
 Self time:   0.001786

count  total (s)   self (s)
   13              0.000458     let newObj = copy(self)
                            
   13              0.000178     let llist = filter(copy(a:rawLoclist), 'v:val["valid"]')
                            
   19              0.000091     for e in llist
    6              0.000039         if get(e, 'type', '') ==# ''
                                        let e['type'] = 'E'
                                    endif
    6              0.000016     endfor
                            
   13              0.000081     let newObj._rawLoclist = llist
   13              0.000064     let newObj._name = ''
   13              0.000091     let newObj._owner = bufnr('')
   13              0.000068     let newObj._sorted = 0
   13              0.000084     let newObj._columns = g:syntastic_cursor_columns
                            
   13              0.000057     return newObj

FUNCTION  39()
Called 12 times
Total time:   0.001172
 Self time:   0.000826

count  total (s)   self (s)
   12              0.000111     let buf = a:0 ? a:1 : bufnr('')
   12   0.000505   0.000259     let loclist = syntastic#util#getbufvar(buf, 'syntastic_loclist', {})
   12              0.000133     if type(loclist) != type({}) || empty(loclist)
    1              0.000004         unlet! loclist
    1   0.000118   0.000018         let loclist = g:SyntasticLoclist.New([])
    1              0.000003     endif
   12              0.000044     return loclist

FUNCTION  <SNR>39_BufEnterHook()
Called 3 times
Total time:   1.296857
 Self time:   0.000635

count  total (s)   self (s)
    3   0.002162   0.000081     let buf = syntastic#util#fname2buf(a:fname)
    3   0.000251   0.000115     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_AUTOCOMMANDS, 'autocmd: BufEnter, buffer ' . buf . ' = ' . string(a:fname) . ', &buftype = ' . string(&buftype))
    3              0.000023     if buf > 0 && getbufvar(buf, '&buftype') ==# ''
    1              0.000012         let idx = index(reverse(copy(s:_check_stack)), buf)
    1              0.000003         if idx >= 0
    1              0.000008             if !has('vim_starting')
    1              0.000007                 call remove(s:_check_stack, -idx - 1)
    1   1.294035   0.000030                 call s:UpdateErrors(buf, 1, [])
    1              0.000003             endif
    1              0.000026         elseif &buftype ==# ''
                                        call s:notifiers.refresh(g:SyntasticLoclist.current())
                                    endif
    1              0.000004     elseif &buftype ==# 'quickfix'
                                    " TODO: this is needed because in recent versions of Vim lclose
                                    " can no longer be called from BufWinLeave
                                    " TODO: at this point there is no b:syntastic_loclist
                                    let loclist = filter(copy(getloclist(0)), 'v:val["valid"]')
                                    let owner = str2nr(getbufvar(buf, 'syntastic_owner_buffer'))
                                    let buffers = syntastic#util#unique(map(loclist, 'v:val["bufnr"]') + (owner ? [owner] : []))
                                    if !empty(get(w:, 'syntastic_loclist_set', [])) && !empty(loclist) && empty(filter( buffers, 'syntastic#util#bufIsActive(v:val)' ))
                                        call SyntasticLoclistHide()
                                    endif
                                endif

FUNCTION  <SNR>72_Setup()
Called 3 times
Total time:   0.001113
 Self time:   0.000240

count  total (s)   self (s)
    3              0.000017     if &filetype ==# ""
    2   0.000540   0.000033         call s:InitColor()
    2              0.000005     endif
                            
    3   0.000243   0.000051     if s:Filter() && g:indentLine_enabled || exists("b:indentLine_enabled") && b:indentLine_enabled
                                    call s:IndentLinesEnable()
                                endif
                            
    3   0.000219   0.000045     if s:Filter() && g:indentLine_leadingSpaceEnabled || exists("b:indentLine_leadingSpaceEnabled") && b:indentLine_leadingSpaceEnabled
                                    call s:LeadingSpaceEnable()
                                endif

FUNCTION  fzf#vim#files()
Called 1 time
Total time:   0.071070
 Self time:   0.000275

count  total (s)   self (s)
    1              0.000012   let args = {}
    1              0.000022   if !empty(a:dir)
                                if !isdirectory(expand(a:dir))
                                  return s:warn('Invalid directory')
                                endif
                                let slash = (s:is_win && !&shellslash) ? '\\' : '/'
                                let dir = substitute(a:dir, '[/\\]*$', slash, '')
                                let args.dir = dir
                              else
    1   0.000191   0.000043     let dir = s:shortpath()
    1              0.000005   endif
                            
    1              0.000026   let args.options = ['-m', '--prompt', strwidth(dir) < &columns / 2 - 20 ? dir : '> ']
    1   0.000114   0.000050   call s:merge_opts(args, get(g:, 'fzf_files_options', []))
    1   0.070629   0.000046   return s:fzf('files', args, a:000)

FUNCTION  emmet#util#getcurpos()
Called 1 time
Total time:   0.000035
 Self time:   0.000035

count  total (s)   self (s)
    1              0.000007   let pos = getpos('.')
    1              0.000008   if mode(0) ==# 'i' && pos[2] > 0
    1              0.000005     let pos[2] -=1
    1              0.000002   endif
    1              0.000003   return pos

FUNCTION  <SNR>39_BufReadPostHook()
Called 1 time
Total time:   0.000288
 Self time:   0.000073

count  total (s)   self (s)
    1   0.000201   0.000016     let buf = syntastic#util#fname2buf(a:fname)
    1              0.000006     if g:syntastic_check_on_open && buf > 0
    1   0.000052   0.000022         call syntastic#log#debug(g:_SYNTASTIC_DEBUG_AUTOCOMMANDS, 'autocmd: BufReadPost, buffer ' . buf . ' = ' . string(a:fname))
    1              0.000006         if index(s:_check_stack, buf) == -1
    1              0.000006             call add(s:_check_stack, buf)
    1              0.000003         endif
    1              0.000002     endif

FUNCTION  <SNR>39_BufWinEnterHook()
Called 2 times
Total time:   0.001122
 Self time:   0.000181

count  total (s)   self (s)
    2   0.000916   0.000038     let buf = syntastic#util#fname2buf(a:fname)
    2   0.000116   0.000053     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_AUTOCOMMANDS, 'autocmd: BufWinEnter, buffer ' . buf . ' = ' . string(a:fname) . ', &buftype = ' . string(&buftype))
    2              0.000015     if buf > 0 && getbufvar(buf, '&buftype') ==# ''
    1              0.000011         let idx = index(reverse(copy(s:_check_stack)), buf)
    1              0.000005         if idx >= 0 && !has('vim_starting')
                                        call remove(s:_check_stack, -idx - 1)
                                        call s:UpdateErrors(buf, 1, [])
                                    endif
    1              0.000002     endif

FUNCTION  42()
Called 30 times
Total time:   0.000295
 Self time:   0.000295

count  total (s)   self (s)
   30              0.000199     return empty(self._rawLoclist)

FUNCTION  43()
Called 12 times
Total time:   0.001055
 Self time:   0.000439

count  total (s)   self (s)
   12              0.000084     if !exists('self._stamp')
                                    let self._stamp = []
                                    return 0
                                endif
   12   0.000789   0.000172     return syntastic#util#compareLexi(self._stamp, a:stamp) > 0

FUNCTION  44()
Called 12 times
Total time:   0.000120
 Self time:   0.000120

count  total (s)   self (s)
   12              0.000083     return copy(self._rawLoclist)

FUNCTION  45()
Called 6 times
Total time:   0.000048
 Self time:   0.000048

count  total (s)   self (s)
    6              0.000029     return self._rawLoclist

FUNCTION  46()
Called 12 times
Total time:   0.002197
 Self time:   0.000477

count  total (s)   self (s)
   12   0.002156   0.000436     return syntastic#util#unique(map(copy(self._rawLoclist), 'str2nr(v:val["bufnr"])') + [self._owner])

FUNCTION  47()
Called 6 times
Total time:   0.000049
 Self time:   0.000049

count  total (s)   self (s)
    6              0.000030     return self._columns

FUNCTION  emmet#parseIntoTree()
Called 1 time
Total time:   0.060393
 Self time:   0.000053

count  total (s)   self (s)
    1              0.000006   let abbr = a:abbr
    1              0.000004   let type = a:type
    1   0.060375   0.000035   return emmet#lang#{emmet#lang#type(type)}#parseIntoTree(abbr, type)

FUNCTION  <SNR>7_LoadIndent()
Called 2 times
Total time:   0.002531
 Self time:   0.000969

count  total (s)   self (s)
    2              0.000016     if exists("b:undo_indent")
                                  exe b:undo_indent
                                  unlet! b:undo_indent b:did_indent
                                endif
    2              0.000018     let s = expand("<amatch>")
    2              0.000008     if s != ""
    2              0.000010       if exists("b:did_indent")
                            	unlet b:did_indent
                                  endif
                            
                                  " When there is a dot it is used to separate filetype names.  Thus for
                                  " "aaa.bbb" load "indent/aaa.vim" and then "indent/bbb.vim".
    4              0.000029       for name in split(s, '\.')
    2   0.002354   0.000792 	exe 'runtime! indent/' . name . '.vim'
    2              0.000007       endfor
    2              0.000005     endif

FUNCTION  deoplete#util#get_buffer_config()
Called 45 times
Total time:   0.003780
 Self time:   0.003780

count  total (s)   self (s)
   45              0.000482   let default_val = get(a:000, 0, '')
                            
   45              0.000349   if exists(a:buffer_var)
                                return {a:buffer_var}
                              endif
                            
   45              0.001053   let filetype = !has_key({a:user_var}, a:filetype) && !has_key(eval(a:default_var), a:filetype) ? '_' : a:filetype
                            
   45              0.000877   return get({a:user_var}, filetype,   get(eval(a:default_var), filetype, default_val))

FUNCTION  lightline#link()
Called 149 times
Total time:   0.030592
 Self time:   0.026237

count  total (s)   self (s)
  149              0.004208   let mode = get(s:lightline._mode_, a:0 ? a:1 : mode(), 'normal')
  149              0.000915   if s:mode == mode
  141              0.000629     return ''
                              endif
    8              0.000064   let s:mode = mode
    8              0.000064   if !has_key(s:highlight, mode)
    1   0.004374   0.000019     call lightline#highlight(mode)
    1              0.000002   endif
    8              0.000249   let types = map(s:uniq(sort(filter(values(s:lightline.component_type), 'v:val !=# "raw"'))), '[v:val, 1]')
   24              0.000255   for [p, l] in [['Left', len(s:lightline.active.left)], ['Right', len(s:lightline.active.right)]]
   88              0.000542     for [i, t] in map(range(0, l), '[v:val, 0]') + types
   72              0.000266       if i != l
   56              0.001634         exec printf('hi link Lightline%s_active_%s Lightline%s_%s_%s', p, i, p, mode, i)
   56              0.000135       endif
  400              0.002332       for [j, s] in map(range(0, l), '[v:val, 0]') + types
  328              0.001756         if i + 1 == j || t || s && i != l
  152              0.004217           exec printf('hi link Lightline%s_active_%s_%s Lightline%s_%s_%s_%s', p, i, j, p, mode, i, j)
  152              0.000352         endif
  328              0.000816       endfor
   72              0.000175     endfor
   16              0.000038   endfor
    8              0.000166   exec printf('hi link LightlineMiddle_active LightlineMiddle_%s', mode)
    8              0.000030   return ''

FUNCTION  <SNR>15_execute_term()
Called 1 time
Total time:   0.059449
 Self time:   0.008953

count  total (s)   self (s)
    1              0.000011   let winrest = winrestcmd()
    1              0.000006   let pbuf = bufnr('')
    1   0.023440   0.000026   let [ppos, winopts] = s:split(a:dict)
    1   0.000058   0.000012   call s:use_sh()
    1              0.000006   let b:fzf = a:dict
    1              0.000020   let fzf = { 'buf': bufnr(''), 'pbuf': pbuf, 'ppos': ppos, 'dict': a:dict, 'temps': a:temps, 'winopts': winopts, 'winrest': winrest, 'lines': &lines, 'columns': &columns, 'command': a:command }
    1              0.000006   function! fzf.switch_back(inplace)
                                if a:inplace && bufnr('') == self.buf
                                  if bufexists(self.pbuf)
                                    execute 'keepalt b' self.pbuf
                                  endif
                                  " No other listed buffer
                                  if bufnr('') == self.buf
                                    enew
                                  endif
                                endif
                              endfunction
    1              0.000004   function! fzf.on_exit(id, code, ...)
                                if s:getpos() == self.ppos " {'window': 'enew'}
                                  for [opt, val] in items(self.winopts)
                                    execute 'let' opt '=' val
                                  endfor
                                  call self.switch_back(1)
                                else
                                  if bufnr('') == self.buf
                                    " We use close instead of bd! since Vim does not close the split when
                                    " there's no other listed buffer (nvim +'set nobuflisted')
                                    close
                                  endif
                                  execute 'tabnext' self.ppos.tab
                                  execute self.ppos.win.'wincmd w'
                                endif
                            
                                if bufexists(self.buf)
                                  execute 'bd!' self.buf
                                endif
                            
                                if &lines == self.lines && &columns == self.columns && s:getpos() == self.ppos
                                  execute self.winrest
                                endif
                            
                                if !s:exit_handler(a:code, self.command, 1)
                                  return
                                endif
                            
                                call s:pushd(self.dict)
                                let lines = s:collect(self.temps)
                                call s:callback(self.dict, lines)
                                call self.switch_back(s:getpos() == self.ppos)
                              endfunction
                            
    1              0.000003   try
    1   0.000037   0.000013     if s:present(a:dict, 'dir')
    1   0.003463   0.000053       execute 'lcd' s:escape(a:dict.dir)
    1              0.000003     endif
    1              0.000004     if s:is_win
                                  let fzf.temps.batchfile = s:fzf_tempname().'.bat'
                                  call writefile(s:wrap_cmds(a:command), fzf.temps.batchfile)
                                  let command = fzf.temps.batchfile
                                else
    1              0.000006       let command = a:command
    1              0.000003     endif
    1              0.000007     let command .= s:term_marker
    1              0.000007     if has('nvim')
    1              0.008359       call termopen(command, fzf)
    1              0.000014     else
                                  let fzf.buf = term_start([&shell, &shellcmdflag, command], {'curwin': 1, 'exit_cb': function(fzf.on_exit)})
                                  if !has('patch-8.0.1261') && !has('nvim') && !s:is_win
                                    call term_wait(fzf.buf, 20)
                                  endif
                                endif
    1              0.000004   finally
    1   0.000081   0.000032     if s:present(a:dict, 'dir')
    1   0.008456   0.000052       lcd -
    1              0.000004     endif
    1              0.000003   endtry
    1   0.000761   0.000057   setlocal nospell bufhidden=wipe nobuflisted nonumber
    1   0.014464   0.000019   setf fzf
    1              0.000004   startinsert
    1              0.000007   return []

FUNCTION  <SNR>15_fzf_call()
Called 12 times
Total time:   0.000176
 Self time:   0.000176

count  total (s)   self (s)
   12              0.000137     return call(a:fn, a:000)

FUNCTION  gitgutter#diff#parse_diff()
Called 6 times
Total time:   0.001459
 Self time:   0.000687

count  total (s)   self (s)
    6              0.000033   let hunks = []
   16              0.000113   for line in split(a:diff, '\n')
   10   0.000936   0.000164     let hunk_info = gitgutter#diff#parse_hunk(line)
   10              0.000052     if len(hunk_info) == 4
    4              0.000024       call add(hunks, hunk_info)
    4              0.000010     endif
   10              0.000023   endfor
    6              0.000021   return hunks

FUNCTION  51()
Called 6 times
Total time:   0.000063
 Self time:   0.000063

count  total (s)   self (s)
    6              0.000042     let self._name = a:name

FUNCTION  53()
Called 6 times
Total time:   0.000109
 Self time:   0.000109

count  total (s)   self (s)
    6              0.000087     let self._owner = type(a:buffer) == type(0) ? a:buffer : str2nr(a:buffer)

FUNCTION  54()
Called 6 times
Total time:   0.001708
 Self time:   0.000509

count  total (s)   self (s)
    6   0.000342   0.000113     let self._stamp = syntastic#util#stamp()
   18   0.001099   0.000128     for buf in self.getBuffers()
   12              0.000112         call setbufvar(buf, 'syntastic_loclist', self)
   12              0.000037     endfor

FUNCTION  55()
Called 6 times
Total time:   0.001665
 Self time:   0.000439

count  total (s)   self (s)
   17   0.001375   0.000148     for buf in self.getBuffers()
   11              0.000119         call setbufvar(buf, 'syntastic_loclist', {})
   11              0.000043     endfor

FUNCTION  syntastic#util#rawVar()
Called 133 times
Total time:   0.002117
 Self time:   0.002117

count  total (s)   self (s)
  133              0.001678     return get(b:, a:name, get(g:, a:name, a:0 ? a:1 : ''))

FUNCTION  59()
Called 12 times
Total time:   0.000760
 Self time:   0.000352

count  total (s)   self (s)
   12              0.000082     if !exists('self._cachedWarnings')
    6   0.000497   0.000089         let self._cachedWarnings = self.filter({'type': 'W'})
    6              0.000017     endif
   12              0.000043     return self._cachedWarnings

FUNCTION  deoplete#util#get_context_filetype()
Called 19 times
Total time:   0.006887
 Self time:   0.004625

count  total (s)   self (s)
   19              0.000198   if !exists('s:context_filetype')
                                let s:context_filetype = {}
                            
                                " Force context_filetype call.
                                try
                                  call context_filetype#get_filetype()
                                catch
                                  " Ignore error
                                endtry
                              endif
                            
   19              0.001117   if empty(s:context_filetype) || s:context_filetype.prev_filetype !=# &filetype || s:context_filetype.line != line('.') || s:context_filetype.bufnr != bufnr('.') || (a:input =~# '\W$' &&     substitute(a:input, '\s\zs\s\+$', '', '') !=#     substitute(s:context_filetype.input, '\s\zs\s\+$', '', '')) || (a:input =~# '\w$' &&     substitute(a:input, '\w\+$', '', '') !=#     substitute(s:context_filetype.input, '\w\+$', '', '')) || a:event ==# 'InsertEnter'
                            
   13              0.000124     let s:context_filetype.line = line('.')
   13              0.000216     let s:context_filetype.bufnr = bufnr('.')
   13              0.000091     let s:context_filetype.input = a:input
   13              0.000093     let s:context_filetype.prev_filetype = &filetype
   13              0.000358     let s:context_filetype.filetype = (exists('*context_filetype#get_filetype') ?   context_filetype#get_filetype() :   (&filetype ==# '' ? 'nothing' : &filetype))
   13   0.002836   0.000574     let s:context_filetype.filetypes = exists('*context_filetype#get_filetypes') ?   context_filetype#get_filetypes() :   &filetype ==# '' ? ['nothing'] :                     deoplete#util#uniq([&filetype]                          + split(&filetype, '\.'))
   13              0.000235     let s:context_filetype.same_filetypes = exists('*context_filetype#get_same_filetypes') ?   context_filetype#get_same_filetypes() : []
   13              0.000043   endif
   19              0.000196   return [ s:context_filetype.filetype,  s:context_filetype.filetypes, s:context_filetype.same_filetypes]

FUNCTION  emmet#unescapeDollarExpr()
Called 1 time
Total time:   0.000016
 Self time:   0.000016

count  total (s)   self (s)
    1              0.000011   return substitute(a:expand, '\\\$', '$', 'g')

FUNCTION  gitgutter#sign#add_dummy_sign()
Called 3 times
Total time:   0.034550
 Self time:   0.034343

count  total (s)   self (s)
    3   0.000056   0.000035   let bufnr = gitgutter#utility#bufnr()
    3   0.000116   0.000037   if !gitgutter#utility#getbufvar(bufnr, 'dummy_sign')
    3              0.034151     execute "sign place" s:dummy_sign_id "line=" . 9999 "name=GitGutterDummy buffer=" . bufnr
    3   0.000186   0.000080     call gitgutter#utility#setbufvar(bufnr, 'dummy_sign', 1)
    3              0.000009   endif

FUNCTION  <SNR>82_notify()
Called 19 times
Total time:   0.007622
 Self time:   0.007260

count  total (s)   self (s)
   19              0.000196   let a:context['rpc'] = a:event
                            
   19   0.000601   0.000239   if deoplete#util#has_yarp()
                                call g:deoplete#_yarp.notify(a:event, a:context)
                              else
   19              0.006244     call rpcnotify(g:deoplete#_channel_id, a:event, a:context)
   19              0.000100   endif

FUNCTION  gitgutter#utility#filename()
Called 7 times
Total time:   0.000091
 Self time:   0.000091

count  total (s)   self (s)
    7              0.000060   return fnamemodify(s:file, ':t')

FUNCTION  61()
Called 6 times
Total time:   0.003598
 Self time:   0.002602

count  total (s)   self (s)
    6              0.000043     if !exists('self._cachedMessages')
    6              0.000036         let self._cachedMessages = {}
                            
    6   0.000401   0.000117         let errors = self.errors() + self.warnings()
   12              0.000056         for e in errors
    6              0.000034             let b = e['bufnr']
    6              0.000028             let l = e['lnum']
                            
    6              0.000042             if !has_key(self._cachedMessages, b)
    6              0.000043                 let self._cachedMessages[b] = {}
    6              0.000016             endif
                            
    6              0.000045             if !has_key(self._cachedMessages[b], l)
    6              0.000048                 let self._cachedMessages[b][l] = [e]
    6              0.000026             elseif self._columns
                                            call add(self._cachedMessages[b][l], e)
                                        endif
    6              0.000016         endfor
                            
    6              0.000024         if self._columns
    6              0.000021             if !self._sorted
   12              0.000064                 for b in keys(self._cachedMessages)
   12              0.000063                     for l in keys(self._cachedMessages[b])
    6              0.000050                         if len(self._cachedMessages[b][l]) > 1
                                                        for e in self._cachedMessages[b][l]
                                                            call s:_set_screen_column(e)
                                                        endfor
                                                        call sort(self._cachedMessages[b][l], 's:_compare_error_items_by_columns')
                                                    endif
    6              0.000015                     endfor
    6              0.000027                 endfor
    6              0.000015             endif
                            
   12              0.000063             for b in keys(self._cachedMessages)
   12              0.000062                 for l in keys(self._cachedMessages[b])
    6   0.000849   0.000137                     call s:_remove_shadowed_items(self._cachedMessages[b][l])
    6              0.000016                 endfor
    6              0.000014             endfor
    6              0.000016         endif
    6              0.000014     endif
                            
    6              0.000052     return get(self._cachedMessages, a:buf, {})

FUNCTION  62()
Called 12 times
Total time:   0.000849
 Self time:   0.000670

count  total (s)   self (s)
   12   0.000471   0.000292     let conditions = values(map(copy(a:filters), 's:_translate(v:key, v:val)'))
   12              0.000138     let filter = len(conditions) == 1 ? conditions[0] : join(map(conditions, '"(" . v:val . ")"'), ' && ')
   12              0.000165     return filter(copy(self._rawLoclist), filter)

FUNCTION  <SNR>39_UpdateErrors()
Called 6 times
Total time:   7.348317
 Self time:   0.002647

count  total (s)   self (s)
    6   0.000414   0.000136     call syntastic#log#debugShowVariables(g:_SYNTASTIC_DEBUG_TRACE, 'version')
    6   0.000378   0.000132     call syntastic#log#debugShowOptions(g:_SYNTASTIC_DEBUG_TRACE, g:_SYNTASTIC_SHELL_OPTIONS)
    6   0.000328   0.000107     call syntastic#log#debugDump(g:_SYNTASTIC_DEBUG_VARIABLES)
    6   0.000383   0.000168     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_TRACE, 'UpdateErrors' . (a:auto_invoked ? ' (auto)' : '') . ': ' . (len(a:checker_names) ? join(a:checker_names) : 'default checkers'))
                            
    6   0.000613   0.000112     call s:modemap.synch()
                            
    6   0.001863   0.000125     if s:_skip_file(a:buf)
                                    return
                                endif
                            
    6   0.002156   0.000137     let run_checks = !a:auto_invoked || s:modemap.doAutoChecking(a:buf)
    6              0.000032     if run_checks
    6   7.318171   0.000240         call s:CacheErrors(a:buf, a:checker_names)
    6   0.000220   0.000108         call syntastic#util#setLastTick(a:buf)
    6              0.000026     elseif a:auto_invoked
                                    return
                                endif
                            
    6   0.000539   0.000087     let loclist = g:SyntasticLoclist.current(a:buf)
                            
    6              0.000044     if exists('*SyntasticCheckHook')
                                    call SyntasticCheckHook(loclist.getRaw())
                                endif
                            
                                " populate loclist and jump {{{3
    6   0.000283   0.000076     let do_jump = syntastic#util#var('auto_jump') + 0
    6              0.000030     if do_jump == 2
                                    let do_jump = loclist.getFirstError(1)
                                elseif do_jump == 3
                                    let do_jump = loclist.getFirstError()
                                elseif 0 > do_jump || do_jump > 3
                                    let do_jump = 0
                                endif
                            
    6   0.000262   0.000066     if syntastic#util#var('always_populate_loc_list') || do_jump
    6   0.001270   0.000070         call loclist.setloclist(1)
    6              0.000037         if run_checks && do_jump && !loclist.isEmpty()
                                        call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'loclist: jump')
                                        execute 'silent! lrewind ' . do_jump
                            
                                        " XXX: Vim doesn't call autocmd commands in a predictible
                                        " order, which can lead to missing filetype when jumping
                                        " to a new file; the following is a workaround for the
                                        " resulting brain damage
                                        if &filetype ==# ''
                                            silent! filetype detect
                                        endif
                                    endif
    6              0.000013     endif
                                " }}}3
                            
    6   0.020470   0.000114     call s:notifiers.refresh(loclist)

FUNCTION  66()
Called 6 times
Total time:   0.000501
 Self time:   0.000501

count  total (s)   self (s)
    6              0.000061     if exists('g:syntastic_mode_map')
                                    let self._mode = get(g:syntastic_mode_map, 'mode', 'active')
                                    let self._activeFiletypes = copy(get(g:syntastic_mode_map, 'active_filetypes', []))
                                    let self._passiveFiletypes = copy(get(g:syntastic_mode_map, 'passive_filetypes', []))
                                else
    6              0.000040         let self._mode = 'active'
    6              0.000067         let self._activeFiletypes = []
    6              0.000041         let self._passiveFiletypes = []
    6              0.000018     endif

FUNCTION  67()
Called 6 times
Total time:   0.001675
 Self time:   0.000564

count  total (s)   self (s)
    6   0.000395   0.000158     let registry = g:SyntasticRegistry.Instance()
    6   0.000762   0.000109     let fts = registry.resolveFiletypes(a:filetype)
                            
    6   0.000149   0.000085     if self.isPassive()
                                    return self._isOneFiletypeActive(fts)
                                else
    6   0.000243   0.000087         return self._noFiletypesArePassive(fts)
                                endif

FUNCTION  68()
Called 6 times
Total time:   0.002018
 Self time:   0.000343

count  total (s)   self (s)
    6              0.000071     let local_mode = getbufvar(a:buf, 'syntastic_mode')
    6              0.000049     if local_mode ==# 'active' || local_mode ==# 'passive'
                                    return local_mode ==# 'active'
                                endif
                            
    6   0.001798   0.000123     return self.allowsAutoChecking(getbufvar(a:buf, '&filetype'))

FUNCTION  69()
Called 6 times
Total time:   0.000065
 Self time:   0.000065

count  total (s)   self (s)
    6              0.000044     return self._mode ==# 'passive'

FUNCTION  deoplete#handler#_skip_next_completion()
Called 2 times
Total time:   0.000589
 Self time:   0.000151

count  total (s)   self (s)
    2              0.000024   if !exists('g:deoplete#_context')
                                return
                              endif
                            
    2   0.000488   0.000050   let input = deoplete#util#get_input('CompleteDone')
    2              0.000014   if input[-1:] !=# '/'
    2              0.000018     let g:deoplete#_context.input = input
    2              0.000006   endif

FUNCTION  <SNR>74_flatten_twice()
Called 20 times
Total time:   0.002596
 Self time:   0.002596

count  total (s)   self (s)
   20              0.000115   let ys = []
   64              0.000281   for xs in a:xss
  123              0.000382     for x in xs
   79              0.000351       let ys += x
   79              0.000247     endfor
   44              0.000104   endfor
   20              0.000082   return ys

FUNCTION  <SNR>85_fzf()
Called 1 time
Total time:   0.070583
 Self time:   0.000259

count  total (s)   self (s)
    1              0.000023   let [extra, bang] = [{}, 0]
    1              0.000011   if len(a:extra) <= 1
    1              0.000012     let first = get(a:extra, 0, 0)
    1              0.000012     if type(first) == s:TYPE.dict
                                  let extra = first
                                else
    1              0.000007       let bang = first
    1              0.000004     endif
    1              0.000007   elseif len(a:extra) == 2
                                let [extra, bang] = a:extra
                              else
                                throw 'invalid number of arguments'
                              endif
                            
    1              0.000017   let eopts  = has_key(extra, 'options') ? remove(extra, 'options') : ''
    1              0.000029   let merged = extend(copy(a:opts), extra)
    1   0.000075   0.000023   call s:merge_opts(merged, eopts)
    1   0.070332   0.000060   return fzf#run(s:wrap(a:name, merged, bang))

FUNCTION  deoplete#util#get_prev_event()
Called 19 times
Total time:   0.000265
 Self time:   0.000265

count  total (s)   self (s)
   19              0.000198   return get(g:deoplete#_context, 'event', '')

FUNCTION  <SNR>28_sub()
Called 20 times
Total time:   0.000585
 Self time:   0.000585

count  total (s)   self (s)
   20              0.000522   return substitute(a:str,'\v\C'.a:pat,a:rep,'')

FUNCTION  <SNR>15_defaults()
Called 1 time
Total time:   0.001189
 Self time:   0.000279

count  total (s)   self (s)
    1              0.000014   let rules = copy(get(g:, 'fzf_colors', {}))
    1   0.001158   0.000248   let colors = join(map(items(filter(map(rules, 'call("s:get_color", v:val)'), '!empty(v:val)')), 'join(v:val, ":")'), ',')
    1              0.000010   return empty(colors) ? '' : ('--color='.colors)

FUNCTION  74()
Called 6 times
Total time:   0.000156
 Self time:   0.000156

count  total (s)   self (s)
    6              0.000133     return empty(filter(copy(a:filetypes), 'index(self._passiveFiletypes, v:val) != -1'))

FUNCTION  76()
Called 6 times
Total time:   0.020356
 Self time:   0.004789

count  total (s)   self (s)
    6   0.001199   0.000203     if !syntastic#util#bufIsActive(bufnr('')) || (!a:loclist.isEmpty() && !a:loclist.isNewerThan([]))
                                    " loclist not fully constructed yet
                                    return
                                endif
                            
    6   0.000397   0.000219     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'notifiers: refresh')
   36              0.000148     for type in self._enabled_types
   30              0.000648         let class = substitute(type, '\m.*', 'Syntastic\u&Notifier', '')
   30   0.001680   0.000618         if !has_key(g:{class}, 'enabled') || self._notifier[type].enabled()
   24              0.000194             if index(s:_PERSISTENT_NOTIFIERS, type) > -1
                                            " refresh only if loclist has changed since last call
    6              0.000054                 if !exists('b:syntastic_private_' . type . '_stamp')
                                                let b:syntastic_private_{type}_stamp = []
                                            endif
    6   0.000614   0.000111                 if a:loclist.isNewerThan(b:syntastic_private_{type}_stamp) || a:loclist.isEmpty()
    6   0.004308   0.000088                     call self._notifier[type].refresh(a:loclist)
    6   0.000338   0.000106                     let b:syntastic_private_{type}_stamp = syntastic#util#stamp()
    6              0.000021                 endif
    6              0.000014             else
   18   0.008667   0.000290                 call self._notifier[type].refresh(a:loclist)
   18              0.000044             endif
   24              0.000094         endif
   30              0.000072     endfor

FUNCTION  <SNR>16_fzf_restore_colors()
Called 1 time
Total time:   0.000137
 Self time:   0.000137

count  total (s)   self (s)
    1              0.000012     if exists('#User#FzfStatusLine')
                                  doautocmd User FzfStatusLine
                                else
    1              0.000014       if $TERM !~ "256color"
    1              0.000025         highlight default fzf1 ctermfg=1 ctermbg=8 guifg=#E12672 guibg=#565656
    1              0.000015         highlight default fzf2 ctermfg=2 ctermbg=8 guifg=#BCDDBD guibg=#565656
    1              0.000013         highlight default fzf3 ctermfg=7 ctermbg=8 guifg=#D9D9D9 guibg=#565656
    1              0.000003       else
                                    highlight default fzf1 ctermfg=161 ctermbg=238 guifg=#E12672 guibg=#565656
                                    highlight default fzf2 ctermfg=151 ctermbg=238 guifg=#BCDDBD guibg=#565656
                                    highlight default fzf3 ctermfg=252 ctermbg=238 guifg=#D9D9D9 guibg=#565656
                                  endif
    1              0.000017       setlocal statusline=%#fzf1#\ >\ %#fzf2#fz%#fzf3#f
    1              0.000003     endif

FUNCTION  79()
Called 41 times
Total time:   0.001744
 Self time:   0.001744

count  total (s)   self (s)
   41              0.000507     if !exists('s:SyntasticRegistryInstance')
                                    let s:SyntasticRegistryInstance = copy(self)
                                    let s:SyntasticRegistryInstance._checkerMap = {}
                                endif
                            
   41              0.000256     return s:SyntasticRegistryInstance

FUNCTION  <SNR>15_has_any()
Called 2 times
Total time:   0.000187
 Self time:   0.000187

count  total (s)   self (s)
    9              0.000033   for key in a:keys
    7              0.000037     if has_key(a:dict, key)
                                  return 1
                                endif
    7              0.000020   endfor
    2              0.000006   return 0

FUNCTION  <SNR>82_vimoption2python()
Called 29 times
Total time:   0.034814
 Self time:   0.018756

count  total (s)   self (s)
   29              0.000191   let has_dash = 0
   29              0.000132   let patterns = []
  245              0.001387   for pattern in split(a:option, ',')
  216              0.000852     if pattern ==# ''
                                  " ,
   20              0.000096       call add(patterns, ',')
   20              0.000061     elseif pattern ==# '\'
                                  call add(patterns, '\\')
                                elseif pattern ==# '-'
   10              0.000041       let has_dash = 1
   10              0.000030     elseif pattern =~# '\d\+'
   48              0.001609       call add(patterns, substitute(pattern, '\d\+', '\=nr2char(submatch(0))', 'g'))
   48              0.000159     else
  138              0.000917       call add(patterns, pattern)
  138              0.000337     endif
  216              0.000569   endfor
                            
                              " Dash must be last.
   29              0.000106   if has_dash
   10              0.000051     call add(patterns, '-')
   10              0.000026   endif
                            
   29   0.016967   0.000910   return join(deoplete#util#uniq(patterns), '')

FUNCTION  emmet#getSettings()
Called 3 times
Total time:   0.000032
 Self time:   0.000032

count  total (s)   self (s)
    3              0.000019   return s:emmet_settings

FUNCTION  <SNR>78__isDebugEnabled_smart()
Called 198 times
Total time:   0.002342
 Self time:   0.002342

count  total (s)   self (s)
  198              0.001672     return and(g:syntastic_debug, a:level)

FUNCTION  80()
Called 35 times
Total time:   0.094748
 Self time:   0.003732

count  total (s)   self (s)
   35   0.002411   0.000905     let registry = g:SyntasticRegistry.Instance()
                            
   35              0.000298     if has_key(a:args, 'redirect')
    9              0.000269         let [ft, name] = split(a:args['redirect'], '/')
    9   0.024642   0.019727         call registry._loadCheckersFor(ft, 1)
                            
    9              0.000097         let clone = get(registry._checkerMap[ft], name, {})
    9              0.000049         if empty(clone)
                                        throw 'Syntastic: Checker ' . a:args['redirect'] . ' redirects to unregistered checker ' . ft . '/' . name
                                    endif
                            
    9   0.002390   0.000142         let checker = g:SyntasticChecker.New(a:args, clone)
    9              0.000022     else
   26   0.006876   0.000417         let checker = g:SyntasticChecker.New(a:args)
   26              0.000064     endif
   35   0.003868   0.000400     call registry._registerChecker(checker)

FUNCTION  81()
Called 6 times
Total time:   0.069574
 Self time:   0.001998

count  total (s)   self (s)
    6   0.000603   0.000100     let ftlist = self.resolveFiletypes(a:ftalias)
                            
    6              0.000087     let names = !empty(a:hints_list) ? a:hints_list : exists('b:syntastic_checkers') ? b:syntastic_checkers : []
                            
    6              0.000029     let cnames = []
    6              0.000032     if !empty(names)
                                    for name in names
                                        if name !~# '/'
                                            for ft in ftlist
                                                call add(cnames, ft . '/' . name)
                                            endfor
                                        else
                                            call add(cnames, name)
                                        endif
                                    endfor
                                else
   12              0.000053         for ft in ftlist
    6   0.000544   0.000113             call self._sanityCheck(ft)
    6              0.000130             let defs = exists('g:syntastic_' . ft . '_checkers') ? g:syntastic_{ft}_checkers : get(s:_DEFAULT_CHECKERS, ft, [])
    6              0.000185             call extend(cnames, map(copy(defs), 'stridx(v:val, "/") < 0 ? ft . "/" . v:val : v:val' ))
    6              0.000021         endfor
    6              0.000016     endif
    6   0.000935   0.000105     let cnames = syntastic#util#unique(cnames)
                            
   12   0.000991   0.000223     for ft in syntastic#util#unique(map( copy(cnames), 'v:val[: stridx(v:val, "/")-1]' ))
    6   0.064065   0.000101         call self._loadCheckersFor(ft, 0)
    6              0.000028     endfor
                            
    6   0.001175   0.000094     return self._filterCheckersByName(cnames)

FUNCTION  86()
Called 12 times
Total time:   0.001156
 Self time:   0.000536

count  total (s)   self (s)
   12   0.001113   0.000493     return map(split( get(g:syntastic_filetype_map, a:ftalias, a:ftalias), '\m\.' ), 's:_normalise_filetype(v:val)')

FUNCTION  88()
Called 35 times
Total time:   0.003469
 Self time:   0.002931

count  total (s)   self (s)
   35   0.000839   0.000565     let ft = a:checker.getFiletype()
   35              0.000283     if !has_key(self._checkerMap, ft)
    6              0.000046         let self._checkerMap[ft] = {}
    6              0.000065     endif
                            
   35   0.000682   0.000418     let name = a:checker.getName()
   35              0.000256     if has_key(self._checkerMap[ft], name)
                                    throw 'Syntastic: Duplicate syntax checker name: ' . ft . '/' . name
                                endif
                            
   35              0.000310     let self._checkerMap[ft][name] = a:checker

FUNCTION  89()
Called 12 times
Total time:   0.000782
 Self time:   0.000782

count  total (s)   self (s)
   12              0.000118     let sep_idx = stridx(a:cname, '/')
   12              0.000059     if sep_idx > 0
   12              0.000086         let ft = a:cname[: sep_idx-1]
   12              0.000081         let name = a:cname[sep_idx+1 :]
   12              0.000033     else
                                    let ft = &filetype
                                    let name = a:cname
                                endif
   12              0.000150     return get(self._checkerMap[ft], name, {})

FUNCTION  gitgutter#utility#set_buffer()
Called 32 times
Total time:   0.001480
 Self time:   0.001480

count  total (s)   self (s)
   32              0.000190   let s:bufnr = a:bufnr
   32              0.001113   let s:file = resolve(bufname(a:bufnr))

FUNCTION  syntastic#util#system()
Called 7 times
Total time:   7.208172
 Self time:   7.207476

count  total (s)   self (s)
    7              0.000055     let old_shell = &shell
    7              0.000066     let old_lc_messages = $LC_MESSAGES
    7              0.000044     let old_lc_all = $LC_ALL
                            
    7   0.000434   0.000135     let &shell = syntastic#util#var('shell')
    7              0.000071     let $LC_MESSAGES = 'C'
    7              0.000044     let $LC_ALL = ''
                            
    7              0.000034     let crashed = 0
    7              0.000052     let cmd_start = reltime()
    7              0.000025     try
    7              7.204595         let out = system(a:command)
    7              0.000110     catch
                                    let crashed = 1
                                    call syntastic#log#error('exception running system(' . string(a:command) . '): ' . v:exception)
                                    if syntastic#util#isRunningWindows()
                                        call syntastic#log#debug(g:_SYNTASTIC_DEBUG_CHECKERS, '$TMP = ' . string($TMP) . ', $TEMP = ' . string($TEMP))
                                    else
                                        call syntastic#log#debug(g:_SYNTASTIC_DEBUG_CHECKERS, '$TERM = ' . string($TERM))
                                        call syntastic#log#debug(g:_SYNTASTIC_DEBUG_CHECKERS, '$TMPDIR = ' . string($TMPDIR))
                                    endif
                                    call syntastic#log#debug(g:_SYNTASTIC_DEBUG_TRACE, '$PATH = ' . string($PATH))
                                    call syntastic#log#debug(g:_SYNTASTIC_DEBUG_TRACE, 'getcwd() = ' . string(getcwd()))
                                    call syntastic#log#debugShowOptions(g:_SYNTASTIC_DEBUG_TRACE, g:_SYNTASTIC_SHELL_OPTIONS)
                                    let out = ''
                                endtry
    7              0.000554     let cmd_time = split(reltimestr(reltime(cmd_start)))[0]
                            
    7              0.000129     let $LC_ALL = old_lc_all
    7              0.000057     let $LC_MESSAGES = old_lc_messages
                            
    7              0.000161     let &shell = old_shell
                            
    7              0.000070     if !crashed && exists('g:_SYNTASTIC_DEBUG_TRACE')
    7   0.000629   0.000233         call syntastic#log#debug(g:_SYNTASTIC_DEBUG_TRACE, 'system: command run in ' . cmd_time . 's')
    7              0.000018     endif
                            
    7              0.000040     return out

FUNCTION  gitgutter#debug#log()
Called 6 times
Total time:   0.000638
 Self time:   0.000638

count  total (s)   self (s)
    6              0.000047   if g:gitgutter_log
                                if s:new_log_session && gitgutter#async#available()
                                  if exists('*ch_logfile')
                                    call ch_logfile(s:channel_log, 'w')
                                  endif
                                endif
                            
                                execute 'redir >> '.s:log_file
                                  if s:new_log_session
                                    let s:start = reltime()
                                    silent echo "\n==== start log session ===="
                                  endif
                            
                                  let elapsed = reltimestr(reltime(s:start)).' '
                                  silent echo ''
                                  " callers excluding this function
                                  silent echo elapsed.expand('<sfile>')[:-22].':'
                                  silent echo elapsed.s:format_for_log(a:message)
                                  if a:0 && !empty(a:1)
                                    for msg in a:000
                                      silent echo elapsed.s:format_for_log(msg)
                                    endfor
                                  endif
                                redir END
                            
                                let s:new_log_session = 0
                              endif

FUNCTION  emmet#lang#exists()
Called 4 times
Total time:   0.002831
 Self time:   0.002831

count  total (s)   self (s)
    4              0.000027   if len(a:type) == 0
                                return 0
                              elseif has_key(s:exists, a:type)
    3              0.000015     return s:exists[a:type]
                              endif
    1              0.002713   let s:exists[a:type] = len(globpath(&rtp, 'autoload/emmet/lang/'.a:type.'.vim')) > 0
    1              0.000007   return s:exists[a:type]

FUNCTION  7()
Called 6 times
Total time:   0.000313
 Self time:   0.000313

count  total (s)   self (s)
    6              0.000063     let b:syntastic_private_balloons = {}
    6              0.000092     if has('balloon_eval')
                                    call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'balloons: reset')
                                    unlet! b:syntastic_private_balloons
                                    set noballooneval
                                endif

FUNCTION  <SNR>43_shellslash()
Called 2 times
Total time:   0.000051
 Self time:   0.000051

count  total (s)   self (s)
    2              0.000015   if exists('+shellslash') && !&shellslash
                                return s:gsub(a:path,'\\','/')
                              else
    2              0.000008     return a:path
                              endif

FUNCTION  <SNR>28_winshell()
Called 10 times
Total time:   0.000164
 Self time:   0.000164

count  total (s)   self (s)
   10              0.000134   return &shell =~? 'cmd' || exists('+shellslash') && !&shellslash

FUNCTION  emmet#util#searchRegion()
Called 1 time
Total time:   0.002271
 Self time:   0.002271

count  total (s)   self (s)
    1              0.001144   let b = searchpairpos(a:start, '', a:end, 'bcnW')
    1              0.000007   if b == [0, 0]
    1              0.001113     return [searchpairpos(a:start, '', a:end, 'bnW'), searchpairpos(a:start, '\%#', a:end, 'nW')]
                              else
                                return [b, searchpairpos(a:start, '', a:end. '', 'nW')]
                              endif

FUNCTION  syntastic#log#debugShowVariables()
Called 12 times
Total time:   0.000486
 Self time:   0.000336

count  total (s)   self (s)
   12   0.000365   0.000215     if !s:_isDebugEnabled(a:level)
   12              0.000043         return
                                endif
                            
                                let leader = s:_log_timestamp()
                                call s:_logRedirect(1)
                            
                                let vlist = type(a:names) == type('') ? [a:names] : a:names
                                for name in vlist
                                    let msg = s:_format_variable(name)
                                    if msg !=# ''
                                        echomsg leader . msg
                                    endif
                                endfor
                            
                                call s:_logRedirect(0)

FUNCTION  90()
Called 6 times
Total time:   0.001081
 Self time:   0.000299

count  total (s)   self (s)
    6   0.001054   0.000271     return filter( map(copy(a:cnames), 'self._findChecker(v:val)'), '!empty(v:val)' )

FUNCTION  92()
Called 6 times
Total time:   0.000431
 Self time:   0.000431

count  total (s)   self (s)
    6              0.000093     if exists('g:syntastic_' . a:filetype . '_checkers') && type(g:syntastic_{a:filetype}_checkers) != type([])
                            
                                    unlet! g:syntastic_{a:filetype}_checkers
                                    call syntastic#log#error('variable g:syntastic_' . a:filetype . '_checkers has to be a list of strings')
                                endif
                            
    6              0.000085     if exists('g:syntastic_' . a:filetype . '_checker') && !exists('g:syntastic_' . a:filetype . '_checkers') && type(g:syntastic_{a:filetype}_checker) == type('')
                            
                                    let g:syntastic_{a:filetype}_checkers = [g:syntastic_{a:filetype}_checker]
                                    call syntastic#log#oneTimeWarn('variable g:syntastic_' . a:filetype . '_checker is deprecated')
                                endif

FUNCTION  94()
Called 12 times
Total time:   0.000654
 Self time:   0.000236

count  total (s)   self (s)
   12   0.000615   0.000197     return has('signs') && syntastic#util#var('enable_signs')

FUNCTION  95()
Called 6 times
Total time:   0.004220
 Self time:   0.000657

count  total (s)   self (s)
    6   0.000264   0.000089     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'signs: refresh')
                            
    6   0.000246   0.000095     let old_signs = copy(self._bufSignIds())
    6   0.000384   0.000070     if self.enabled()
    6              0.000027         if !s:setup_done
    1   0.000421   0.000015             call self._setup()
    1              0.000009             let s:setup_done = 1
    1              0.000005             lockvar s:setup_done
    1              0.000002         endif
                            
    6   0.002372   0.000082         call self._signErrors(a:loclist)
    6              0.000013     endif
    6   0.000298   0.000070     call self._removeSigns(old_signs)

FUNCTION  96()
Called 1 time
Total time:   0.000406
 Self time:   0.000406

count  total (s)   self (s)
    1              0.000008     if has('signs')
    1              0.000045         if !hlexists('SyntasticErrorSign')
    1              0.000035             highlight link SyntasticErrorSign error
    1              0.000003         endif
    1              0.000018         if !hlexists('SyntasticWarningSign')
    1              0.000022             highlight link SyntasticWarningSign todo
    1              0.000002         endif
    1              0.000017         if !hlexists('SyntasticStyleErrorSign')
    1              0.000016             highlight link SyntasticStyleErrorSign SyntasticErrorSign
    1              0.000002         endif
    1              0.000017         if !hlexists('SyntasticStyleWarningSign')
    1              0.000016             highlight link SyntasticStyleWarningSign SyntasticWarningSign
    1              0.000002         endif
    1              0.000016         if !hlexists('SyntasticStyleErrorLine')
    1              0.000026             highlight link SyntasticStyleErrorLine SyntasticErrorLine
    1              0.000002         endif
    1              0.000016         if !hlexists('SyntasticStyleWarningLine')
    1              0.000026             highlight link SyntasticStyleWarningLine SyntasticWarningLine
    1              0.000002         endif
                            
                                    " define the signs used to display syntax and style errors/warns
    1              0.000022         execute 'sign define SyntasticError text=' . g:syntastic_error_symbol . ' texthl=SyntasticErrorSign linehl=SyntasticErrorLine'
    1              0.000015         execute 'sign define SyntasticWarning text=' . g:syntastic_warning_symbol . ' texthl=SyntasticWarningSign linehl=SyntasticWarningLine'
    1              0.000016         execute 'sign define SyntasticStyleError text=' . g:syntastic_style_error_symbol . ' texthl=SyntasticStyleErrorSign linehl=SyntasticStyleErrorLine'
    1              0.000016         execute 'sign define SyntasticStyleWarning text=' . g:syntastic_style_warning_symbol . ' texthl=SyntasticStyleWarningSign linehl=SyntasticStyleWarningLine'
    1              0.000003     endif

FUNCTION  97()
Called 6 times
Total time:   0.002291
 Self time:   0.000955

count  total (s)   self (s)
    6              0.000036     let loclist = a:loclist
    6   0.000125   0.000067     if !loclist.isEmpty()
                            
    6              0.000037         let buf = bufnr('')
    6              0.000031         if !bufloaded(buf)
                                        " signs can be placed only in loaded buffers
                                        return
                                    endif
                            
                                    " errors come first, so that they are not masked by warnings
    6   0.000741   0.000082         let issues = copy(loclist.errors())
    6   0.000703   0.000084         call extend(issues, loclist.warnings())
    6              0.000058         call filter(issues, 'v:val["bufnr"] == buf')
    6              0.000028         let seen = {}
                            
    6              0.000026         for i in issues
                                        if i['lnum'] > 0 && !has_key(seen, i['lnum'])
                                            let seen[i['lnum']] = 1
                            
                                            let sign_severity = i['type'] ==? 'W' ? 'Warning' : 'Error'
                                            let sign_subtype = get(i, 'subtype', '')
                                            let sign_type = 'Syntastic' . sign_subtype . sign_severity
                            
                                            execute 'sign place ' . s:next_sign_id . ' line=' . i['lnum'] . ' name=' . sign_type . ' buffer=' . i['bufnr']
                                            call add(self._bufSignIds(), s:next_sign_id)
                                            let s:next_sign_id += 1
                                        endif
                                    endfor
    6              0.000015     endif

FUNCTION  98()
Called 6 times
Total time:   0.000228
 Self time:   0.000228

count  total (s)   self (s)
    6              0.000044     if has('signs')
    6              0.000048         for s in reverse(copy(a:ids))
                                        execute 'sign unplace ' . s
                                        call remove(self._bufSignIds(), index(self._bufSignIds(), s))
                                    endfor
    6              0.000014     endif

FUNCTION  99()
Called 6 times
Total time:   0.000151
 Self time:   0.000151

count  total (s)   self (s)
    6              0.000050     if !exists('b:syntastic_private_sign_ids')
    1              0.000008         let b:syntastic_private_sign_ids = []
    1              0.000003     endif
    6              0.000025     return b:syntastic_private_sign_ids

FUNCTION  emmet#getDollarExprs()
Called 1 time
Total time:   0.000666
 Self time:   0.000327

count  total (s)   self (s)
    1              0.000006   let expand = a:expand
    1              0.000004   let dollar_list = []
    1              0.000005   let dollar_reg = '\%(\\\)\@<!\${\(\([^{}]\|\%(\\\)\@\<=[{}]\)\{}\)}'
    2              0.000006   while 1
    2              0.000076     let matcharr = matchlist(expand, dollar_reg)
    2              0.000013     if len(matcharr) > 0
    1              0.000007       let key = get(matcharr, 1)
    1              0.000009       if key !~# '^\d\+:'
    1              0.000011         let key = substitute(key, '\\{', '{', 'g')
    1              0.000009         let key = substitute(key, '\\}', '}', 'g')
    1   0.000364   0.000025         let value = emmet#getDollarValueByKey(key)
    1              0.000006         if type(value) ==# type('')
                                      let expr = get(matcharr, 0)
                                      call add(dollar_list, {'expr': expr, 'value': value})
                                    endif
    1              0.000002       endif
    1              0.000002     else
    1              0.000003       break
                                endif
    1              0.000038     let expand = substitute(expand, dollar_reg, '', '')
    1              0.000003   endwhile
    1              0.000004   return dollar_list

FUNCTION  <SNR>15_exit_handler()
Called 1 time
Total time:   0.000054
 Self time:   0.000054

count  total (s)   self (s)
    1              0.000008   if a:code == 130
                                return 0
                              elseif a:code > 1
                                call s:error('Error running ' . a:command)
                                if !empty(a:000)
                                  sleep
                                endif
                                return 0
                              endif
    1              0.000004   return 1

FUNCTION  emmet#lang#scss#parseIntoTree()
Called 1 time
Total time:   0.060237
 Self time:   0.000213

count  total (s)   self (s)
    1              0.000008   if a:abbr =~# '>'
                                return emmet#lang#html#parseIntoTree(a:abbr, a:type)
                              else
    1   0.060215   0.000191     return emmet#lang#css#parseIntoTree(a:abbr, a:type)
                              endif

FUNCTION  deoplete#init#_check_channel()
Called 19 times
Total time:   0.000235
 Self time:   0.000235

count  total (s)   self (s)
   19              0.000168   return !exists('g:deoplete#_initialized')

FUNCTION  <SNR>39__os_name()
Called 12 times
Total time:   0.000107
 Self time:   0.000107

count  total (s)   self (s)
   12              0.000066     return g:_SYNTASTIC_UNAME

FUNCTION  <SNR>28_buffer()
Called 4 times
Total time:   0.000323
 Self time:   0.000274

count  total (s)   self (s)
    4              0.000047   let buffer = {'#': bufnr(a:0 ? a:1 : '%')}
    4              0.000112   call extend(extend(buffer,s:buffer_prototype,'keep'),s:abstract_prototype,'keep')
    4   0.000118   0.000068   if buffer.getvar('git_dir') !=# ''
    4              0.000015     return buffer
                              endif
                              call s:throw('not a git repository: '.expand('%:p'))

FUNCTION  gitgutter#hunk#hunks()
Called 6 times
Total time:   0.000349
 Self time:   0.000136

count  total (s)   self (s)
    6   0.000330   0.000117   return gitgutter#utility#getbufvar(gitgutter#utility#bufnr(), 'hunks', [])

FUNCTION  <SNR>89_prevnonblanknoncomment()
Called 1 time
Total time:   0.000160
 Self time:   0.000160

count  total (s)   self (s)
    1              0.000016   let lnum = a:lnum
    1              0.000009   while lnum > 1
    1              0.000015     let lnum = prevnonblank(lnum)
    1              0.000012     let line = getline(lnum)
    1              0.000020     if line =~ '\*/'
                                  while lnum > 1 && line !~ '/\*'
                                    let lnum -= 1
                                  endwhile
                                  if line =~ '^\s*/\*'
                                    let lnum -= 1
                                  else
                                    break
                                  endif
                                else
    1              0.000004       break
                                endif
                              endwhile
    1              0.000007   return lnum

FUNCTION  gitgutter#diff#process_removed()
Called 1 time
Total time:   0.000030
 Self time:   0.000030

count  total (s)   self (s)
    1              0.000006   if a:to_line == 0
    1              0.000007     call add(a:modifications, [1, 'removed_first_line'])
    1              0.000003   else
                                call add(a:modifications, [a:to_line, 'removed'])
                              endif

FUNCTION  syntastic#util#getbufvar()
Called 12 times
Total time:   0.000246
 Self time:   0.000246

count  total (s)   self (s)
   12              0.000197     return a:0 ? s:_getbufvar(a:buf, a:name, a:1) : getbufvar(a:buf, a:name)

FUNCTION  <SNR>6_LoadFTPlugin()
Called 2 times
Total time:   0.005737
 Self time:   0.004451

count  total (s)   self (s)
    2              0.000022     if exists("b:undo_ftplugin")
                                  exe b:undo_ftplugin
                                  unlet! b:undo_ftplugin b:did_ftplugin
                                endif
                            
    2              0.000020     let s = expand("<amatch>")
    2              0.000009     if s != ""
    2              0.000059       if &cpo =~# "S" && exists("b:did_ftplugin")
                            	" In compatible mode options are reset to the global values, need to
                            	" set the local values also when a plugin was already used.
                            	unlet b:did_ftplugin
                                  endif
                            
                                  " When there is a dot it is used to separate filetype names.  Thus for
                                  " "aaa.bbb" load "aaa" and then "bbb".
    4              0.000045       for name in split(s, '\.')
    2   0.005451   0.004165 	exe 'runtime! ftplugin/' . name . '.vim ftplugin/' . name . '_*.vim ftplugin/' . name . '/*.vim'
    2              0.000016       endfor
    2              0.000006     endif

FUNCTION  fzf#shellescape()
Called 5 times
Total time:   0.000313
 Self time:   0.000250

count  total (s)   self (s)
    5              0.000055   let shell = get(a:000, 0, &shell)
    5              0.000051   if shell =~# 'cmd.exe$'
                                return s:shellesc_cmd(a:arg)
                              endif
    5   0.000128   0.000065   return s:fzf_call('shellescape', a:arg)

FUNCTION  gitgutter#sign#update_signs()
Called 6 times
Total time:   0.120191
 Self time:   0.001013

count  total (s)   self (s)
    6   0.004472   0.000098   call gitgutter#sign#find_current_signs()
                            
    6              0.000099   let new_gitgutter_signs_line_numbers = map(copy(a:modified_lines), 'v:val[0]')
    6   0.001174   0.000136   let obsolete_signs = gitgutter#sign#obsolete_gitgutter_signs_to_remove(new_gitgutter_signs_line_numbers)
                            
    6              0.000051   let flicker_possible = s:remove_all_old_signs && !empty(a:modified_lines)
    6              0.000021   if flicker_possible
    3   0.034601   0.000050     call gitgutter#sign#add_dummy_sign()
    3              0.000006   endif
                            
    6   0.071011   0.000116   call gitgutter#sign#remove_signs(obsolete_signs, s:remove_all_old_signs)
    6   0.008060   0.000154   call gitgutter#sign#upsert_new_gitgutter_signs(a:modified_lines)
                            
    6              0.000024   if flicker_possible
    3   0.000469   0.000054     call gitgutter#sign#remove_dummy_sign(0)
    3              0.000007   endif

FUNCTION  syntastic#util#isRunningWindows()
Called 6 times
Total time:   0.000150
 Self time:   0.000150

count  total (s)   self (s)
    6              0.000129     return has('win16') || has('win32') || has('win64')

FUNCTION  <SNR>15_wrap_cmds()
Called 1 time
Total time:   0.000009
 Self time:   0.000009

count  total (s)   self (s)
    1              0.000005     return a:cmds

FUNCTION  emmet#util#closePopup()
Called 1 time
Total time:   0.000022
 Self time:   0.000022

count  total (s)   self (s)
    1              0.000017   return pumvisible() ? "\<c-e>" : ''

FUNCTION  syntastic#postprocess#compressWhitespace()
Called 6 times
Total time:   0.001016
 Self time:   0.001016

count  total (s)   self (s)
   12              0.000070     for e in a:errors
    6              0.000105         let e['text'] = substitute(e['text'], "\001", '', 'g')
    6              0.000073         let e['text'] = substitute(e['text'], '\n', ' ', 'g')
    6              0.000149         let e['text'] = substitute(e['text'], '\m\s\{2,}', ' ', 'g')
    6              0.000148         let e['text'] = substitute(e['text'], '\m^\s\+', '', '')
    6              0.000141         let e['text'] = substitute(e['text'], '\m\s\+$', '', '')
    6              0.000021     endfor
                            
    6              0.000024     return a:errors

FUNCTION  deoplete#util#rpcnotify()
Called 19 times
Total time:   0.009383
 Self time:   0.001526

count  total (s)   self (s)
   19   0.000476   0.000242   if deoplete#init#_check_channel()
                                return ''
                              endif
                            
   19              0.000177   if !exists('s:logged') && !empty(g:deoplete#_logging)
                                call s:notify('deoplete_enable_logging', deoplete#init#_context(a:event, []))
                                let s:logged = 1
                              endif
                            
   19   0.007957   0.000335   call s:notify(a:event, a:context)
   19              0.000083   return ''

FUNCTION  <SNR>15_use_sh()
Called 2 times
Total time:   0.000099
 Self time:   0.000099

count  total (s)   self (s)
    2              0.000020   let [shell, shellslash] = [&shell, &shellslash]
    2              0.000008   if s:is_win
                                set shell=cmd.exe
                                set noshellslash
                              else
    2              0.000022     set shell=sh
    2              0.000006   endif
    2              0.000010   return [shell, shellslash]

FUNCTION  <SNR>72_LeadingSpaceDisable()
Called 2 times
Total time:   0.000098
 Self time:   0.000098

count  total (s)   self (s)
    2              0.000010     if g:indentLine_newVersion
    2              0.000016         if exists("w:indentLine_leadingSpaceId") && ! empty(w:indentLine_leadingSpaceId)
                                        for id in w:indentLine_leadingSpaceId
                                            try
                                                call matchdelete(id)
                                            catch /^Vim\%((\a\+)\)\=:E80[23]/
                                            endtry
                                        endfor
                                        let w:indentLine_leadingSpaceId = []
                                    endif
                            
    2              0.000005         return
                                endif
                            
                                let b:indentLine_leadingSpaceEnabled = 0
                                try
                                    syntax clear IndentLineLeadingSpace
                                catch /^Vim\%((\a\+)\)\=:E28/   " catch error E28
                                endtry

FUNCTION  gitgutter#sign#remove_dummy_sign()
Called 3 times
Total time:   0.000415
 Self time:   0.000217

count  total (s)   self (s)
    3   0.000073   0.000052   let bufnr = gitgutter#utility#bufnr()
    3   0.000135   0.000050   if gitgutter#utility#getbufvar(bufnr, 'dummy_sign') && (a:force || !g:gitgutter_sign_column_always)
    3              0.000035     execute "sign unplace" s:dummy_sign_id "buffer=" . bufnr
    3   0.000133   0.000041     call gitgutter#utility#setbufvar(bufnr, 'dummy_sign', 0)
    3              0.000008   endif

FUNCTION  fugitive#extract_git_dir()
Called 1 time
Total time:   0.002615
 Self time:   0.001515

count  total (s)   self (s)
    1   0.000084   0.000032   if s:shellslash(a:path) =~# '^fugitive://.*//'
                                return matchstr(s:shellslash(a:path), '\C^fugitive://\zs.\{-\}\ze//')
                              endif
    1              0.000012   if isdirectory(a:path)
                                let path = fnamemodify(a:path, ':p:s?[\/]$??')
                              else
    1              0.000053     let path = fnamemodify(a:path, ':p:h:s?[\/]$??')
    1              0.000003   endif
    1   0.000096   0.000053   let root = s:shellslash(resolve(path))
    1              0.000004   let previous = ""
    6              0.000028   while root !=# previous
    6              0.000075     if root =~# '\v^//%([^/]+/?)?$'
                                  " This is for accessing network shares from Cygwin Vim. There won't be
                                  " any git directory called //.git or //serverName/.git so let's avoid
                                  " checking for them since such checks are extremely slow.
                                  break
                                endif
    6              0.000074     if index(split($GIT_CEILING_DIRECTORIES, ':'), root) >= 0
                                  break
                                endif
    6              0.000054     if root ==# $GIT_WORK_TREE && fugitive#is_git_dir($GIT_DIR)
                                  return simplify(fnamemodify(expand($GIT_DIR), ':p:s?[\/]$??'))
                                endif
    6   0.000393   0.000075     if fugitive#is_git_dir($GIT_DIR)
                                  " Ensure that we've cached the worktree
                                  call s:configured_tree(simplify(fnamemodify(expand($GIT_DIR), ':p:s?[\/]$??')))
                                  if has_key(s:dir_for_worktree, root)
                                    return s:dir_for_worktree[root]
                                  endif
                                endif
    6   0.000296   0.000084     let dir = s:sub(root, '[\/]$', '') . '/.git'
    6              0.000077     let type = getftype(dir)
    6   0.000130   0.000046     if type ==# 'dir' && fugitive#is_git_dir(dir)
    1              0.000004       return dir
                                elseif type ==# 'link' && fugitive#is_git_dir(dir)
                                  return resolve(dir)
                                elseif type !=# '' && filereadable(dir)
                                  let line = get(readfile(dir, '', 1), 0, '')
                                  if line =~# '^gitdir: \.' && fugitive#is_git_dir(root.'/'.line[8:-1])
                                    return simplify(root.'/'.line[8:-1])
                                  elseif line =~# '^gitdir: ' && fugitive#is_git_dir(line[8:-1])
                                    return line[8:-1]
                                  endif
                                elseif fugitive#is_git_dir(root)
                                  return root
                                endif
    5              0.000024     let previous = root
    5              0.000041     let root = fnamemodify(root, ':h')
    5              0.000015   endwhile
                              return ''

FUNCTION  gitgutter#utility#directory_of_file()
Called 6 times
Total time:   0.000070
 Self time:   0.000070

count  total (s)   self (s)
    6              0.000051   return fnamemodify(s:file, ':h')

FUNCTION  <SNR>39__ignore_file()
Called 12 times
Total time:   0.000908
 Self time:   0.000908

count  total (s)   self (s)
   12              0.000510     let fname = fnamemodify(a:filename, ':p')
   12              0.000101     for pattern in g:syntastic_ignore_files
                                    if fname =~# pattern
                                        return 1
                                    endif
                                endfor
   12              0.000041     return 0

FUNCTION  27()
Called 30 times
Total time:   0.006965
 Self time:   0.002680

count  total (s)   self (s)
   30              0.000176     let ret = []
   30   0.001676   0.000599     call extend( ret, syntastic#util#argsescape(get(a:opts, a:name . '_before', '')) )
   30   0.002996   0.000893     call extend( ret, syntastic#util#argsescape(syntastic#util#var( a:basename . a:name, get(a:opts, a:name, a:default) )) )
   30   0.001660   0.000556     call extend( ret, syntastic#util#argsescape(get(a:opts, a:name . '_after', '')) )
                            
   30              0.000108     return ret

FUNCTION  syntastic#util#var()
Called 133 times
Total time:   0.005065
 Self time:   0.002948

count  total (s)   self (s)
  133   0.004637   0.002521     return call('syntastic#util#rawVar', ['syntastic_' . a:name] + a:000)

FUNCTION  <SNR>137_itemno()
Called 1 time
Total time:   0.000026
 Self time:   0.000026

count  total (s)   self (s)
    1              0.000007   let current = a:current
    1              0.000004   if current.basedirect > 0
    1              0.000003     if current.basevalue ==# 0
    1              0.000004       return a:itemno
                                else
                                  return current.basevalue - 1 + a:itemno
                                endif
                              else
                                if current.basevalue ==# 0
                                  return current.multiplier - 1 - a:itemno
                                else
                                  return current.multiplier + current.basevalue - 2 - a:itemno
                                endif
                              endif

FUNCTION  syntastic#util#compareLexi()
Called 12 times
Total time:   0.000616
 Self time:   0.000616

count  total (s)   self (s)
   12              0.000158     for idx in range(max([len(a:a), len(a:b)]))
   12              0.000116         let a_element = str2nr(get(a:a, idx, 0))
   12              0.000111         let b_element = str2nr(get(a:b, idx, 0))
   12              0.000057         if a_element != b_element
   12              0.000060             return a_element > b_element ? 1 : -1
                                    endif
                                endfor
                                " still here, thus everything matched
                                return 0

FUNCTION  <SNR>85_shortpath()
Called 1 time
Total time:   0.000148
 Self time:   0.000148

count  total (s)   self (s)
    1              0.000045   let short = fnamemodify(getcwd(), ':~:.')
    1              0.000018   if !has('win32unix')
    1              0.000016     let short = pathshorten(short)
    1              0.000004   endif
    1              0.000010   let slash = (s:is_win && !&shellslash) ? '\' : '/'
    1              0.000041   return empty(short) ? '~'.slash : short . (short =~ escape(slash, '\').'$' ? '' : slash)

FUNCTION  <SNR>15_fzf_exec()
Called 1 time
Total time:   0.000178
 Self time:   0.000122

count  total (s)   self (s)
    1              0.000007   if !exists('s:exec')
    1              0.000019     if executable(s:fzf_go)
    1              0.000006       let s:exec = s:fzf_go
    1              0.000004     elseif executable('fzf')
                                  let s:exec = 'fzf'
                                elseif s:is_win && !has('win32unix')
                                  call s:warn('fzf executable not found.')
                                  call s:warn('Download fzf binary for Windows from https://github.com/junegunn/fzf-bin/releases/')
                                  call s:warn('and place it as '.s:base_dir.'\bin\fzf.exe')
                                  throw 'fzf executable not found'
                                elseif !s:installed && executable(s:install) && input('fzf executable not found. Download binary? (y/n) ') =~? '^y'
                                  redraw
                                  echo
                                  call s:warn('Downloading fzf binary. Please wait ...')
                                  let s:installed = 1
                                  call system(s:install.' --bin')
                                  return s:fzf_exec()
                                else
                                  redraw
                                  throw 'fzf executable not found'
                                endif
    1              0.000003   endif
    1   0.000066   0.000010   return fzf#shellescape(s:exec)

FUNCTION  lightline#statusline()
Called 10 times
Total time:   0.041095
 Self time:   0.000490

count  total (s)   self (s)
   10              0.000084   if a:inactive && !has_key(s:highlight, 'inactive')
    1   0.004339   0.000032     call lightline#highlight('inactive')
    1              0.000003   endif
   10   0.036548   0.000250   return s:line(0, a:inactive)

FUNCTION  <SNR>28_define_commands()
Called 1 time
Total time:   0.000836
 Self time:   0.000836

count  total (s)   self (s)
   28              0.000127   for command in s:commands
   27              0.000536     exe 'command! -buffer '.command
   27              0.000065   endfor

FUNCTION  <SNR>85_merge_opts()
Called 2 times
Total time:   0.000116
 Self time:   0.000073

count  total (s)   self (s)
    2   0.000106   0.000063   return s:extend_opts(a:dict, a:eopts, 0)

FUNCTION  gitgutter#utility#command_in_directory_of_file()
Called 6 times
Total time:   0.000457
 Self time:   0.000176

count  total (s)   self (s)
    6   0.000431   0.000150   return 'cd '.gitgutter#utility#shellescape(gitgutter#utility#directory_of_file()).' && '.a:cmd

FUNCTION  <SNR>15_getpos()
Called 4 times
Total time:   0.000090
 Self time:   0.000090

count  total (s)   self (s)
    4              0.000074   return {'tab': tabpagenr(), 'win': winnr(), 'cnt': winnr('$'), 'tcnt': tabpagenr('$')}

FUNCTION  <SNR>74_line()
Called 10 times
Total time:   0.036298
 Self time:   0.015902

count  total (s)   self (s)
   10              0.000081   let _ = a:tabline ? '' : '%{lightline#link()}'
   10              0.000070   if s:lightline.palette == {}
                                call lightline#colorscheme()
                              endif
   10              0.000127   let [l, r] = a:tabline ? [s:lightline.tab_llen, s:lightline.tab_rlen] : [s:lightline.llen, s:lightline.rlen]
   10              0.000175   let [p, s] = a:tabline ? [s:lightline.tabline_separator, s:lightline.tabline_subseparator] : [s:lightline.separator, s:lightline.subseparator]
   10              0.000119   let [c, f, t, w] = [s:lightline.component, s:lightline.component_function, s:lightline.component_type, s:lightline.component_raw]
   10              0.000072   let mode = a:tabline ? 'tabline' : a:inactive ? 'inactive' : 'active'
   10              0.000129   let l_ = has_key(s:lightline, mode) ? s:lightline[mode].left : s:lightline.active.left
   10   0.007800   0.000249   let [lt, lc, ll] = s:expand(copy(l_))
   10              0.000151   let r_ = has_key(s:lightline, mode) ? s:lightline[mode].right : s:lightline.active.right
   10   0.008085   0.000243   let [rt, rc, rl] = s:expand(copy(r_))
   27              0.000182   for i in range(len(lt))
   17              0.000179     let _ .= '%#LightlineLeft_' . mode . '_' . ll[i] . '#'
   55              0.000262     for j in range(len(lt[i]))
   38              0.000919       let x = lc[i][j] ? lt[i][j] : has_key(f, lt[i][j]) ? (exists('*' . f[lt[i][j]]) ? '%{' . f[lt[i][j]] . '()}' : '%{exists("*' . f[lt[i][j]] . '")?' . f[lt[i][j]] . '():""}') : get(c, lt[i][j], '')
   38              0.000774       let _ .= has_key(t, lt[i][j]) && t[lt[i][j]] ==# 'raw' || get(w, lt[i][j]) || lc[i][j] ==# 2 || x ==# '' ? x : '%( ' . x . ' %)'
   38              0.000312       if j < len(lt[i]) - 1 && s.left !=# ''
   21   0.002970   0.000496         let _ .= s:subseparator(lt[i][(j):], s.left, lc[i][(j):])
   21              0.000066       endif
   38              0.000098     endfor
   17              0.000223     let _ .= '%#LightlineLeft_' . mode . '_' . ll[i] . '_' . ll[i + 1] . '#'
   17              0.000317     let _ .= i < l + len(lt) - len(l_) && ll[i] < l || ll[i] != ll[i + 1] ? p.left : len(lt[i]) ? s.left : ''
   17              0.000189   endfor
   10              0.000132   let _ .= '%#LightlineMiddle_' . mode . '#%='
   37              0.000194   for i in reverse(range(len(rt)))
   27              0.000379     let _ .= '%#LightlineRight_' . mode . '_' . rl[i] . '_' . rl[i + 1] . '#'
   27              0.000751     let _ .= i < r + len(rt) - len(r_) && rl[i] < r || rl[i] != rl[i + 1] ? p.right : len(rt[i]) ? s.right : ''
   27              0.000315     let _ .= '%#LightlineRight_' . mode . '_' . rl[i] . '#'
   68              0.000345     for j in range(len(rt[i]))
   41              0.001182       let x = rc[i][j] ? rt[i][j] : has_key(f, rt[i][j]) ? (exists('*' . f[rt[i][j]]) ? '%{' . f[rt[i][j]] . '()}' : '%{exists("*' . f[rt[i][j]] . '")?' . f[rt[i][j]] . '():""}') : get(c, rt[i][j], '')
   41              0.000896       let _ .= has_key(t, rt[i][j]) && t[rt[i][j]] ==# 'raw' || get(w, rt[i][j]) || rc[i][j] ==# 2 || x ==# '' ? x : '%( ' . x . ' %)'
   41              0.000327       if j < len(rt[i]) - 1 && s.right !=# ''
   14   0.002873   0.000344         let _ .= s:subseparator(rt[i][(j):], s.right, rc[i][(j):])
   14              0.000045       endif
   41              0.000123     endfor
   27              0.000075   endfor
   10              0.000053   return _

FUNCTION  emmet#expandAbbr()
Called 1 time
Total time:   0.071933
 Self time:   0.002048

count  total (s)   self (s)
    1   0.000193   0.000027   let type = emmet#getFileType()
    1   0.003704   0.000177   let rtype = emmet#lang#type(emmet#getFileType(1))
    1   0.000125   0.000028   let indent = emmet#getIndentation(type)
    1              0.000004   let expand = ''
    1              0.000003   let line = ''
    1              0.000003   let part = ''
    1              0.000003   let rest = ''
                            
    1   0.000374   0.000023   let filters = emmet#getFilters(type)
    1              0.000006   if len(filters) ==# 0
                                let filters = ['html']
                              endif
                            
    1              0.000003   if a:mode ==# 2
                                let leader = substitute(input('Tag: ', ''), '^\s*\(.*\)\s*$', '\1', 'g')
                                if len(leader) ==# 0
                                  return ''
                                endif
                                if leader =~# s:filtermx
                                  let filters = map(split(matchstr(leader, s:filtermx)[1:], '\s*[^\\]\zs,\s*'), 'substitute(v:val, "\\\\\\\\zs.\\\\ze", "&", "g")')
                                  let leader = substitute(leader, s:filtermx, '', '')
                                endif
                                if leader =~# '\*'
                                  let query = substitute(leader, '*', '*' . (a:lastline - a:firstline + 1), '')
                                  if query !~# '}\s*$' && query !~# '\$#'
                                    let query .= '>{$#}'
                                  endif
                                  if emmet#useFilter(filters, '/')
                                    let spl = emmet#splitFilterArg(filters)
                                    let fline = getline(a:firstline)
                                    let query = substitute(query, '>\{0,1}{\$#}\s*$', '{\\$column\\$}*' . len(split(fline, spl)), '')
                                  else
                                    let spl = ''
                                  endif
                                  let items = emmet#parseIntoTree(query, type).child
                                  let itemno = 0
                                  for item in items
                                    let inner = emmet#toString(item, type, 0, filters, 0, indent)
                                    let inner = substitute(inner, '\$#', '$line'.(itemno*(a:lastline - a:firstline + 1)/len(items)+1).'$', 'g')
                                    let expand .= inner
                                    let itemno = itemno + 1
                                  endfor
                                  if emmet#useFilter(filters, 'e')
                                    let expand = substitute(expand, '&', '\&amp;', 'g')
                                    let expand = substitute(expand, '<', '\&lt;', 'g')
                                    let expand = substitute(expand, '>', '\&gt;', 'g')
                                  endif
                                  let line = getline(a:firstline)
                                  let part = substitute(line, '^\s*', '', '')
                                  for n in range(a:firstline, a:lastline)
                                    let lline = getline(n)
                                    let lpart = substitute(lline, '^\s\+', '', '')
                                    if emmet#useFilter(filters, 't')
                                      let lpart = substitute(lpart, '^[0-9.-]\+\s\+', '', '')
                                      let lpart = substitute(lpart, '\s\+$', '', '')
                                    endif
                                    if emmet#useFilter(filters, '/')
                                      for column in split(lpart, spl)
                                        let expand = substitute(expand, '\$column\$', '\=column', '')
                                      endfor
                                    else
                                      let expand = substitute(expand, '\$line'.(n-a:firstline+1).'\$', '\=lpart', 'g')
                                    endif
                                  endfor
                                  let expand = substitute(expand, '\$line\d*\$', '', 'g')
                                  let expand = substitute(expand, '\$column\$', '', 'g')
                                  let content = join(getline(a:firstline, a:lastline), "\n")
                                  if stridx(expand, '$#') < len(expand)-2
                                    let expand = substitute(expand, '^\(.*\)\$#\s*$', '\1', '')
                                  endif
                                  let expand = substitute(expand, '\$#', '\=content', 'g')
                                else
                                  let str = ''
                                  if visualmode() ==# 'V'
                                    let line = getline(a:firstline)
                                    let lspaces = matchstr(line, '^\s*', '', '')
                                    let part = substitute(line, '^\s*', '', '')
                                    for n in range(a:firstline, a:lastline)
                                      if len(leader) > 0
                                        let line = getline(a:firstline)
                                        let spaces = matchstr(line, '^\s*', '', '')
                                        if len(spaces) >= len(lspaces)
                                          let str .= indent . getline(n)[len(lspaces):] . "\n"
                                        else
                                          let str .= getline(n) . "\n"
                                        endif
                                      else
                                        let lpart = substitute(getline(n), '^\s*', '', '')
                                        let str .= lpart . "\n"
                                      endif
                                    endfor
                                    if stridx(leader, '{$#}') ==# -1
                                      let leader .= '{$#}'
                                    endif
                                    let items = emmet#parseIntoTree(leader, type).child
                                  else
                                    let save_regcont = @"
                                    let save_regtype = getregtype('"')
                                    silent! normal! gvygv
                                    let str = @"
                                    call setreg('"', save_regcont, save_regtype)
                                    if stridx(leader, '{$#}') ==# -1
                                      let leader .= '{$#}'
                                    endif
                                    let items = emmet#parseIntoTree(leader, type).child
                                  endif
                                  for item in items
                                    let expand .= emmet#toString(item, type, 0, filters, 0, '')
                                  endfor
                                  if emmet#useFilter(filters, 'e')
                                    let expand = substitute(expand, '&', '\&amp;', 'g')
                                    let expand = substitute(expand, '<', '\&lt;', 'g')
                                    let expand = substitute(expand, '>', '\&gt;', 'g')
                                  endif
                                  if stridx(leader, '{$#}') !=# -1
                                    let expand = substitute(expand, '\$#', '\="\n" . str', 'g')
                                  endif
                                endif
                              elseif a:mode ==# 4
                                let line = getline('.')
                                let spaces = matchstr(line, '^\s*')
                                if line !~# '^\s*$'
                                  put =spaces.a:abbr
                                else
                                  call setline('.', spaces.a:abbr)
                                endif
                                normal! $
                                call emmet#expandAbbr(0, '')
                                return ''
                              else
    1              0.000007     let line = getline('.')
    1              0.000006     if col('.') < len(line)
                                  let line = matchstr(line, '^\(.*\%'.col('.').'c\)')
                                endif
    1              0.000003     if a:mode ==# 1
                                  let part = matchstr(line, '\([a-zA-Z0-9:_\-\@|]\+\)$')
                                else
    1              0.000027       let part = matchstr(line, '\(\S.*\)$')
    1   0.000044   0.000017       let ftype = emmet#lang#exists(type) ? type : 'html'
    1   0.002437   0.000153       let part = emmet#lang#{ftype}#findTokens(part)
    1              0.000013       let line = line[0: strridx(line, part) + len(part) - 1]
    1              0.000003     endif
    1              0.000006     if col('.') ==# col('$')
    1              0.000004       let rest = ''
    1              0.000002     else
                                  let rest = getline('.')[len(line):]
                                endif
    1              0.000004     let str = part
    1              0.000022     if str =~# s:filtermx
                                  let filters = split(matchstr(str, s:filtermx)[1:], '\s*,\s*')
                                  let str = substitute(str, s:filtermx, '', '')
                                endif
    1   0.060422   0.000029     let items = emmet#parseIntoTree(str, type).child
    2              0.000009     for item in items
    1   0.001564   0.000035       let expand .= emmet#toString(item, type, 0, filters, 0, indent)
    1              0.000003     endfor
    1   0.000073   0.000017     if emmet#useFilter(filters, 'e')
                                  let expand = substitute(expand, '&', '\&amp;', 'g')
                                  let expand = substitute(expand, '<', '\&lt;', 'g')
                                  let expand = substitute(expand, '>', '\&gt;', 'g')
                                endif
    1              0.000015     let expand = substitute(expand, '\$line\([0-9]\+\)\$', '\=submatch(1)', 'g')
    1              0.000003   endif
    1   0.000799   0.000023   let expand = emmet#expandDollarExpr(expand)
    1   0.000134   0.000021   let expand = emmet#expandCursorExpr(expand, a:mode)
    1              0.000005   if len(expand)
    1              0.000008     if has_key(s:emmet_settings, 'timezone') && len(s:emmet_settings.timezone)
                                  let expand = substitute(expand, '${datetime}', strftime('%Y-%m-%dT%H:%M:%S') . s:emmet_settings.timezone, 'g')
                                else
                                  " TODO: on windows, %z/%Z is 'Tokyo(Standard)'
    1              0.000121       let expand = substitute(expand, '${datetime}', strftime('%Y-%m-%dT%H:%M:%S %z'), 'g')
    1              0.000003     endif
    1   0.000042   0.000026     let expand = emmet#unescapeDollarExpr(expand)
    1              0.000006     if a:mode ==# 2 && visualmode() ==# 'v'
                                  if a:firstline ==# a:lastline
                                    let expand = substitute(expand, '[\r\n]\s*', '', 'g')
                                  else
                                    let expand = substitute(expand, '[\n]$', '', 'g')
                                  endif
                                  silent! normal! gv
                                  let col = col('''<')
                                  silent! normal! c
                                  let line = getline('.')
                                  let lhs = matchstr(line, '.*\%<'.col.'c.')
                                  let rhs = matchstr(line, '\%>'.(col-1).'c.*')
                                  let expand = lhs.expand.rhs
                                  let lines = split(expand, '\n')
                                  call setline(line('.'), lines[0])
                                  if len(lines) > 1
                                    call append(line('.'), lines[1:])
                                  endif
                                else
    1              0.000011       if line[:-len(part)-1] =~# '^\s\+$'
                                    let indent = line[:-len(part)-1]
                                  else
    1              0.000004         let indent = ''
    1              0.000002       endif
    1              0.000021       let expand = substitute(expand, '[\r\n]\s*$', '', 'g')
    1   0.000070   0.000013       if emmet#useFilter(filters, 's')
                                    let epart = substitute(expand, '[\r\n]\s*', '', 'g')
                                  else
    1              0.000023         let epart = substitute(expand, '[\r\n]', "\n" . indent, 'g')
    1              0.000003       endif
    1              0.000010       let expand = line[:-len(part)-1] . epart . rest
    1              0.000014       let lines = split(expand, '[\r\n]', 1)
    1              0.000004       if a:mode ==# 2
                                    silent! exe 'normal! gvc'
                                  endif
    1              0.000018       call setline('.', lines[0])
    1              0.000005       if len(lines) > 1
    1              0.000019         call append('.', lines[1:])
    1              0.000003       endif
    1              0.000002     endif
    1              0.000002   endif
    1              0.000005   if g:emmet_debug > 1
                                call getchar()
                              endif
    1              0.000023   if search('\ze\$\(cursor\|select\)\$', 'c')
    1              0.000008     let oldselection = &selection
    1              0.000015     let &selection = 'inclusive'
    1              0.000009     if foldclosed(line('.')) !=# -1
                                  silent! foldopen
                                endif
    1   0.000054   0.000019     let pos = emmet#util#getcurpos()
    1   0.000498   0.000039     let use_selection = emmet#getResource(type, 'use_selection', 0)
    1              0.000005     try
    1              0.000007       let l:gdefault = &gdefault
    1              0.000010       let &gdefault = 0
    1              0.000008       if use_selection && getline('.')[col('.')-1:] =~# '^\$select'
                                    let pos[2] += 1
                                    silent! s/\$select\$//
                                    let next = searchpos('.\ze\$select\$', 'nW')
                                    silent! %s/\$\(cursor\|select\)\$//g
                                    call emmet#util#selectRegion([pos[1:2], next])
                                    return "\<esc>gv"
                                  else
    1              0.000054         silent! %s/\$\(cursor\|select\)\$//g
    1              0.000009         silent! call setpos('.', pos)
    1              0.000006         if col('.') < col('$')
    1              0.000008           return "\<right>"
                                    endif
                                  endif
                                finally
    1              0.000009       let &gdefault = l:gdefault
    1              0.000004     endtry
                                let &selection = oldselection
                              endif
                              return ''

FUNCTION  fugitive#is_git_dir()
Called 12 times
Total time:   0.000792
 Self time:   0.000478

count  total (s)   self (s)
   12   0.000498   0.000185   let path = s:sub(a:path, '[\/]$', '') . '/'
   12              0.000234   return getfsize(path.'HEAD') > 10 && ( isdirectory(path.'objects') && isdirectory(path.'refs') || getftype(path.'commondir') ==# 'file')

FUNCTION  syntastic#util#bufVar()
Called 6 times
Total time:   0.000334
 Self time:   0.000200

count  total (s)   self (s)
    6   0.000292   0.000157     return call('syntastic#util#bufRawVar', [a:buf, 'syntastic_' . a:name] + a:000)

FUNCTION  <SNR>84_is_skip()
Called 9 times
Total time:   0.004181
 Self time:   0.000806

count  total (s)   self (s)
    9   0.003341   0.000161   if s:is_skip_text(a:event)
                                return 1
                              endif
                            
    9   0.000383   0.000189   let disable_auto_complete = deoplete#util#get_simple_buffer_config(   'b:deoplete_disable_auto_complete',   'g:deoplete#disable_auto_complete')
                            
    9              0.000165   if &paste || (a:event !=# 'Manual' && disable_auto_complete) || (&l:completefunc !=# '' && &l:buftype =~# 'nofile') || (a:event !=# 'InsertEnter' && mode() !=# 'i')
                                return 1
                              endif
                            
    9              0.000030   return 0

FUNCTION  <SNR>43_FindBundlerLock()
Called 2 times
Total time:   0.002544
 Self time:   0.002404

count  total (s)   self (s)
    2   0.000091   0.000040   let path = s:shellslash(a:path)
    2              0.000145   let fn = fnamemodify(path,':s?[\/]$??')
    2              0.000010   let ofn = ""
    2              0.000009   let nfn = fn
   29              0.000125   while fn != ofn
   29              0.000391     if filereadable(fn.'/Gemfile.lock')
    2   0.000160   0.000071       return s:sub(simplify(fnamemodify(fn,':p')),'[\\/]$','/Gemfile.lock')
                                elseif filereadable(fn.'/gems.locked')
                                  return s:sub(simplify(fnamemodify(fn,':p')),'[\\/]$','/gems.locked')
                                endif
   27              0.000119     let ofn = fn
   27              0.000255     let fn = fnamemodify(ofn,':h')
   27              0.000077   endwhile
                              return ''

FUNCTION  <SNR>16_fzf_vim_term()
Called 1 time
Total time:   0.000234
 Self time:   0.000097

count  total (s)   self (s)
    1              0.000009     if get(w:, 'airline_active', 0)
                                  let w:airline_disabled = 1
                                  autocmd BufWinLeave <buffer> let w:airline_disabled = 0
                                endif
    1              0.000023     autocmd WinEnter,ColorScheme <buffer> call s:fzf_restore_colors()
                            
    1              0.000014     setlocal nospell
    1   0.000167   0.000030     call s:fzf_restore_colors()

FUNCTION  <SNR>84_is_skip_text()
Called 9 times
Total time:   0.003180
 Self time:   0.001554

count  total (s)   self (s)
    9              0.000077   let context = g:deoplete#_context
    9   0.001565   0.000153   let input = deoplete#util#get_input(a:event)
                            
    9              0.000117   if has_key(context, 'input') && a:event !=# 'Manual' && a:event !=# 'Async' && input ==# context.input
                                return 1
                              endif
                            
    9              0.000100   let displaywidth = strdisplaywidth(input) + 1
    9              0.000170   if &l:formatoptions =~# '[tca]' && &l:textwidth > 0     && displaywidth >= &l:textwidth
                                if &l:formatoptions =~# '[ta]' || !empty(filter(deoplete#util#get_syn_names(),                  "v:val ==# 'Comment'"))
                                  return 1
                                endif
                              endif
                            
    9   0.000493   0.000278   let skip_chars = deoplete#util#get_simple_buffer_config(   'b:deoplete_skip_chars', 'g:deoplete#skip_chars')
                            
    9              0.000192   return (!pumvisible() && virtcol('.') != displaywidth) || (a:event !=# 'Manual' && input !=# ''     && index(skip_chars, input[-1:]) >= 0)

FUNCTION  emmet#getResource()
Called 6 times
Total time:   0.057450
 Self time:   0.002724

count  total (s)   self (s)
    6              0.000048   if exists('b:emmet_' . a:name)
                                return get(b:, 'emmet_' . a:name)
                              endif
    6              0.000026   let global = {}
    6              0.000049   if has_key(s:emmet_settings, '*') && has_key(s:emmet_settings['*'], a:name)
                                let global = extend(global, s:emmet_settings['*'][a:name])
                              endif
                            
    6              0.000033   if has_key(s:emmet_settings, a:type)
    6              0.000032     let types = [a:type]
    6              0.000014   else
                                let types = split(a:type, '\.')
                              endif
                            
    8              0.000041   for type in types
    6              0.000036     if !has_key(s:emmet_settings, type)
                                  continue
                                endif
    6              0.000026     let ret = a:default
                            
    6              0.000042     if has_key(s:emmet_settings[type], 'extends')
    6              0.000039       let extends = s:emmet_settings[type].extends
    6              0.000031       if type(extends) ==# 1
    6              0.000104         let tmp = split(extends, '\s*,\s*')
    6              0.000028         unlet! extends
    6              0.000027         let extends = tmp
    6              0.000014       endif
   12              0.000042       for ext in extends
    6              0.000063         if has_key(s:emmet_settings, ext) && has_key(s:emmet_settings[ext], a:name)
    2              0.000013           if type(ret) ==# 3 || type(ret) ==# 4
    1   0.054761   0.000034             call emmet#mergeConfig(ret, s:emmet_settings[ext][a:name])
    1              0.000003           else
    1              0.000008             let ret = s:emmet_settings[ext][a:name]
    1              0.000002           endif
    2              0.000006         endif
    6              0.000015       endfor
    6              0.000013     endif
                            
    6              0.000044     if has_key(s:emmet_settings[type], a:name)
                                  if type(ret) ==# 3 || type(ret) ==# 4
                                    call emmet#mergeConfig(ret, s:emmet_settings[type][a:name])
                                    return extend(global, ret)
                                  else
                                    return s:emmet_settings[type][a:name]
                                  endif
                                endif
    6              0.000028     if !empty(ret)
    4              0.000024       if type(ret) ==# 3 || type(ret) ==# 4
    1              0.000537         let ret = extend(global, ret)
    1              0.000003       endif
    4              0.000013       return ret
                                endif
    2              0.000005   endfor
                            
    2              0.000009   let ret = a:default
    2              0.000013   if type(ret) ==# 3 || type(ret) ==# 4
    1              0.000016     let ret = extend(global, ret)
    1              0.000003   endif
    2              0.000006   return ret

FUNCTION  deoplete#util#convert2list()
Called 45 times
Total time:   0.000691
 Self time:   0.000691

count  total (s)   self (s)
   45              0.000520   return type(a:expr) ==# type([]) ? a:expr : [a:expr]

FUNCTION  deoplete#util#vimoption2python()
Called 19 times
Total time:   0.018112
 Self time:   0.000424

count  total (s)   self (s)
   19   0.018046   0.000358   return '[a-zA-Z' . s:vimoption2python(a:option) . ']'

FUNCTION  gitgutter#utility#shellescape()
Called 19 times
Total time:   0.001231
 Self time:   0.000887

count  total (s)   self (s)
   19              0.000469   if a:arg =~ '^[A-Za-z0-9_/.-]\+$'
   13              0.000066     return a:arg
                              elseif &shell =~# 'cmd' || gitgutter#utility#using_xolox_shell()
                                return '"' . substitute(substitute(a:arg, '"', '""', 'g'), '%', '"%"', 'g') . '"'
                              else
    6              0.000041     return shellescape(a:arg)
                              endif

FUNCTION  lightline#mode()
Called 147 times
Total time:   0.002080
 Self time:   0.002080

count  total (s)   self (s)
  147              0.001521   return get(s:lightline.mode_map, mode(), '')

FUNCTION  <SNR>43_sub()
Called 2 times
Total time:   0.000089
 Self time:   0.000089

count  total (s)   self (s)
    2              0.000081   return substitute(a:str,'\v\C'.a:pat,a:rep,'')

FUNCTION  gitgutter#async#available()
Called 6 times
Total time:   0.000059
 Self time:   0.000059

count  total (s)   self (s)
    6              0.000032   return s:available

FUNCTION  csscomplete#CompleteCSS()
Called 5 times
Total time:   0.025976
 Self time:   0.025976

count  total (s)   self (s)
                            
    5              0.000039   if a:findstart
                                " We need whole line to proper checking
    3              0.000032     let line = getline('.')
    3              0.000022     let start = col('.') - 1
    3              0.000021     let compl_begin = col('.') - 2
    7              0.000116     while start >= 0 && line[start - 1] =~ '\%(\k\|-\)'
    4              0.000024       let start -= 1
    4              0.000020     endwhile
    3              0.000026     let b:after = line[compl_begin :]
    3              0.000026     let b:compl_context = line[0:compl_begin]
    3              0.000013     return start
                              endif
                            
                              " There are few chars important for context:
                              " ^ ; : { } /* */
                              " Where ^ is start of line and /* */ are comment borders
                              " Depending on their relative position to cursor we will know what should
                              " be completed. 
                              " 1. if nearest are ^ or { or ; current word is property
                              " 2. if : it is value (with exception of pseudo things)
                              " 3. if } we are outside of css definitions
                              " 4. for comments ignoring is be the easiest but assume they are the same
                              "    as 1. 
                              " 5. if @ complete at-rule
                              " 6. if ! complete important
    2              0.000014   if exists("b:compl_context")
    2              0.000013     let line = b:compl_context
    2              0.000009     let after = b:after
    2              0.000013     unlet! b:compl_context
    2              0.000005   else
                                let line = a:base
                              endif
                            
    2              0.000009   let res = []
    2              0.000008   let res2 = []
    2              0.000010   let borders = {}
                            
                              " Check last occurrence of sequence
                            
    2              0.000016   let openbrace  = strridx(line, '{')
    2              0.000014   let closebrace = strridx(line, '}')
    2              0.000013   let colon      = strridx(line, ':')
    2              0.000013   let semicolon  = strridx(line, ';')
    2              0.000013   let opencomm   = strridx(line, '/*')
    2              0.000013   let closecomm  = strridx(line, '*/')
    2              0.000013   let style      = strridx(line, 'style\s*=')
    2              0.000013   let atrule     = strridx(line, '@')
    2              0.000012   let exclam     = strridx(line, '!')
                            
    2              0.000008   if openbrace > -1
                                let borders[openbrace] = "openbrace"
                              endif
    2              0.000007   if closebrace > -1
                                let borders[closebrace] = "closebrace"
                              endif
    2              0.000006   if colon > -1
                                let borders[colon] = "colon"
                              endif
    2              0.000006   if semicolon > -1
                                let borders[semicolon] = "semicolon"
                              endif
    2              0.000006   if opencomm > -1
                                let borders[opencomm] = "opencomm"
                              endif
    2              0.000006   if closecomm > -1
                                let borders[closecomm] = "closecomm"
                              endif
    2              0.000006   if style > -1
                                let borders[style] = "style"
                              endif
    2              0.000006   if atrule > -1
                                let borders[atrule] = "atrule"
                              endif
    2              0.000006   if exclam > -1
                                let borders[exclam] = "exclam"
                              endif
                            
                            
    2              0.000019   if len(borders) == 0 || borders[max(keys(borders))] =~ '^\%(openbrace\|semicolon\|opencomm\|closecomm\|style\)$'
                                " Complete properties
                            
                            
    2              0.000072     let entered_property = matchstr(line, '.\{-}\zs[a-zA-Z-]*$')
                            
  624              0.002104     for m in s:values
  622              0.005232       if m =~? '^'.entered_property
   22              0.000170         call add(res, m . ':')
   22              0.000086       elseif m =~? entered_property
  291              0.002383         call add(res2, m . ':')
  291              0.000733       endif
  622              0.001617     endfor
                            
    2              0.000101     return res + res2
                            
                              elseif borders[max(keys(borders))] == 'colon'
                                " Get name of property
                                let prop = tolower(matchstr(line, '\zs[a-zA-Z-]*\ze\s*:[^:]\{-}$'))
                            
                                let wide_keywords = ["initial", "inherit", "unset"]
                                let color_values = ["transparent", "rgb(", "rgba(", "hsl(", "hsla(", "#"]
                                let border_style_values = ["none", "hidden", "dotted", "dashed", "solid", "double", "groove", "ridge", "inset", "outset"]
                                let border_width_values = ["thin", "thick", "medium"]
                                let list_style_type_values = ["decimal", "decimal-leading-zero", "arabic-indic", "armenian", "upper-armenian", "lower-armenian", "bengali", "cambodian", "khmer", "cjk-decimal", "devanagari", "georgian", "gujarati", "gurmukhi", "hebrew", "kannada", "lao", "malayalam", "mongolian", "myanmar", "oriya", "persian", "lower-roman", "upper-roman", "tamil", "telugu", "thai", "tibetan", "lower-alpha", "lower-latin", "upper-alpha", "upper-latin", "cjk-earthly-branch", "cjk-heavenly-stem", "lower-greek", "hiragana", "hiragana-iroha", "katakana", "katakana-iroha", "disc", "circle", "square", "disclosure-open", "disclosure-closed"]
                                let timing_functions = ["cubic-bezier(", "steps(", "linear", "ease", "ease-in", "ease-in-out", "ease-out", "step-start", "step-end"]
                            
                                if prop == 'all'
                                  let values = []
                                elseif prop == 'additive-symbols'
                                  let values = []
                                elseif prop == 'align-content'
                                  let values = ["flex-start", "flex-end", "center", "space-between", "space-around", "stretch"]
                                elseif prop == 'align-items'
                                  let values = ["flex-start", "flex-end", "center", "baseline", "stretch"]
                                elseif prop == 'align-self'
                                  let values = ["auto", "flex-start", "flex-end", "center", "baseline", "stretch"]
                                elseif prop == 'animation'
                                  let values = timing_functions + ["normal", "reverse", "alternate", "alternate-reverse"] + ["none", "forwards", "backwards", "both"] + ["running", "paused"]
                                elseif prop == 'animation-delay'
                                  let values = []
                                elseif prop == 'animation-direction'
                                  let values = ["normal", "reverse", "alternate", "alternate-reverse"]
                                elseif prop == 'animation-duration'
                                  let values = []
                                elseif prop == 'animation-fill-mode'
                                  let values = ["none", "forwards", "backwards", "both"]
                                elseif prop == 'animation-iteration-count'
                                  let values = []
                                elseif prop == 'animation-name'
                                  let values = []
                                elseif prop == 'animation-play-state'
                                  let values = ["running", "paused"]
                                elseif prop == 'animation-timing-function'
                                  let values = timing_functions
                                elseif prop == 'background-attachment'
                                  let values = ["scroll", "fixed"]
                                elseif prop == 'background-color'
                                  let values = color_values
                                elseif prop == 'background-image'
                                  let values = ["url(", "none"]
                                elseif prop == 'background-position'
                                  let vals = matchstr(line, '.*:\s*\zs.*')
                                  if vals =~ '^\%([a-zA-Z]\+\)\?$'
                                    let values = ["top", "center", "bottom"]
                                  elseif vals =~ '^[a-zA-Z]\+\s\+\%([a-zA-Z]\+\)\?$'
                                    let values = ["left", "center", "right"]
                                  else
                                    return []
                                  endif
                                elseif prop == 'background-repeat'
                                  let values = ["repeat", "repeat-x", "repeat-y", "no-repeat"]
                                elseif prop == 'background-size'
                                  let values = ["auto", "contain", "cover"]
                                elseif prop == 'background'
                                  let values = ["scroll", "fixed"] + color_values + ["url(", "none"] + ["top", "center", "bottom", "left", "right"] + ["repeat", "repeat-x", "repeat-y", "no-repeat"] + ["auto", "contain", "cover"]
                                elseif prop =~ 'border\%(-top\|-right\|-bottom\|-left\|-block-start\|-block-end\)\?$'
                                  let vals = matchstr(line, '.*:\s*\zs.*')
                                  if vals =~ '^\%([a-zA-Z0-9.]\+\)\?$'
                                    let values = border_width_values
                                  elseif vals =~ '^[a-zA-Z0-9.]\+\s\+\%([a-zA-Z]\+\)\?$'
                                    let values = border_style_values
                                  elseif vals =~ '^[a-zA-Z0-9.]\+\s\+[a-zA-Z]\+\s\+\%([a-zA-Z(]\+\)\?$'
                                    let values = color_values
                                  else
                                    return []
                                  endif
                                elseif prop =~ 'border-\%(top\|right\|bottom\|left\|block-start\|block-end\)-color'
                                  let values = color_values
                                elseif prop =~ 'border-\%(top\|right\|bottom\|left\|block-start\|block-end\)-style'
                                  let values = border_style_values
                                elseif prop =~ 'border-\%(top\|right\|bottom\|left\|block-start\|block-end\)-width'
                                  let values = border_width_values
                                elseif prop == 'border-color'
                                  let values = color_values
                                elseif prop == 'border-style'
                                  let values = border_style_values
                                elseif prop == 'border-width'
                                  let values = border_width_values
                                elseif prop == 'bottom'
                                  let values = ["auto"]
                                elseif prop == 'box-decoration-break'
                                  let values = ["slice", "clone"]
                                elseif prop == 'box-shadow'
                                  let values = ["inset"]
                                elseif prop == 'box-sizing'
                                  let values = ["border-box", "content-box"]
                                elseif prop =~ 'break-\%(before\|after\)'
                                  let values = ["auto", "always", "avoid", "left", "right", "page", "column", "region", "recto", "verso", "avoid-page", "avoid-column", "avoid-region"]
                                elseif prop == 'break-inside'
                                  let values = ["auto", "avoid", "avoid-page", "avoid-column", "avoid-region"]
                                elseif prop == 'caption-side'
                                  let values = ["top", "bottom"]
                                elseif prop == 'clear'
                                  let values = ["none", "left", "right", "both"]
                                elseif prop == 'clip'
                                  let values = ["auto", "rect("]
                                elseif prop == 'clip-path'
                                  let values = ["fill-box", "stroke-box", "view-box", "none"]
                                elseif prop == 'color'
                                  let values = color_values
                                elseif prop == 'columns'
                                  let values = []
                                elseif prop == 'column-count'
                                  let values = ['auto']
                                elseif prop == 'column-fill'
                                  let values = ['auto', 'balance']
                                elseif prop == 'column-rule-color'
                                  let values = color_values
                                elseif prop == 'column-rule-style'
                                  let values = border_style_values
                                elseif prop == 'column-rule-width'
                                  let values = border_width_values
                                elseif prop == 'column-rule'
                                  let vals = matchstr(line, '.*:\s*\zs.*')
                                  if vals =~ '^\%([a-zA-Z0-9.]\+\)\?$'
                                    let values = border_width_values
                                  elseif vals =~ '^[a-zA-Z0-9.]\+\s\+\%([a-zA-Z]\+\)\?$'
                                    let values = border_style_values
                                  elseif vals =~ '^[a-zA-Z0-9.]\+\s\+[a-zA-Z]\+\s\+\%([a-zA-Z(]\+\)\?$'
                                    let values = color_values
                                  else
                                    return []
                                  endif
                                elseif prop == 'column-span'
                                  let values = ["none", "all"]
                                elseif prop == 'column-width'
                                  let values = ["auto"]
                                elseif prop == 'content'
                                  let values = ["normal", "attr(", "open-quote", "close-quote", "no-open-quote", "no-close-quote"]
                                elseif prop =~ 'counter-\%(increment\|reset\)$'
                                  let values = ["none"]
                                elseif prop =~ 'cue\%(-after\|-before\)\=$'
                                  let values = ["url("]
                                elseif prop == 'cursor'
                                  let values = ["url(", "auto", "crosshair", "default", "pointer", "move", "e-resize", "ne-resize", "nw-resize", "n-resize", "se-resize", "sw-resize", "s-resize", "w-resize", "text", "wait", "help", "progress"]
                                elseif prop == 'direction'
                                  let values = ["ltr", "rtl"]
                                elseif prop == 'display'
                                  let values = ["inline", "block", "list-item", "inline-list-item", "run-in", "inline-block", "table", "inline-table", "table-row-group", "table-header-group", "table-footer-group", "table-row", "table-column-group", "table-column", "table-cell", "table-caption", "none", "flex", "inline-flex", "grid", "inline-grid", "ruby", "ruby-base", "ruby-text", "ruby-base-container", "ruby-text-container", "contents"]
                                elseif prop == 'elevation'
                                  let values = ["below", "level", "above", "higher", "lower"]
                                elseif prop == 'empty-cells'
                                  let values = ["show", "hide"]
                                elseif prop == 'fallback'
                                  let values = list_style_type_values
                                elseif prop == 'filter'
                                  let values = ["blur(", "brightness(", "contrast(", "drop-shadow(", "grayscale(", "hue-rotate(", "invert(", "opacity(", "sepia(", "saturate("]
                                elseif prop == 'flex-basis'
                                  let values = ["auto", "content"]
                                elseif prop == 'flex-flow'
                                  let values = ["row", "row-reverse", "column", "column-reverse", "nowrap", "wrap", "wrap-reverse"]
                                elseif prop == 'flex-grow'
                                  let values = []
                                elseif prop == 'flex-shrink'
                                  let values = []
                                elseif prop == 'flex-wrap'
                                  let values = ["nowrap", "wrap", "wrap-reverse"]
                                elseif prop == 'flex'
                                  let values = ["nowrap", "wrap", "wrap-reverse"] + ["row", "row-reverse", "column", "column-reverse", "nowrap", "wrap", "wrap-reverse"] + ["auto", "content"]
                                elseif prop == 'float'
                                  let values = ["left", "right", "none"]
                                elseif prop == 'font-family'
                                  let values = ["sans-serif", "serif", "monospace", "cursive", "fantasy"]
                                elseif prop == 'font-feature-settings'
                                  let values = ["normal", '"aalt"', '"abvf"', '"abvm"', '"abvs"', '"afrc"', '"akhn"', '"blwf"', '"blwm"', '"blws"', '"calt"', '"case"', '"ccmp"', '"cfar"', '"cjct"', '"clig"', '"cpct"', '"cpsp"', '"cswh"', '"curs"', '"cv', '"c2pc"', '"c2sc"', '"dist"', '"dlig"', '"dnom"', '"dtls"', '"expt"', '"falt"', '"fin2"', '"fin3"', '"fina"', '"flac"', '"frac"', '"fwid"', '"half"', '"haln"', '"halt"', '"hist"', '"hkna"', '"hlig"', '"hngl"', '"hojo"', '"hwid"', '"init"', '"isol"', '"ital"', '"jalt"', '"jp78"', '"jp83"', '"jp90"', '"jp04"', '"kern"', '"lfbd"', '"liga"', '"ljmo"', '"lnum"', '"locl"', '"ltra"', '"ltrm"', '"mark"', '"med2"', '"medi"', '"mgrk"', '"mkmk"', '"mset"', '"nalt"', '"nlck"', '"nukt"', '"numr"', '"onum"', '"opbd"', '"ordn"', '"ornm"', '"palt"', '"pcap"', '"pkna"', '"pnum"', '"pref"', '"pres"', '"pstf"', '"psts"', '"pwid"', '"qwid"', '"rand"', '"rclt"', '"rkrf"', '"rlig"', '"rphf"', '"rtbd"', '"rtla"', '"rtlm"', '"ruby"', '"salt"', '"sinf"', '"size"', '"smcp"', '"smpl"', '"ss01"', '"ss02"', '"ss03"', '"ss04"', '"ss05"', '"ss06"', '"ss07"', '"ss08"', '"ss09"', '"ss10"', '"ss11"', '"ss12"', '"ss13"', '"ss14"', '"ss15"', '"ss16"', '"ss17"', '"ss18"', '"ss19"', '"ss20"', '"ssty"', '"stch"', '"subs"', '"sups"', '"swsh"', '"titl"', '"tjmo"', '"tnam"', '"tnum"', '"trad"', '"twid"', '"unic"', '"valt"', '"vatu"', '"vert"', '"vhal"', '"vjmo"', '"vkna"', '"vkrn"', '"vpal"', '"vrt2"', '"zero"']
                                elseif prop == 'font-kerning'
                                  let values = ["auto", "normal", "none"]
                                elseif prop == 'font-language-override'
                                  let values = ["normal"]
                                elseif prop == 'font-size'
                                  let values = ["xx-small", "x-small", "small", "medium", "large", "x-large", "xx-large", "larger", "smaller"]
                                elseif prop == 'font-size-adjust'
                                  let values = []
                                elseif prop == 'font-stretch'
                                  let values = ["normal", "ultra-condensed", "extra-condensed", "condensed", "semi-condensed", "semi-expanded", "expanded", "extra-expanded", "ultra-expanded"]
                                elseif prop == 'font-style'
                                  let values = ["normal", "italic", "oblique"]
                                elseif prop == 'font-synthesis'
                                  let values = ["none", "weight", "style"]
                                elseif prop == 'font-variant-alternates'
                                  let values = ["normal", "historical-forms", "stylistic(", "styleset(", "character-variant(", "swash(", "ornaments(", "annotation("]
                                elseif prop == 'font-variant-caps'
                                  let values = ["normal", "small-caps", "all-small-caps", "petite-caps", "all-petite-caps", "unicase", "titling-caps"]
                                elseif prop == 'font-variant-asian'
                                  let values = ["normal", "ruby", "jis78", "jis83", "jis90", "jis04", "simplified", "traditional"]
                                elseif prop == 'font-variant-ligatures'
                                  let values = ["normal", "none", "common-ligatures", "no-common-ligatures", "discretionary-ligatures", "no-discretionary-ligatures", "historical-ligatures", "no-historical-ligatures", "contextual", "no-contextual"]
                                elseif prop == 'font-variant-numeric'
                                  let values = ["normal", "ordinal", "slashed-zero", "lining-nums", "oldstyle-nums", "proportional-nums", "tabular-nums", "diagonal-fractions", "stacked-fractions"]
                                elseif prop == 'font-variant-position'
                                  let values = ["normal", "sub", "super"]
                                elseif prop == 'font-variant'
                                  let values = ["normal", "historical-forms", "stylistic(", "styleset(", "character-variant(", "swash(", "ornaments(", "annotation("] + ["small-caps", "all-small-caps", "petite-caps", "all-petite-caps", "unicase", "titling-caps"] + ["ruby", "jis78", "jis83", "jis90", "jis04", "simplified", "traditional"] + ["none", "common-ligatures", "no-common-ligatures", "discretionary-ligatures", "no-discretionary-ligatures", "historical-ligatures", "no-historical-ligatures", "contextual", "no-contextual"] + ["ordinal", "slashed-zero", "lining-nums", "oldstyle-nums", "proportional-nums", "tabular-nums", "diagonal-fractions", "stacked-fractions"] + ["sub", "super"]
                                elseif prop == 'font-weight'
                                  let values = ["normal", "bold", "bolder", "lighter", "100", "200", "300", "400", "500", "600", "700", "800", "900"]
                                elseif prop == 'font'
                                  let values = ["normal", "italic", "oblique", "small-caps", "bold", "bolder", "lighter", "100", "200", "300", "400", "500", "600", "700", "800", "900", "xx-small", "x-small", "small", "medium", "large", "x-large", "xx-large", "larger", "smaller", "sans-serif", "serif", "monospace", "cursive", "fantasy", "caption", "icon", "menu", "message-box", "small-caption", "status-bar"]
                                elseif prop =~ '^\%(height\|width\)$'
                                  let values = ["auto", "border-box", "content-box", "max-content", "min-content", "available", "fit-content"]
                                elseif prop =~ '^\%(left\|rigth\)$'
                                  let values = ["auto"]
                                elseif prop == 'image-rendering'
                                  let values = ["auto", "crisp-edges", "pixelated"]
                                elseif prop == 'image-orientation'
                                  let values = ["from-image", "flip"]
                                elseif prop == 'ime-mode'
                                  let values = ["auto", "normal", "active", "inactive", "disabled"]
                                elseif prop == 'inline-size'
                                  let values = ["auto", "border-box", "content-box", "max-content", "min-content", "available", "fit-content"]
                                elseif prop == 'isolation'
                                  let values = ["auto", "isolate"]
                                elseif prop == 'justify-content'
                                  let values = ["flex-start", "flex-end", "center", "space-between", "space-around"]
                                elseif prop == 'letter-spacing'
                                  let values = ["normal"]
                                elseif prop == 'line-break'
                                  let values = ["auto", "loose", "normal", "strict"]
                                elseif prop == 'line-height'
                                  let values = ["normal"]
                                elseif prop == 'list-style-image'
                                  let values = ["url(", "none"]
                                elseif prop == 'list-style-position'
                                  let values = ["inside", "outside"]
                                elseif prop == 'list-style-type'
                                  let values = list_style_type_values
                                elseif prop == 'list-style'
                                  let values = list_style_type_values + ["inside", "outside"] + ["url(", "none"]
                                elseif prop == 'margin'
                                  let values = ["auto"]
                                elseif prop =~ 'margin-\%(right\|left\|top\|bottom\|block-start\|block-end\|inline-start\|inline-end\)$'
                                  let values = ["auto"]
                                elseif prop == 'marks'
                                  let values = ["crop", "cross", "none"]
                                elseif prop == 'mask'
                                  let values = ["url("]
                                elseif prop == 'mask-type'
                                  let values = ["luminance", "alpha"]
                                elseif prop == '\%(max\|min\)-\%(block\|inline\)-size'
                                  let values = ["auto", "border-box", "content-box", "max-content", "min-content", "available", "fit-content"]
                                elseif prop == '\%(max\|min\)-\%(height\|width\)'
                                  let values = ["auto", "border-box", "content-box", "max-content", "min-content", "available", "fit-content"]
                                elseif prop == '\%(max\|min\)-zoom'
                                  let values = ["auto"]
                                elseif prop == 'mix-blend-mode'
                                  let values = ["normal", "multiply", "screen", "overlay", "darken", "lighten", "color-dodge", "color-burn", "hard-light", "soft-light", "difference", "exclusion", "hue", "saturation", "color", "luminosity"]
                                elseif prop == 'opacity'
                                  let values = []
                                elseif prop == 'orientation'
                                  let values = ["auto", "portrait", "landscape"]
                                elseif prop == 'orphans'
                                  let values = []
                                elseif prop == 'outline-offset'
                                  let values = []
                                elseif prop == 'outline-color'
                                  let values = color_values
                                elseif prop == 'outline-style'
                                  let values = ["none", "hidden", "dotted", "dashed", "solid", "double", "groove", "ridge", "inset", "outset"]
                                elseif prop == 'outline-width'
                                  let values = ["thin", "thick", "medium"]
                                elseif prop == 'outline'
                                  let vals = matchstr(line, '.*:\s*\zs.*')
                                  if vals =~ '^\%([a-zA-Z0-9,()#]\+\)\?$'
                                    let values = color_values
                                  elseif vals =~ '^[a-zA-Z0-9,()#]\+\s\+\%([a-zA-Z]\+\)\?$'
                                    let values = ["none", "hidden", "dotted", "dashed", "solid", "double", "groove", "ridge", "inset", "outset"]
                                  elseif vals =~ '^[a-zA-Z0-9,()#]\+\s\+[a-zA-Z]\+\s\+\%([a-zA-Z(]\+\)\?$'
                                    let values = ["thin", "thick", "medium"]
                                  else
                                    return []
                                  endif
                                elseif prop == 'overflow-wrap'
                                  let values = ["normal", "break-word"]
                                elseif prop =~ 'overflow\%(-x\|-y\)\='
                                  let values = ["visible", "hidden", "scroll", "auto"]
                                elseif prop == 'pad'
                                  let values = []
                                elseif prop == 'padding'
                                  let values = []
                                elseif prop =~ 'padding-\%(top\|right\|bottom\|left\|inline-start\|inline-end\|block-start\|block-end\)$'
                                  let values = []
                                elseif prop =~ 'page-break-\%(after\|before\)$'
                                  let values = ["auto", "always", "avoid", "left", "right", "recto", "verso"]
                                elseif prop == 'page-break-inside'
                                  let values = ["auto", "avoid"]
                                elseif prop =~ 'pause\%(-after\|-before\)\=$'
                                  let values = ["none", "x-weak", "weak", "medium", "strong", "x-strong"]
                                elseif prop == 'perspective'
                                  let values = ["none"]
                                elseif prop == 'perspective-origin'
                                  let values = ["top", "bottom", "left", "center", " right"]
                                elseif prop == 'pointer-events'
                                  let values = ["auto", "none", "visiblePainted", "visibleFill", "visibleStroke", "visible", "painted", "fill", "stroke", "all"]
                                elseif prop == 'position'
                                  let values = ["static", "relative", "absolute", "fixed", "sticky"]
                                elseif prop == 'prefix'
                                  let values = []
                                elseif prop == 'quotes'
                                  let values = ["none"]
                                elseif prop == 'range'
                                  let values = ["auto", "infinite"]
                                elseif prop == 'resize'
                                  let values = ["none", "both", "horizontal", "vertical"]
                                elseif prop =~ 'rest\%(-after\|-before\)\=$'
                                  let values = ["none", "x-weak", "weak", "medium", "strong", "x-strong"]
                                elseif prop == 'ruby-align'
                                  let values = ["start", "center", "space-between", "space-around"]
                                elseif prop == 'ruby-merge'
                                  let values = ["separate", "collapse", "auto"]
                                elseif prop == 'ruby-position'
                                  let values = ["over", "under", "inter-character"]
                                elseif prop == 'scroll-behavior'
                                  let values = ["auto", "smooth"]
                                elseif prop == 'scroll-snap-coordinate'
                                  let values = ["none"]
                                elseif prop == 'scroll-snap-destination'
                                  return []
                                elseif prop == 'scroll-snap-points-\%(x\|y\)$'
                                  let values = ["none", "repeat("]
                                elseif prop == 'scroll-snap-type\%(-x\|-y\)\=$'
                                  let values = ["none", "mandatory", "proximity"]
                                elseif prop == 'shape-image-threshold'
                                  let values = []
                                elseif prop == 'shape-margin'
                                  let values = []
                                elseif prop == 'shape-outside'
                                  let values = ["margin-box", "border-box", "padding-box", "content-box", 'inset(', 'circle(', 'ellipse(', 'polygon(', 'url(']
                                elseif prop == 'speak'
                                  let values = ["auto", "none", "normal"]
                                elseif prop == 'speak-as'
                                  let values = ["auto", "normal", "spell-out", "digits"]
                                elseif prop == 'src'
                                  let values = ["url("]
                                elseif prop == 'suffix'
                                  let values = []
                                elseif prop == 'symbols'
                                  let values = []
                                elseif prop == 'system'
                                  let vals = matchstr(line, '.*:\s*\zs.*')
                                  if vals =~ '^extends'
                                    let values = list_style_type_values
                                  else
                                    let values = ["cyclic", "numeric", "alphabetic", "symbolic", "additive", "fixed", "extends"]
                                  endif
                                elseif prop == 'table-layout'
                                  let values = ["auto", "fixed"]
                                elseif prop == 'tab-size'
                                  let values = []
                                elseif prop == 'text-align'
                                  let values = ["start", "end", "left", "right", "center", "justify", "match-parent"]
                                elseif prop == 'text-align-last'
                                  let values = ["auto", "start", "end", "left", "right", "center", "justify"]
                                elseif prop == 'text-combine-upright'
                                  let values = ["none", "all", "digits"]
                                elseif prop == 'text-decoration-line'
                                  let values = ["none", "underline", "overline", "line-through", "blink"]
                                elseif prop == 'text-decoration-color'
                                  let values = color_values
                                elseif prop == 'text-decoration-style'
                                  let values = ["solid", "double", "dotted", "dashed", "wavy"]
                                elseif prop == 'text-decoration'
                                  let values = ["none", "underline", "overline", "line-through", "blink"] + ["solid", "double", "dotted", "dashed", "wavy"] + color_values
                                elseif prop == 'text-emphasis-color'
                                  let values = color_values
                                elseif prop == 'text-emphasis-position'
                                  let values = ["over", "under", "left", "right"]
                                elseif prop == 'text-emphasis-style'
                                  let values = ["none", "filled", "open", "dot", "circle", "double-circle", "triangle", "sesame"]
                                elseif prop == 'text-emphasis'
                                  let values = color_values + ["over", "under", "left", "right"] + ["none", "filled", "open", "dot", "circle", "double-circle", "triangle", "sesame"]
                                elseif prop == 'text-indent'
                                  let values = ["hanging", "each-line"]
                                elseif prop == 'text-orientation'
                                  let values = ["mixed", "upright", "sideways", "sideways-right", "use-glyph-orientation"]
                                elseif prop == 'text-overflow'
                                  let values = ["clip", "ellipsis"]
                                elseif prop == 'text-rendering'
                                  let values = ["auto", "optimizeSpeed", "optimizeLegibility", "geometricPrecision"]
                                elseif prop == 'text-shadow'
                                  let values = color_values
                                elseif prop == 'text-transform'
                                  let values = ["capitalize", "uppercase", "lowercase", "full-width", "none"]
                                elseif prop == 'text-underline-position'
                                  let values = ["auto", "under", "left", "right"]
                                elseif prop == 'touch-action'
                                  let values = ["auto", "none", "pan-x", "pan-y", "manipulation", "pan-left", "pan-right", "pan-top", "pan-down"]
                                elseif prop == 'transform'
                                  let values = ["matrix(", "translate(", "translateX(", "translateY(", "scale(", "scaleX(", "scaleY(", "rotate(", "skew(", "skewX(", "skewY(", "matrix3d(", "translate3d(", "translateZ(", "scale3d(", "scaleZ(", "rotate3d(", "rotateX(", "rotateY(", "rotateZ(", "perspective("]
                                elseif prop == 'transform-box'
                                  let values = ["border-box", "fill-box", "view-box"]
                                elseif prop == 'transform-origin'
                                  let values = ["left", "center", "right", "top", "bottom"]
                                elseif prop == 'transform-style'
                                  let values = ["flat", "preserve-3d"]
                                elseif prop == 'top'
                                  let values = ["auto"]
                                elseif prop == 'transition-property'
                                  let values = ["all", "none"] + s:values
                                elseif prop == 'transition-duration'
                                  let values = []
                                elseif prop == 'transition-delay'
                                  let values = []
                                elseif prop == 'transition-timing-function'
                                  let values = timing_functions
                                elseif prop == 'transition'
                                  let values = ["all", "none"] + s:values + timing_functions
                                elseif prop == 'unicode-bidi'
                                  let values = ["normal", "embed", "isolate", "bidi-override", "isolate-override", "plaintext"]
                                elseif prop == 'unicode-range'
                                  let values = ["U+"]
                                elseif prop == 'user-zoom'
                                  let values = ["zoom", "fixed"]
                                elseif prop == 'vertical-align'
                                  let values = ["baseline", "sub", "super", "top", "text-top", "middle", "bottom", "text-bottom"]
                                elseif prop == 'visibility'
                                  let values = ["visible", "hidden", "collapse"]
                                elseif prop == 'voice-volume'
                                  let values = ["silent", "x-soft", "soft", "medium", "loud", "x-loud"]
                                elseif prop == 'voice-balance'
                                  let values = ["left", "center", "right", "leftwards", "rightwards"]
                                elseif prop == 'voice-family'
                                  let values = []
                                elseif prop == 'voice-rate'
                                  let values = ["normal", "x-slow", "slow", "medium", "fast", "x-fast"]
                                elseif prop == 'voice-pitch'
                                  let values = ["absolute", "x-low", "low", "medium", "high", "x-high"]
                                elseif prop == 'voice-range'
                                  let values = ["absolute", "x-low", "low", "medium", "high", "x-high"]
                                elseif prop == 'voice-stress'
                                  let values = ["normal", "strong", "moderate", "none", "reduced "]
                                elseif prop == 'voice-duration'
                                  let values = ["auto"]
                                elseif prop == 'white-space'
                                  let values = ["normal", "pre", "nowrap", "pre-wrap", "pre-line"]
                                elseif prop == 'widows'
                                  let values = []
                                elseif prop == 'will-change'
                                  let values = ["auto", "scroll-position", "contents"] + s:values
                                elseif prop == 'word-break'
                                  let values = ["normal", "break-all", "keep-all"]
                                elseif prop == 'word-spacing'
                                  let values = ["normal"]
                                elseif prop == 'word-wrap'
                                  let values = ["normal", "break-word"]
                                elseif prop == 'writing-mode'
                                  let values = ["horizontal-tb", "vertical-rl", "vertical-lr", "sideways-rl", "sideways-lr"]
                                elseif prop == 'z-index'
                                  let values = ["auto"]
                                elseif prop == 'zoom'
                                  let values = ["auto"]
                                else
                                  " If no property match it is possible we are outside of {} and
                                  " trying to complete pseudo-(class|element)
                                  let element = tolower(matchstr(line, '\zs[a-zA-Z1-6]*\ze:[^:[:space:]]\{-}$'))
                                  if stridx('a,abbr,address,area,article,aside,audio,b,base,bdi,bdo,bgsound,blockquote,body,br,button,canvas,caption,center,cite,code,col,colgroup,command,content,data,datalist,dd,del,details,dfn,dialog,div,dl,dt,element,em,embed,fieldset,figcaption,figure,font,footer,form,frame,frameset,head,header,hgroup,hr,html,i,iframe,image,img,input,ins,isindex,kbd,keygen,label,legend,li,link,main,map,mark,menu,menuitem,meta,meter,nav,nobr,noframes,noscript,object,ol,optgroup,option,output,p,param,picture,pre,progress,q,rp,rt,rtc,ruby,s,samp,script,section,select,shadow,small,source,span,strong,style,sub,summary,sup,table,tbody,td,template,textarea,tfoot,th,thead,time,title,tr,track,u,ul,var,video,wbr', ','.element.',') > -1
                                    let values = ["active", "any", "checked", "default", "dir(", "disabled", "empty", "enabled", "first", "first-child", "first-of-type", "fullscreen", "focus", "hover", "indeterminate", "in-range", "invalid", "lang(", "last-child", "last-of-type", "left", "link", "not(", "nth-child(", "nth-last-child(", "nth-last-of-type(", "nth-of-type(", "only-child", "only-of-type", "optional", "out-of-range", "read-only", "read-write", "required", "right", "root", "scope", "target", "valid", "visited", "first-line", "first-letter", "before", "after", "selection", "backdrop"]
                                  else
                                    return []
                                  endif
                                endif
                            
                                let values = wide_keywords + values
                                " Complete values
                                let entered_value = matchstr(line, '.\{-}\zs[a-zA-Z0-9#,.(_-]*$')
                            
                                for m in values
                                  if m =~? '^'.entered_value
                                    call add(res, m)
                                  elseif m =~? entered_value
                                    call add(res2, m)
                                  endif
                                endfor
                            
                                return res + res2
                            
                              elseif borders[max(keys(borders))] == 'closebrace'
                            
                                return []
                            
                              elseif borders[max(keys(borders))] == 'exclam'
                            
                                " Complete values
                                let entered_imp = matchstr(line, '.\{-}!\s*\zs[a-zA-Z ]*$')
                            
                                let values = ["important"]
                            
                                for m in values
                                  if m =~? '^'.entered_imp
                                    call add(res, m)
                                  endif
                                endfor
                            
                                return res
                            
                              elseif borders[max(keys(borders))] == 'atrule'
                            
                                let afterat = matchstr(line, '.*@\zs.*')
                            
                                if afterat =~ '\s'
                            
                                  let atrulename = matchstr(line, '.*@\zs[a-zA-Z-]\+\ze')
                            
                                  if atrulename == 'media'
                                    let entered_atruleafter = matchstr(line, '.*@media\s\+\zs.*$')
                            
                                    if entered_atruleafter =~ "([^)]*$"
                                      let entered_atruleafter = matchstr(entered_atruleafter, '(\s*\zs[^)]*$')
                                      let values = ["max-width", "min-width", "width", "max-height", "min-height", "height", "max-aspect-ration", "min-aspect-ration", "aspect-ratio", "orientation", "max-resolution", "min-resolution", "resolution", "scan", "grid", "update-frequency", "overflow-block", "overflow-inline", "max-color", "min-color", "color", "max-color-index", "min-color-index", "color-index", "monochrome", "inverted-colors", "pointer", "hover", "any-pointer", "any-hover", "light-level", "scripting"]
                                    else
                                      let values = ["screen", "print", "speech", "all", "not", "and", "("]
                                    endif
                            
                                  elseif atrulename == 'supports'
                                    let entered_atruleafter = matchstr(line, '.*@supports\s\+\zs.*$')
                            
                                    if entered_atruleafter =~ "([^)]*$"
                                      let entered_atruleafter = matchstr(entered_atruleafter, '(\s*\zs.*$')
                                      let values = s:values
                                    else
                                      let values = ["("]
                                    endif
                            
                                  elseif atrulename == 'charset'
                                    let entered_atruleafter = matchstr(line, '.*@charset\s\+\zs.*$')
                                    let values = [ '"UTF-8";', '"ANSI_X3.4-1968";', '"ISO_8859-1:1987";', '"ISO_8859-2:1987";', '"ISO_8859-3:1988";', '"ISO_8859-4:1988";', '"ISO_8859-5:1988";',  '"ISO_8859-6:1987";', '"ISO_8859-7:1987";', '"ISO_8859-8:1988";', '"ISO_8859-9:1989";', '"ISO-8859-10";', '"ISO_6937-2-add";', '"JIS_X0201";',  '"JIS_Encoding";', '"Shift_JIS";', '"Extended_UNIX_Code_Packed_Format_for_Japanese";', '"Extended_UNIX_Code_Fixed_Width_for_Japanese";', '"BS_4730";', '"SEN_850200_C";', '"IT";', '"ES";', '"DIN_66003";', '"NS_4551-1";', '"NF_Z_62-010";', '"ISO-10646-UTF-1";', '"ISO_646.basic:1983";', '"INVARIANT";', '"ISO_646.irv:1983";', '"NATS-SEFI";', '"NATS-SEFI-ADD";', '"NATS-DANO";', '"NATS-DANO-ADD";', '"SEN_850200_B";', '"KS_C_5601-1987";', '"ISO-2022-KR";', '"EUC-KR";', '"ISO-2022-JP";', '"ISO-2022-JP-2";', '"JIS_C6220-1969-jp";', '"JIS_C6220-1969-ro";', '"PT";', '"greek7-old";',  '"latin-greek";', '"NF_Z_62-010_(1973)";', '"Latin-greek-1";', '"ISO_5427";', '"JIS_C6226-1978";', '"BS_viewdata";', '"INIS";', '"INIS-8";',  '"INIS-cyrillic";', '"ISO_5427:1981";', '"ISO_5428:1980";', '"GB_1988-80";', '"GB_2312-80";', '"NS_4551-2";', '"videotex-suppl";', '"PT2";',  '"ES2";', '"MSZ_7795.3";', '"JIS_C6226-1983";', '"greek7";', '"ASMO_449";', '"iso-ir-90";', '"JIS_C6229-1984-a";', '"JIS_C6229-1984-b";',  '"JIS_C6229-1984-b-add";', '"JIS_C6229-1984-hand";', '"JIS_C6229-1984-hand-add";', '"JIS_C6229-1984-kana";', '"ISO_2033-1983";',  '"ANSI_X3.110-1983";', '"T.61-7bit";', '"T.61-8bit";', '"ECMA-cyrillic";', '"CSA_Z243.4-1985-1";', '"CSA_Z243.4-1985-2";', '"CSA_Z243.4-1985-gr";',  '"ISO_8859-6-E";', '"ISO_8859-6-I";', '"T.101-G2";', '"ISO_8859-8-E";', '"ISO_8859-8-I";', '"CSN_369103";', '"JUS_I.B1.002";', '"IEC_P27-1";',  '"JUS_I.B1.003-serb";', '"JUS_I.B1.003-mac";', '"greek-ccitt";', '"NC_NC00-10:81";', '"ISO_6937-2-25";', '"GOST_19768-74";', '"ISO_8859-supp";',  '"ISO_10367-box";', '"latin-lap";', '"JIS_X0212-1990";', '"DS_2089";', '"us-dk";', '"dk-us";', '"KSC5636";', '"UNICODE-1-1-UTF-7";', '"ISO-2022-CN";',  '"ISO-2022-CN-EXT";', '"ISO-8859-13";', '"ISO-8859-14";', '"ISO-8859-15";', '"ISO-8859-16";', '"GBK";', '"GB18030";', '"OSD_EBCDIC_DF04_15";',  '"OSD_EBCDIC_DF03_IRV";', '"OSD_EBCDIC_DF04_1";', '"ISO-11548-1";', '"KZ-1048";', '"ISO-10646-UCS-2";', '"ISO-10646-UCS-4";', '"ISO-10646-UCS-Basic";', '"ISO-10646-Unicode-Latin1";', '"ISO-10646-J-1";', '"ISO-Unicode-IBM-1261";', '"ISO-Unicode-IBM-1268";', '"ISO-Unicode-IBM-1276";',  '"ISO-Unicode-IBM-1264";', '"ISO-Unicode-IBM-1265";', '"UNICODE-1-1";', '"SCSU";', '"UTF-7";', '"UTF-16BE";', '"UTF-16LE";', '"UTF-16";', '"CESU-8";',  '"UTF-32";', '"UTF-32BE";', '"UTF-32LE";', '"BOCU-1";', '"ISO-8859-1-Windows-3.0-Latin-1";', '"ISO-8859-1-Windows-3.1-Latin-1";',  '"ISO-8859-2-Windows-Latin-2";', '"ISO-8859-9-Windows-Latin-5";', '"hp-roman8";', '"Adobe-Standard-Encoding";', '"Ventura-US";',  '"Ventura-International";', '"DEC-MCS";', '"IBM850";', '"PC8-Danish-Norwegian";', '"IBM862";', '"PC8-Turkish";', '"IBM-Symbols";', '"IBM-Thai";',  '"HP-Legal";', '"HP-Pi-font";', '"HP-Math8";', '"Adobe-Symbol-Encoding";', '"HP-DeskTop";', '"Ventura-Math";', '"Microsoft-Publishing";',  '"Windows-31J";', '"GB2312";', '"Big5";', '"macintosh";', '"IBM037";', '"IBM038";', '"IBM273";', '"IBM274";', '"IBM275";', '"IBM277";', '"IBM278";',  '"IBM280";', '"IBM281";', '"IBM284";', '"IBM285";', '"IBM290";', '"IBM297";', '"IBM420";', '"IBM423";', '"IBM424";', '"IBM437";', '"IBM500";', '"IBM851";',  '"IBM852";', '"IBM855";', '"IBM857";', '"IBM860";', '"IBM861";', '"IBM863";', '"IBM864";', '"IBM865";', '"IBM868";', '"IBM869";', '"IBM870";', '"IBM871";',  '"IBM880";', '"IBM891";', '"IBM903";', '"IBM904";', '"IBM905";', '"IBM918";', '"IBM1026";', '"EBCDIC-AT-DE";', '"EBCDIC-AT-DE-A";', '"EBCDIC-CA-FR";',  '"EBCDIC-DK-NO";', '"EBCDIC-DK-NO-A";', '"EBCDIC-FI-SE";', '"EBCDIC-FI-SE-A";', '"EBCDIC-FR";', '"EBCDIC-IT";', '"EBCDIC-PT";', '"EBCDIC-ES";',  '"EBCDIC-ES-A";', '"EBCDIC-ES-S";', '"EBCDIC-UK";', '"EBCDIC-US";', '"UNKNOWN-8BIT";', '"MNEMONIC";', '"MNEM";', '"VISCII";', '"VIQR";', '"KOI8-R";',  '"HZ-GB-2312";', '"IBM866";', '"IBM775";', '"KOI8-U";', '"IBM00858";', '"IBM00924";', '"IBM01140";', '"IBM01141";', '"IBM01142";', '"IBM01143";',  '"IBM01144";', '"IBM01145";', '"IBM01146";', '"IBM01147";', '"IBM01148";', '"IBM01149";', '"Big5-HKSCS";', '"IBM1047";', '"PTCP154";', '"Amiga-1251";',  '"KOI7-switched";', '"BRF";', '"TSCII";', '"windows-1250";', '"windows-1251";', '"windows-1252";', '"windows-1253";', '"windows-1254";', '"windows-1255";',  '"windows-1256";', '"windows-1257";', '"windows-1258";', '"TIS-620";']
                            
                                  elseif atrulename == 'namespace'
                                    let entered_atruleafter = matchstr(line, '.*@namespace\s\+\zs.*$')
                                    let values = ["url("]
                            
                                  elseif atrulename == 'document'
                                    let entered_atruleafter = matchstr(line, '.*@document\s\+\zs.*$')
                                    let values = ["url(", "url-prefix(", "domain(", "regexp("]
                            
                                  elseif atrulename == 'import'
                                    let entered_atruleafter = matchstr(line, '.*@import\s\+\zs.*$')
                            
                                    if entered_atruleafter =~ "^[\"']"
                                      let filestart = matchstr(entered_atruleafter, '^.\zs.*')
                                      let files = split(glob(filestart.'*'), '\n')
                                      let values = map(copy(files), '"\"".v:val')
                            
                                    elseif entered_atruleafter =~ "^url("
                                      let filestart = matchstr(entered_atruleafter, "^url([\"']\\?\\zs.*")
                                      let files = split(glob(filestart.'*'), '\n')
                                      let values = map(copy(files), '"url(".v:val')
                            
                                    else
                                      let values = ['"', 'url(']
                            
                                    endif
                            
                                  else
                                    return []
                            
                                  endif
                            
                                  for m in values
                                    if m =~? '^'.entered_atruleafter
                                      if entered_atruleafter =~? '^"' && m =~? '^"'
                                        let m = m[1:]
                                      endif
                                      if b:after =~? '"' && stridx(m, '"') > -1
                                        let m = m[0:stridx(m, '"')-1]
                                      endif 
                                      call add(res, m)
                                    elseif m =~? entered_atruleafter
                                      if m =~? '^"'
                                        let m = m[1:]
                                      endif
                                      call add(res2, m)
                                    endif
                                  endfor
                            
                                  return res + res2
                            
                                endif
                            
                                let values = ["charset", "page", "media", "import", "font-face", "namespace", "supports", "keyframes", "viewport", "document"]
                            
                                let entered_atrule = matchstr(line, '.*@\zs[a-zA-Z-]*$')
                            
                                for m in values
                                  if m =~? '^'.entered_atrule
                                    call add(res, m .' ')
                                  elseif m =~? entered_atrule
                                    call add(res2, m .' ')
                                  endif
                                endfor
                            
                                return res + res2
                            
                              endif
                            
                              return []
                            

FUNCTION  <SNR>15_common_sink()
Called 1 time
Total time:   1.421420
 Self time:   0.008759

count  total (s)   self (s)
    1              0.000010   if len(a:lines) < 2
                                return
                              endif
    1              0.000010   let key = remove(a:lines, 0)
    1              0.000010   let Cmd = get(a:action, key, 'e')
    1              0.000013   if type(Cmd) == type(function('call'))
                                return Cmd(a:lines)
                              endif
    1              0.000006   if len(a:lines) > 1
                                augroup fzf_swap
                                  autocmd SwapExists * let v:swapchoice='o'| call s:warn('fzf: E325: swap file exists: '.s:fzf_expand('<afile>'))
                                augroup END
                              endif
    1              0.000004   try
    1   0.000097   0.000047     let empty = empty(s:fzf_expand('%')) && line('$') == 1 && empty(getline(1)) && !&modified
    1              0.000008     let autochdir = &autochdir
    1              0.000013     set noautochdir
    2              0.000012     for item in a:lines
    1              0.000005       if empty
    1   1.421043   0.008432         execute 'e' s:escape(item)
    1              0.000006         let empty = 0
    1              0.000003       else
                                    call s:open(Cmd, item)
                                  endif
    1              0.000016       if !has('patch-8.0.0177') && !has('nvim-0.2') && exists('#BufEnter') && isdirectory(item)
                                    doautocmd BufEnter
                                  endif
    1              0.000003     endfor
    1              0.000003   finally
    1              0.000013     let &autochdir = autochdir
    1              0.000024     silent! autocmd! fzf_swap
    1              0.000003   endtry

FUNCTION  AutoSave()
Called 6 times
Total time:   6.168437
 Self time:   0.003120

count  total (s)   self (s)
    6              0.000053   if g:auto_save == 0
                                return
                              end
                            
    6   0.000405   0.000130   let was_modified = s:IsModified()
    6              0.000028   if !was_modified
    1              0.000002     return
                              end
                            
    5              0.000046   if exists("g:auto_save_presave_hook")
                                let g:auto_save_abort = 0
                                execute "" . g:auto_save_presave_hook
                                if g:auto_save_abort >= 1
                                  return
                                endif
                              endif
                            
                              " Preserve marks that are used to remember start and
                              " end position of the last changed or yanked text (`:h '[`).
    5              0.000055   let first_char_pos = getpos("'[")
    5              0.000042   let last_char_pos = getpos("']")
                            
    5   6.165146   0.000103   call DoSave()
                            
    5              0.000063   call setpos("'[", first_char_pos)
    5              0.000032   call setpos("']", last_char_pos)
                            
    5              0.000049   if was_modified && !&modified
    5              0.000036     if exists("g:auto_save_postsave_hook")
                                  execute "" . g:auto_save_postsave_hook
                                endif
                            
    5              0.000025     if g:auto_save_silent == 0
    5              0.001888       echo "(AutoSave) saved at " . strftime("%H:%M:%S")
    5              0.000029     endif
    5              0.000013   endif

FUNCTION  <SNR>28_buffer_commit()
Called 1 time
Total time:   0.000126
 Self time:   0.000027

count  total (s)   self (s)
    1   0.000123   0.000024   return matchstr(self.spec(),'^fugitive://.\{-\}//\zs\w*')

FUNCTION  <SNR>15_callback()
Called 1 time
Total time:   1.425674
 Self time:   0.000230

count  total (s)   self (s)
                              " Since anything can be done in the sink function, there is no telling that
                              " the change of the working directory was made by &autochdir setting.
                              "
                              " We use the following heuristic to determine whether to restore CWD:
                              " - Always restore the current directory when &autochdir is disabled.
                              "   FIXME This makes it impossible to change directory from inside the sink
                              "   function when &autochdir is not used.
                              " - In case of an error or an interrupt, a:lines will be empty.
                              "   And it will be an array of a single empty string when fzf was finished
                              "   without a match. In these cases, we presume that the change of the
                              "   directory is not expected and should be undone.
    1              0.000024   let popd = has_key(a:dict, 'prev_dir') && (!&autochdir || (empty(a:lines) || len(a:lines) == 1 && empty(a:lines[0])))
    1              0.000005   if popd
    1              0.000011     let w:fzf_dir = [a:dict.prev_dir, a:dict.dir]
    1              0.000003   endif
                            
    1              0.000004   try
    1              0.000007     if has_key(a:dict, 'sink')
                                  for line in a:lines
                                    if type(a:dict.sink) == 2
                                      call a:dict.sink(line)
                                    else
                                      execute a:dict.sink s:escape(line)
                                    endif
                                  endfor
                                endif
    1              0.000008     if has_key(a:dict, 'sink*')
    1   1.421491   0.000022       call a:dict['sink*'](a:lines)
    1              0.000005     endif
    1              0.000003   catch
                                if stridx(v:exception, ':E325:') < 0
                                  echoerr v:exception
                                endif
                              endtry
                            
                              " We may have opened a new window or tab
    1              0.000003   if popd
    1              0.000010     let w:fzf_dir = [a:dict.prev_dir, a:dict.dir]
    1   0.003987   0.000012     call s:dopopd()
    1              0.000003   endif

FUNCTION  91()
Called 15 times
Total time:   0.140228
 Self time:   0.046219

count  total (s)   self (s)
   15              0.000210     if !a:force && has_key(self._checkerMap, a:filetype)
    5              0.000017         return
                                endif
                            
   10   0.052323   0.014446     execute 'runtime! syntax_checkers/' . a:filetype . '/*.vim'
                            
   10              0.000102     if !has_key(self._checkerMap, a:filetype)
                                    let self._checkerMap[a:filetype] = {}
                                endif

FUNCTION  <SNR>15_calc_size()
Called 1 time
Total time:   0.000129
 Self time:   0.000129

count  total (s)   self (s)
    1              0.000017   let val = substitute(a:val, '^\~', '', '')
    1              0.000008   if val =~ '%$'
    1              0.000010     let size = a:max * str2nr(val[:-2]) / 100
    1              0.000003   else
                                let size = min([a:max, str2nr(val)])
                              endif
                            
    1              0.000004   let srcsz = -1
    1              0.000009   if type(get(a:dict, 'source', 0)) == type([])
                                let srcsz = len(a:dict.source)
                              endif
                            
    1              0.000010   let opts = get(a:dict, 'options', '').$FZF_DEFAULT_OPTS
    1              0.000013   let margin = stridx(opts, '--inline-info') > stridx(opts, '--no-inline-info') ? 1 : 2
    1              0.000012   let margin += stridx(opts, '--header') > stridx(opts, '--no-header')
    1              0.000007   return srcsz >= 0 ? min([srcsz + margin, size]) : size

FUNCTION  <SNR>130_on_stderr_nvim()
Called 6 times
Total time:   0.003839
 Self time:   0.000498

count  total (s)   self (s)
                              " Backward compatibility for nvim < 0.2.0
    6              0.000097   if !has('nvim-0.2.0')
                                let current_buffer = gitgutter#utility#bufnr()
                                call gitgutter#utility#set_buffer(self.buffer)
                                if gitgutter#utility#is_active()
                                  call gitgutter#hunk#reset()
                                endif
                                call gitgutter#utility#set_buffer(current_buffer)
                                return
                              endif
                            
    6   0.003487   0.000147   call s:buffer_exec(self.buffer, function('gitgutter#hunk#reset'))

FUNCTION  gitgutter#utility#restore_shell()
Called 8 times
Total time:   0.000668
 Self time:   0.000668

count  total (s)   self (s)
    8              0.000097   if has('unix')
    8              0.000060     if exists('s:shell')
    8              0.000179       let &shell = s:shell
    8              0.000093       let &shellcmdflag = s:shellcmdflag
    8              0.000078       let &shellredir = s:shellredir
    8              0.000024     endif
    8              0.000019   endif

FUNCTION  <SNR>39_CacheErrors()
Called 6 times
Total time:   7.317931
 Self time:   0.005444

count  total (s)   self (s)
    6   0.000371   0.000148     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_TRACE, 'CacheErrors: ' . (len(a:checker_names) ? join(a:checker_names) : 'default checkers'))
    6   0.008586   0.000281     call s:ClearCache(a:buf)
    6   0.000934   0.000126     let newLoclist = g:SyntasticLoclist.New([])
    6   0.000197   0.000088     call newLoclist.setOwner(a:buf)
                            
    6   0.001760   0.000095     if !s:_skip_file(a:buf)
                                    " debug logging {{{3
    6   0.000310   0.000102         call syntastic#log#debugShowVariables(g:_SYNTASTIC_DEBUG_TRACE, 'aggregate_errors')
    6   0.000236   0.000086         if syntastic#util#isRunningWindows()
                                        call syntastic#log#debug(g:_SYNTASTIC_DEBUG_CHECKERS, '$TMP = ' . string($TMP) . ', $TEMP = ' . string($TEMP))
                                    else
    6   0.000327   0.000128             call syntastic#log#debug(g:_SYNTASTIC_DEBUG_CHECKERS, '$TERM = ' . string($TERM))
    6   0.000318   0.000125             call syntastic#log#debug(g:_SYNTASTIC_DEBUG_CHECKERS, '$TMPDIR = ' . string($TMPDIR))
    6              0.000017         endif
    6   0.000424   0.000228         call syntastic#log#debug(g:_SYNTASTIC_DEBUG_CHECKERS, '$PATH = ' . string($PATH))
    6   0.000382   0.000191         call syntastic#log#debug(g:_SYNTASTIC_DEBUG_TRACE, 'getcwd() = ' . string(getcwd()))
                                    " }}}3
                            
    6   0.069743   0.000169         let clist = s:registry.getCheckers(getbufvar(a:buf, '&filetype'), a:checker_names)
                            
    6   0.001488   0.000317         let aggregate_errors = syntastic#util#var('aggregate_errors') || len(syntastic#util#unique(map(copy(clist), 'v:val.getFiletype()'))) > 1
    6              0.000054         let decorate_errors = aggregate_errors && syntastic#util#var('id_checkers')
    6              0.000053         let sort_aggregated_errors = aggregate_errors && syntastic#util#var('sort_aggregated_errors')
                            
    6              0.000026         let names = []
    6              0.000032         let unavailable_checkers = 0
    6              0.000034         for checker in clist
    6   0.000187   0.000109             let cname = checker.getCName()
    6   0.001454   0.000074             if !checker.isAvailable()
                                            call syntastic#log#debug(g:_SYNTASTIC_DEBUG_TRACE, 'CacheErrors: Checker ' . cname . ' is not available')
                                            let unavailable_checkers += 1
                                            continue
                                        endif
                            
    6   0.000313   0.000109             call syntastic#log#debug(g:_SYNTASTIC_DEBUG_TRACE, 'CacheErrors: Invoking checker: ' . cname)
                            
    6   7.224880   0.000135             let loclist = checker.getLocList()
                            
    6   0.000149   0.000088             if !loclist.isEmpty()
    6              0.000024                 if decorate_errors
                                                call loclist.decorate(cname)
                                            endif
    6              0.000045                 call add(names, cname)
    6   0.000397   0.000073                 if checker.wantSort() && !sort_aggregated_errors
                                                call loclist.sort()
                                                call syntastic#log#debug(g:_SYNTASTIC_DEBUG_LOCLIST, 'sorted:', loclist)
                                            endif
                            
    6   0.000235   0.000071                 call newLoclist.extend(loclist)
                            
    6              0.000026                 if !aggregate_errors
    6              0.000020                     break
                                            endif
                                        endif
                                    endfor
                            
                                    " set names {{{3
    6              0.000030         if !empty(names)
    6   0.000888   0.000301             if len(syntastic#util#unique(map( copy(names), 'substitute(v:val, "\\m/.*", "", "")' ))) == 1
    6              0.000115                 let type = substitute(names[0], '\m/.*', '', '')
    6              0.000149                 let name = join(map( names, 'substitute(v:val, "\\m.\\{-}/", "", "")' ), ', ')
    6   0.000160   0.000097                 call newLoclist.setName( name . ' ('. type . ')' )
    6              0.000018             else
                                            " checkers from mixed types
                                            call newLoclist.setName(join(names, ', '))
                                        endif
    6              0.000013         endif
                                    " }}}3
                            
                                    " issue warning about no active checkers {{{3
    6              0.000039         if len(clist) == unavailable_checkers
                                        if !empty(a:checker_names)
                                            if len(a:checker_names) == 1
                                                call syntastic#log#warn('checker ' . a:checker_names[0] . ' is not available')
                                            else
                                                call syntastic#log#warn('checkers ' . join(a:checker_names, ', ') . ' are not available')
                                            endif
                                        else
                                            call syntastic#log#debug(g:_SYNTASTIC_DEBUG_TRACE, 'CacheErrors: no checkers available for ' . &filetype)
                                        endif
                                    endif
                                    " }}}3
                            
    6   0.000266   0.000086         call syntastic#log#debug(g:_SYNTASTIC_DEBUG_LOCLIST, 'aggregated:', newLoclist)
    6              0.000025         if sort_aggregated_errors
                                        call newLoclist.sort()
                                        call syntastic#log#debug(g:_SYNTASTIC_DEBUG_LOCLIST, 'sorted:', newLoclist)
                                    endif
    6              0.000014     endif
                            
    6   0.001769   0.000061     call newLoclist.deploy()

FUNCTION  <SNR>43_buffer_getvar()
Called 4 times
Total time:   0.000055
 Self time:   0.000055

count  total (s)   self (s)
    4              0.000044   return getbufvar(self['#'],a:var)

FUNCTION  gitgutter#sign#obsolete_gitgutter_signs_to_remove()
Called 6 times
Total time:   0.001037
 Self time:   0.000830

count  total (s)   self (s)
    6   0.000117   0.000074   let bufnr = gitgutter#utility#bufnr()
    6              0.000029   let signs_to_remove = []  " list of [<id (number)>, ...]
    6              0.000027   let remove_all_signs = 1
    6   0.000246   0.000083   let old_gitgutter_signs = gitgutter#utility#getbufvar(bufnr, 'gitgutter_signs')
   14              0.000076   for line_number in keys(old_gitgutter_signs)
    8              0.000071     if index(a:new_gitgutter_signs_line_numbers, str2nr(line_number)) == -1
    5              0.000043       call add(signs_to_remove, old_gitgutter_signs[line_number].id)
    5              0.000012     else
    3              0.000012       let remove_all_signs = 0
    3              0.000006     endif
    8              0.000018   endfor
    6              0.000037   let s:remove_all_old_signs = remove_all_signs
    6              0.000022   return signs_to_remove

FUNCTION  <SNR>74_subseparator()
Called 35 times
Total time:   0.005003
 Self time:   0.005003

count  total (s)   self (s)
   35              0.000529   let [a, c, f, v, u] = [a:components, s:lightline.component, s:lightline.component_function, s:lightline.component_visible_condition, s:lightline.component_function_visible_condition]
   35              0.002620   let xs = map(range(len(a:components)), 'a:expanded[v:val] ? "1" : has_key(f, a[v:val]) ? (has_key(u, a[v:val]) ? "(".u[a[v:val]].")" : (exists("*".f[a[v:val]]) ? "" : "exists(\"*".f[a[v:val]]."\")&&").f[a[v:val]]."()!=#\"\"") : has_key(v, a[v:val]) ? "(".v[a[v:val]].")" : has_key(c, a[v:val]) ? "1" : "0"')
   35              0.001572   return '%{' . (xs[0] ==# '1' || xs[0] ==# '(1)' ? '' : xs[0] . '&&(') . join(xs[1:], '||') . (xs[0] ==# '1' || xs[0] ==# '(1)' ? '' : ')') . '?"' . a:subseparator . '":""}'

FUNCTION  <SNR>28_buffer_type()
Called 1 time
Total time:   0.000618
 Self time:   0.000286

count  total (s)   self (s)
    1   0.000025   0.000014   if self.getvar('fugitive_type') != ''
                                let type = self.getvar('fugitive_type')
                              elseif fnamemodify(self.spec(),':p') =~# '.\git/refs/\|\.git/\w*HEAD$'
                                let type = 'head'
                              elseif self.getline(1) =~ '^tree \x\{40\}$' && self.getline(2) == ''
                                let type = 'tree'
                              elseif self.getline(1) =~ '^\d\{6\} \w\{4\} \x\{40\}\>\t'
                                let type = 'tree'
                              elseif self.getline(1) =~ '^\d\{6\} \x\{40\}\> \d\t'
                                let type = 'index'
                              elseif isdirectory(self.spec())
                                let type = 'directory'
                              elseif self.spec() == ''
                                let type = 'null'
                              else
    1              0.000004     let type = 'file'
    1              0.000002   endif
    1              0.000003   if a:0
    1              0.000015     return !empty(filter(copy(a:000),'v:val ==# type'))
                              else
                                return type
                              endif

FUNCTION  remote#host#PluginsForHost()
Called 1 time
Total time:   0.000025
 Self time:   0.000025

count  total (s)   self (s)
    1              0.000009   if !has_key(s:plugins_for_host, a:host)
                                let s:plugins_for_host[a:host] = []
                              end
    1              0.000005   return s:plugins_for_host[a:host]

FUNCTION  UltiSnips#TrackChange()
Called 21 times
Total time:   0.159648
 Self time:   0.159648

count  total (s)   self (s)
   21              0.159542     exec g:_uspy "UltiSnips_Manager._track_change()"

FUNCTION  syntastic#util#bufIsActive()
Called 6 times
Total time:   0.000384
 Self time:   0.000384

count  total (s)   self (s)
                                " convert to number, or hell breaks loose
    6              0.000059     let buf = str2nr(a:buffer)
                            
    6              0.000047     if !bufloaded(buf) || !buflisted(buf)
                                    return 0
                                endif
                            
                                " get rid of hidden buffers
    6              0.000057     for tab in range(1, tabpagenr('$'))
    6              0.000051         if index(tabpagebuflist(tab), buf) >= 0
    6              0.000019             return 1
                                    endif
                                endfor
                            
                                return 0

FUNCTION  emmet#getIndentation()
Called 2 times
Total time:   0.000195
 Self time:   0.000195

count  total (s)   self (s)
    2              0.000011   if a:0 > 0
    2              0.000010     let type = a:1
    2              0.000005   else
                                let type = emmet#getFileType()
                              endif
    2              0.000022   if has_key(s:emmet_settings, type) && has_key(s:emmet_settings[type], 'indentation')
                                let indent = s:emmet_settings[type].indentation
                              elseif has_key(s:emmet_settings, 'indentation')
                                let indent = s:emmet_settings.indentation
                              elseif has_key(s:emmet_settings.variables, 'indentation')
                                let indent = s:emmet_settings.variables.indentation
                              else
    2              0.000018     let sw = exists('*shiftwidth') ? shiftwidth() : &l:shiftwidth
    2              0.000020     let indent = (&l:expandtab || &l:tabstop !=# sw) ? repeat(' ', sw) : "\t"
    2              0.000005   endif
    2              0.000007   return indent

FUNCTION  gitgutter#utility#setbufvar()
Called 68 times
Total time:   0.002207
 Self time:   0.002207

count  total (s)   self (s)
   68              0.000756   let dict = get(getbufvar(a:buffer, ''), 'gitgutter', {})
   68              0.000500   let dict[a:varname] = a:val
   68              0.000514   call setbufvar(a:buffer, 'gitgutter', dict)

FUNCTION  UltiSnips#SnippetsInCurrentScope()
Called 1 time
Total time:   0.067420
 Self time:   0.067420

count  total (s)   self (s)
    1              0.000020     let g:current_ulti_dict = {}
    1              0.000013     let all = get(a:, 1, 0)
    1              0.000005     if all
                                  let g:current_ulti_dict_info = {}
                                endif
    1              0.067343     exec g:_uspy "UltiSnips_Manager.snippets_in_current_scope(" . all . ")"
    1              0.000018     return g:current_ulti_dict

FUNCTION  <SNR>28_repo_tree()
Called 3 times
Total time:   0.000354
 Self time:   0.000274

count  total (s)   self (s)
    3   0.000097   0.000057   if self.dir() =~# '/\.git$'
    3   0.000082   0.000042     let dir = self.dir()[0:-6]
    3              0.000021     if dir !~# '/'
                                  let dir .= '/'
                                endif
    3              0.000007   else
                                let dir = s:configured_tree(self.git_dir)
                              endif
    3              0.000011   if dir ==# ''
                                call s:throw('no work tree')
                              else
    3              0.000037     return join([dir]+a:000,'/')
                              endif

FUNCTION  provider#python3#Prog()
Called 1 time
Total time:   0.000009
 Self time:   0.000009

count  total (s)   self (s)
    1              0.000006   return s:prog

FUNCTION  emmet#mergeConfig()
Called 1 time
Total time:   0.054727
 Self time:   0.054727

count  total (s)   self (s)
    1              0.000010   let [lhs, rhs] = [a:lhs, a:rhs]
    1              0.000006   if type(lhs) ==# 3
                                if type(rhs) ==# 3
                                  let lhs += rhs
                                  if len(lhs)
                                    call remove(lhs, 0, len(lhs)-1)
                                  endif
                                  for rhi in rhs
                                    call add(lhs, rhs[rhi])
                                  endfor
                                elseif type(rhs) ==# 4
                                  let lhs += map(keys(rhs), '{v:val : rhs[v:val]}')
                                endif
                              elseif type(lhs) ==# 4
    1              0.000004     if type(rhs) ==# 3
                                  for V in rhs
                                    if type(V) != 4
                                      continue
                                    endif
                                    for k in keys(V)
                                      let lhs[k] = V[k]
                                    endfor
                                  endfor
                                elseif type(rhs) ==# 4
  642              0.002258       for key in keys(rhs)
  641              0.003751         if type(rhs[key]) ==# 3
                                      if !has_key(lhs, key)
                                        let lhs[key] = []
                                      endif
                                      if type(lhs[key]) == 3
                                        let lhs[key] += rhs[key]
                                      elseif type(lhs[key]) == 4
                                        for k in keys(rhs[key])
                                          let lhs[key][k] = rhs[key][k]
                                        endfor
                                      endif
                                    elseif type(rhs[key]) ==# 4
                                      if has_key(lhs, key)
                                        call emmet#mergeConfig(lhs[key], rhs[key])
                                      else
                                        let lhs[key] = rhs[key]
                                      endif
                                    else
  641              0.004296           let lhs[key] = rhs[key]
  641              0.001512         endif
  641              0.001521       endfor
    1              0.000003     endif
    1              0.000002   endif

FUNCTION  MakeViewCheck()
Called 7 times
Total time:   0.001641
 Self time:   0.001641

count  total (s)   self (s)
    7              0.000086     if &l:diff | return 0 | endif
    7              0.000068     if &buftype != '' | return 0 | endif
    6              0.000157     if expand('%') =~ '\[.*\]' | return 0 | endif
    6              0.000502     if empty(glob(expand('%:p'))) | return 0 | endif
    6              0.000053     if &modifiable == 0 | return 0 | endif
    6              0.000147     if len($TEMP) && expand('%:p:h') == $TEMP | return 0 | endif
    6              0.000068     if len($TMP) && expand('%:p:h') == $TMP | return 0 | endif
                            
    6              0.000236     let file_name = expand('%:p')
    6              0.000064     for ifiles in g:skipview_files
                                    if file_name =~ ifiles
                                        return 0
                                    endif
                                endfor
                            
    6              0.000022     return 1

FUNCTION  emmet#expandDollarExpr()
Called 1 time
Total time:   0.000775
 Self time:   0.000028

count  total (s)   self (s)
    1   0.000771   0.000024   return emmet#reExpandDollarExpr(a:expand, 0)

FUNCTION  37()
Called 12 times
Total time:   0.000391
 Self time:   0.000391

count  total (s)   self (s)
   12              0.000107     for match in getmatches()
                                    if stridx(match['group'], 'Syntastic') == 0
                                        call matchdelete(match['id'])
                                    endif
                                endfor

FUNCTION  deoplete#mapping#_restore_completeopt()
Called 4 times
Total time:   0.000164
 Self time:   0.000164

count  total (s)   self (s)
    4              0.000051   if exists('g:deoplete#_saved_completeopt')
    2              0.000039     let &completeopt = g:deoplete#_saved_completeopt
    2              0.000011     unlet g:deoplete#_saved_completeopt
    2              0.000006   endif

FUNCTION  <SNR>130_on_stdout_nvim()
Called 11 times
Total time:   0.000440
 Self time:   0.000440

count  total (s)   self (s)
   11              0.000100   if empty(self.stdoutbuffer)
    6              0.000045     let self.stdoutbuffer = a:data
    6              0.000018   else
    5              0.000076     let self.stdoutbuffer = self.stdoutbuffer[:-2] + [self.stdoutbuffer[-1] . a:data[0]] + a:data[1:]
    5              0.000015   endif

FUNCTION  <SNR>15_get_color()
Called 12 times
Total time:   0.000910
 Self time:   0.000910

count  total (s)   self (s)
   12              0.000121   let gui = has('termguicolors') && &termguicolors
   12              0.000059   let fam = gui ? 'gui' : 'cterm'
   12              0.000056   let pat = gui ? '^#[a-f0-9]\+' : '^[0-9]\+$'
   13              0.000066   for group in a:000
   13              0.000234     let code = synIDattr(synIDtrans(hlID(group)), a:attr, fam)
   13              0.000142     if code =~? pat
   12              0.000052       return code
                                endif
    1              0.000002   endfor
                              return ''

FUNCTION  gitgutter#utility#full_path_to_directory_of_file()
Called 18 times
Total time:   0.000757
 Self time:   0.000757

count  total (s)   self (s)
   18              0.000696   return fnamemodify(s:file, ':p:h')

FUNCTION  gitgutter#utility#git_supports_command_line_config_override()
Called 1 time
Total time:   0.007765
 Self time:   0.007765

count  total (s)   self (s)
    1              0.007722   call system(g:gitgutter_git_executable.' -c foo.bar=baz --version')
    1              0.000025   return !v:shell_error

FUNCTION  <SNR>74_convert()
Called 79 times
Total time:   0.003974
 Self time:   0.003974

count  total (s)   self (s)
   79              0.000730   if has_key(s:lightline.component_expand, a:name)
                                let type = get(s:lightline.component_type, a:name, a:index)
                                let is_raw = get(s:lightline.component_raw, a:name) || type ==# 'raw'
                                return filter(s:map(s:evaluate_expand(s:lightline.component_expand[a:name]), '[v:val, 1 + ' . is_raw . ', v:key == 1 && ' . (type !=# 'raw') . ' ? "' . type . '" : "' . a:index . '"]'), 'v:val[0] != []')
                              else
   79              0.000562     return [[[a:name], 0, a:index]]
                              endif

FUNCTION  <SNR>37__normalise_filetype()
Called 12 times
Total time:   0.000620
 Self time:   0.000620

count  total (s)   self (s)
   12              0.000189     let ft = get(s:_DEFAULT_FILETYPE_MAP, a:ftalias, a:ftalias)
   12              0.000118     let ft = get(g:syntastic_filetype_map, ft, ft)
   12              0.000153     let ft = substitute(ft, '\m-', '_', 'g')
   12              0.000054     return ft

FUNCTION  fzf#wrap()
Called 1 time
Total time:   0.002229
 Self time:   0.000559

count  total (s)   self (s)
    1              0.000015   let args = ['', {}, 0]
    1              0.000036   let expects = map(copy(args), 'type(v:val)')
    1              0.000007   let tidx = 0
    4              0.000025   for arg in copy(a:000)
    3              0.000039     let tidx = index(expects, type(arg), tidx)
    3              0.000013     if tidx < 0
                                  throw 'Invalid arguments (expected: [name string] [opts dict] [fullscreen boolean])'
                                endif
    3              0.000018     let args[tidx] = arg
    3              0.000015     let tidx += 1
    3              0.000011     unlet arg
    3              0.000008   endfor
    1              0.000006   let [name, opts, bang] = args
                            
    1              0.000005   if len(name)
    1              0.000005     let opts.name = name
    1              0.000003   end
                            
                              " Layout: g:fzf_layout (and deprecated g:fzf_height)
    1              0.000003   if bang
                                for key in s:layout_keys
                                  if has_key(opts, key)
                                    call remove(opts, key)
                                  endif
                                endfor
                              elseif !s:has_any(opts, s:layout_keys)
    1              0.000008     if !exists('g:fzf_layout') && exists('g:fzf_height')
                                  let opts.down = g:fzf_height
                                else
    1   0.000088   0.000028       let opts = extend(opts, s:validate_layout(get(g:, 'fzf_layout', s:default_layout)))
    1              0.000003     endif
    1              0.000002   endif
                            
                              " Colors: g:fzf_colors
    1   0.001466   0.000043   let opts.options = s:defaults() .' '. s:evaluate_opts(get(opts, 'options', ''))
                            
                              " History: g:fzf_history_dir
    1              0.000009   if len(name) && len(get(g:, 'fzf_history_dir', ''))
                                let dir = s:fzf_expand(g:fzf_history_dir)
                                if !isdirectory(dir)
                                  call mkdir(dir, 'p')
                                endif
                                let history = fzf#shellescape(dir.'/'.name)
                                let opts.options = join(['--history', history, opts.options])
                              endif
                            
                              " Action: g:fzf_action
    1   0.000075   0.000012   if !s:has_any(opts, ['sink', 'sink*'])
    1              0.000009     let opts._action = get(g:, 'fzf_action', s:default_action)
    1              0.000012     let opts.options .= ' --expect='.join(keys(opts._action), ',')
    1              0.000005     function! opts.sink(lines) abort
                                  return s:common_sink(self._action, a:lines)
                                endfunction
    1              0.000009     let opts['sink*'] = remove(opts, 'sink')
    1              0.000003   endif
                            
    1              0.000003   return opts

FUNCTION  gitgutter#hunk#summary()
Called 4 times
Total time:   0.000193
 Self time:   0.000080

count  total (s)   self (s)
    4   0.000181   0.000068   return gitgutter#utility#getbufvar(a:bufnr, 'summary', [0,0,0])

FUNCTION  deoplete#handler#_completion_timer_start()
Called 9 times
Total time:   0.001025
 Self time:   0.000793

count  total (s)   self (s)
    9              0.000105   if exists('s:completion_timer')
    7   0.000350   0.000118     call s:completion_timer_stop()
    7              0.000017   endif
                            
    9              0.000100   let delay = max([50, g:deoplete#auto_complete_delay])
    9              0.000158   let s:completion_timer = timer_start(delay, function('s:do_complete'))
                            
    9              0.000139   let s:prev_completion = { 'complete_position': [], 'candidates': [], 'event': '' }

FUNCTION  emmet#getDollarValueByKey()
Called 1 time
Total time:   0.000339
 Self time:   0.000179

count  total (s)   self (s)
    1              0.000006   let ret = 0
    1              0.000004   let key = a:key
    1   0.000174   0.000015   let ftsetting = get(s:emmet_settings, emmet#getFileType())
    1              0.000008   if type(ftsetting) ==# 4 && has_key(ftsetting, key)
                                let V = get(ftsetting, key)
                                if type(V) ==# 1 | return V | endif
                              endif
    1              0.000008   if type(ret) !=# 1 && has_key(s:emmet_settings.variables, key)
                                let V = get(s:emmet_settings.variables, key)
                                if type(V) ==# 1 | return V | endif
                              endif
    1              0.000009   if has_key(s:emmet_settings, 'custom_expands') && type(s:emmet_settings['custom_expands']) ==# 4
    2              0.000012     for k in keys(s:emmet_settings['custom_expands'])
    1              0.000011       if key =~# k
                                    let V = get(s:emmet_settings['custom_expands'], k)
                                    if type(V) ==# 1 | return V | endif
                                    if type(V) ==# 2 | return V(key) | endif
                                  endif
    1              0.000003     endfor
    1              0.000002   endif
    1              0.000003   return ret

FUNCTION  <SNR>15_fzf_tempname()
Called 2 times
Total time:   0.000050
 Self time:   0.000028

count  total (s)   self (s)
    2   0.000044   0.000022   return s:fzf_call('tempname')

FUNCTION  <SNR>60_Highlight_Matching_Pair()
Called 38 times
Total time:   0.015161
 Self time:   0.015161

count  total (s)   self (s)
                              " Remove any previous match.
   38              0.000514   if exists('w:paren_hl_on') && w:paren_hl_on
    3              0.000030     silent! call matchdelete(3)
    3              0.000024     let w:paren_hl_on = 0
    3              0.000009   endif
                            
                              " Avoid that we remove the popup menu.
                              " Return when there are no colors (looks like the cursor jumps).
   38              0.000411   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
                                return
                              endif
                            
                              " Get the character under the cursor and check if it's in 'matchpairs'.
   38              0.000350   let c_lnum = line('.')
   38              0.000258   let c_col = col('.')
   38              0.000172   let before = 0
                            
   38              0.000299   let text = getline(c_lnum)
   38              0.001538   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
   38              0.000325   if empty(matches)
                                let [c_before, c] = ['', '']
                              else
   38              0.000426     let [c_before, c] = matches[1:2]
   38              0.000112   endif
   38              0.001255   let plist = split(&matchpairs, '.\zs[:,]')
   38              0.000394   let i = index(plist, c)
   38              0.000165   if i < 0
                                " not found, in Insert mode try character before the cursor
   35              0.000315     if c_col > 1 && (mode() == 'i' || mode() == 'R')
   12              0.000104       let before = strlen(c_before)
   12              0.000063       let c = c_before
   12              0.000089       let i = index(plist, c)
   12              0.000037     endif
   35              0.000126     if i < 0
                                  " not found, nothing to do
   35              0.000116       return
                                endif
                              endif
                            
                              " Figure out the arguments for searchpairpos().
    3              0.000014   if i % 2 == 0
                                let s_flags = 'nW'
                                let c2 = plist[i + 1]
                              else
    3              0.000018     let s_flags = 'nbW'
    3              0.000017     let c2 = c
    3              0.000079     let c = plist[i - 1]
    3              0.000011   endif
    3              0.000014   if c == '['
                                let c = '\['
                                let c2 = '\]'
                              endif
                            
                              " Find the match.  When it was just before the cursor move it there for a
                              " moment.
    3              0.000013   if before > 0
                                let has_getcurpos = exists("*getcurpos")
                                if has_getcurpos
                                  " getcurpos() is more efficient but doesn't exist before 7.4.313.
                                  let save_cursor = getcurpos()
                                else
                                  let save_cursor = winsaveview()
                                endif
                                call cursor(c_lnum, c_col - before)
                              endif
                            
                              " Build an expression that detects whether the current cursor position is in
                              " certain syntax types (string, comment, etc.), for use as searchpairpos()'s
                              " skip argument.
                              " We match "escape" for special items, such as lispEscapeSpecial.
    3              0.000039   let s_skip = '!empty(filter(map(synstack(line("."), col(".")), ''synIDattr(v:val, "name")''), ' . '''v:val =~? "string\\|character\\|singlequote\\|escape\\|comment"''))'
                              " If executing the expression determines that the cursor is currently in
                              " one of the syntax types, then we want searchpairpos() to find the pair
                              " within those syntax types (i.e., not skip).  Otherwise, the cursor is
                              " outside of the syntax types and s_skip should keep its value so we skip any
                              " matching pair inside the syntax types.
    3              0.000540   execute 'if' s_skip '| let s_skip = 0 | endif'
                            
                              " Limit the search to lines visible in the window.
    3              0.000031   let stoplinebottom = line('w$')
    3              0.000026   let stoplinetop = line('w0')
    3              0.000016   if i % 2 == 0
                                let stopline = stoplinebottom
                              else
    3              0.000025     let stopline = stoplinetop
    3              0.000009   endif
                            
                              " Limit the search time to 300 msec to avoid a hang on very long lines.
                              " This fails when a timeout is not supported.
    3              0.000027   if mode() == 'i' || mode() == 'R'
                                let timeout = exists("b:matchparen_insert_timeout") ? b:matchparen_insert_timeout : g:matchparen_insert_timeout
                              else
    3              0.000040     let timeout = exists("b:matchparen_timeout") ? b:matchparen_timeout : g:matchparen_timeout
    3              0.000009   endif
    3              0.000014   try
    3              0.002229     let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline, timeout)
    3              0.000019   catch /E118/
                                " Can't use the timeout, restrict the stopline a bit more to avoid taking
                                " a long time on closed folds and long lines.
                                " The "viewable" variables give a range in which we can scroll while
                                " keeping the cursor at the same position.
                                " adjustedScrolloff accounts for very large numbers of scrolloff.
                                let adjustedScrolloff = min([&scrolloff, (line('w$') - line('w0')) / 2])
                                let bottom_viewable = min([line('$'), c_lnum + &lines - adjustedScrolloff - 2])
                                let top_viewable = max([1, c_lnum-&lines+adjustedScrolloff + 2])
                                " one of these stoplines will be adjusted below, but the current values are
                                " minimal boundaries within the current window
                                if i % 2 == 0
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = min([line2byte("$"), line2byte(".") + col(".") + &smc * 2])
                            	let stopline = min([bottom_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = min([bottom_viewable, c_lnum + 100])
                                  endif
                                  let stoplinebottom = stopline
                                else
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = max([1, line2byte(".") + col(".") - &smc * 2])
                            	let stopline = max([top_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = max([top_viewable, c_lnum - 100])
                                  endif
                                  let stoplinetop = stopline
                                endif
                                let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline)
                              endtry
                            
    3              0.000016   if before > 0
                                if has_getcurpos
                                  call setpos('.', save_cursor)
                                else
                                  call winrestview(save_cursor)
                                endif
                              endif
                            
                              " If a match is found setup match highlighting.
    3              0.000028   if m_lnum > 0 && m_lnum >= stoplinetop && m_lnum <= stoplinebottom 
    3              0.000026     if exists('*matchaddpos')
    3              0.000180       call matchaddpos('MatchParen', [[c_lnum, c_col - before], [m_lnum, m_col]], 10, 3)
    3              0.000010     else
                                  exe '3match MatchParen /\(\%' . c_lnum . 'l\%' . (c_col - before) . 'c\)\|\(\%' . m_lnum . 'l\%' . m_col . 'c\)/'
                                endif
    3              0.000019     let w:paren_hl_on = 1
    3              0.000009   endif

FUNCTION  <SNR>28_buffer_repo()
Called 6 times
Total time:   0.000609
 Self time:   0.000134

count  total (s)   self (s)
    6   0.000590   0.000116   return s:repo(self.getvar('git_dir'))

FUNCTION  gitgutter#hunk#increment_lines_removed()
Called 1 time
Total time:   0.000139
 Self time:   0.000054

count  total (s)   self (s)
    1   0.000022   0.000014   let bufnr = gitgutter#utility#bufnr()
    1   0.000061   0.000013   let summary = gitgutter#hunk#summary(bufnr)
    1              0.000006   let summary[2] += a:count
    1   0.000042   0.000013   call gitgutter#utility#setbufvar(bufnr, 'summary', summary)

FUNCTION  gitgutter#utility#bufnr()
Called 98 times
Total time:   0.000769
 Self time:   0.000769

count  total (s)   self (s)
   98              0.000444   return s:bufnr

FUNCTION  <SNR>84_on_insert_leave()
Called 2 times
Total time:   0.000135
 Self time:   0.000071

count  total (s)   self (s)
    2   0.000093   0.000029   call deoplete#mapping#_restore_completeopt()
    2              0.000031   let g:deoplete#_context = {}

FUNCTION  emmet#getFileType()
Called 3 times
Total time:   0.000477
 Self time:   0.000477

count  total (s)   self (s)
    3              0.000024   let flg = get(a:000, 0, 0)
    3              0.000012   let type = ''
                            
    3              0.000024   if has_key(s:emmet_settings, &filetype)
    3              0.000014     let type = &filetype
    3              0.000007   else
                                let types = split(&filetype, '\.')
                                for part in types
                                  if emmet#lang#exists(part)
                                    let type = part
                                    break
                                  endif
                                  let base = emmet#getBaseType(part)
                                  if base !=# ''
                                    if flg
                                      let type = &filetype
                                    else
                                      let type = base
                                    endif
                                    unlet base
                                    break
                                  endif
                                endfor
                              endif
    3              0.000012   if type ==# 'html'
                                let pos = emmet#util#getcurpos()
                                let type = synIDattr(synID(pos[1], pos[2], 1), 'name')
                                if type =~# '^css\w'
                                  let type = 'css'
                                endif
                                if type =~# '^html\w'
                                  let type = 'html'
                                endif
                                if type =~# '^javaScript'
                                  let type = 'javascript'
                                endif
                                if len(type) ==# 0 && type =~# '^xml'
                                  let type = 'xml'
                                endif
                              endif
    3              0.000023   if len(type) ==# 0 | let type = 'html' | endif
    3              0.000011   return type

FUNCTION  gitgutter#diff#parse_hunk()
Called 10 times
Total time:   0.000772
 Self time:   0.000772

count  total (s)   self (s)
   10              0.000267   let matches = matchlist(a:line, s:hunk_re)
   10              0.000062   if len(matches) > 0
    4              0.000033     let from_line  = str2nr(matches[1])
    4              0.000038     let from_count = (matches[2] == '') ? 1 : str2nr(matches[2])
    4              0.000028     let to_line    = str2nr(matches[3])
    4              0.000034     let to_count   = (matches[4] == '') ? 1 : str2nr(matches[4])
    4              0.000026     return [from_line, from_count, to_line, to_count]
                              else
    6              0.000017     return []
                              end

FUNCTION  syntastic#log#debugDump()
Called 6 times
Total time:   0.000221
 Self time:   0.000150

count  total (s)   self (s)
    6   0.000163   0.000092     if !s:_isDebugEnabled(a:level)
    6              0.000021         return
                                endif
                            
                                call syntastic#log#debugShowVariables( a:level, sort(keys(g:_SYNTASTIC_DEFAULTS)) )

FUNCTION  DoSave()
Called 5 times
Total time:   6.165042
 Self time:   0.035422

count  total (s)   self (s)
    5              0.000037   if g:auto_save_write_all_buffers >= 1
                                silent! wa
                              else
    5   6.164915   0.035295     silent! w
    5              0.000017   endif

FUNCTION  <SNR>28_repo()
Called 6 times
Total time:   0.000407
 Self time:   0.000407

count  total (s)   self (s)
    6              0.000073   let dir = a:0 ? a:1 : (exists('b:git_dir') && b:git_dir !=# '' ? b:git_dir : fugitive#extract_git_dir(expand('%:p')))
    6              0.000024   if dir !=# ''
    6              0.000036     if has_key(s:repos, dir)
    6              0.000042       let repo = get(s:repos, dir)
    6              0.000015     else
                                  let repo = {'git_dir': dir}
                                  let s:repos[dir] = repo
                                endif
    6              0.000097     return extend(extend(repo, s:repo_prototype, 'keep'), s:abstract_prototype, 'keep')
                              endif
                              call s:throw('not a git repository: '.expand('%:p'))

FUNCTION  gitgutter#diff#run_diff()
Called 6 times
Total time:   0.046599
 Self time:   0.003134

count  total (s)   self (s)
                              " Wrap compound commands in parentheses to make Windows happy.
                              " bash doesn't mind the parentheses.
    6              0.000036   let cmd = '('
                            
    6   0.000155   0.000083   let bufnr = gitgutter#utility#bufnr()
    6   0.000335   0.000113   let tracked = gitgutter#utility#getbufvar(bufnr, 'tracked', 0)  " i.e. tracked by git
    6              0.000020   if !tracked
                                " Don't bother trying to realtime-diff an untracked file.
                                " NOTE: perhaps we should pull this guard up to the caller?
    1              0.000003     if a:realtime
                                  throw 'diff failed'
                                else
    1   0.000121   0.000047       let cmd .= g:gitgutter_git_executable.' ls-files --error-unmatch '.gitgutter#utility#shellescape(gitgutter#utility#filename()).' && ('
    1              0.000003     endif
    1              0.000002   endif
                            
    6              0.000019   if a:realtime
                                let blob_name = g:gitgutter_diff_base.':'.gitgutter#utility#shellescape(gitgutter#utility#file_relative_to_repo_root())
                                let blob_file = s:temp_index
                                let buff_file = s:temp_buffer
                                let extension = gitgutter#utility#extension()
                                if !empty(extension)
                                  let blob_file .= '.'.extension
                                  let buff_file .= '.'.extension
                                endif
                                let cmd .= g:gitgutter_git_executable.' show '.blob_name.' > '.blob_file.' && '
                            
                                " Writing the whole buffer resets the '[ and '] marks and also the
                                " 'modified' flag (if &cpoptions includes '+').  These are unwanted
                                " side-effects so we save and restore the values ourselves.
                                let modified      = getbufvar(bufnr, "&mod")
                                let op_mark_start = getpos("'[")
                                let op_mark_end   = getpos("']")
                            
                                execute 'keepalt noautocmd silent write!' buff_file
                            
                                call setbufvar(bufnr, "&mod", modified)
                                call setpos("'[", op_mark_start)
                                call setpos("']", op_mark_end)
                              endif
                            
    6              0.000042   let cmd .= g:gitgutter_git_executable
    6              0.000022   if s:c_flag
    6              0.000032     let cmd .= ' -c "diff.autorefreshindex=0"'
    6              0.000033     let cmd .= ' -c "diff.noprefix=false"'
    6              0.000015   endif
    6              0.000048   let cmd .= ' diff --no-ext-diff --no-color -U0 '.g:gitgutter_diff_args.' '
                            
    6              0.000020   if a:realtime
                                let cmd .= ' -- '.blob_file.' '.buff_file
                              else
    6   0.000488   0.000157     let cmd .= g:gitgutter_diff_base.' -- '.gitgutter#utility#shellescape(gitgutter#utility#filename())
    6              0.000017   endif
                            
    6              0.000031   if !a:preserve_full_diff && s:grep_available
    6   0.000816   0.000111     let cmd .= ' | '.s:grep_command.' '.gitgutter#utility#shellescape('^@@ ')
    6              0.000017   endif
                            
    6              0.000036   if (!a:preserve_full_diff && s:grep_available) || a:realtime
                                " grep exits with 1 when no matches are found; diff exits with 1 when
                                " differences are found.  However we want to treat non-matches and
                                " differences as non-erroneous behaviour; so we OR the command with one
                                " which always exits with success (0).
    6              0.000041     let cmd .= ' || exit 0'
    6              0.000016   endif
                            
    6              0.000035   let cmd .= ')'
                            
    6              0.000020   if !tracked
    1              0.000005     let cmd .= ')'
    1              0.000002   endif
                            
    6   0.000567   0.000110   let cmd = gitgutter#utility#command_in_directory_of_file(cmd)
                            
    6   0.001050   0.000528   if g:gitgutter_async && gitgutter#async#available() && !a:preserve_full_diff
    6   0.041319   0.000237     call gitgutter#async#execute(cmd)
    6              0.000070     return 'async'
                            
                              else
                                let diff = gitgutter#utility#system(cmd)
                            
                                if gitgutter#utility#shell_error()
                                  " A shell error indicates the file is not tracked by git (unless something bizarre is going on).
                                  throw 'diff failed'
                                endif
                            
                                return diff
                              endif

FUNCTION  40()
Called 6 times
Total time:   0.000164
 Self time:   0.000105

count  total (s)   self (s)
    6   0.000146   0.000088     call extend(self._rawLoclist, a:other.copyRaw())

FUNCTION  <SNR>28_buffer_path()
Called 1 time
Total time:   0.001887
 Self time:   0.000303

count  total (s)   self (s)
    1   0.000139   0.000037   let rev = matchstr(self.spec(),'^fugitive://.\{-\}//\zs.*')
    1              0.000005   if rev != ''
                                let rev = s:sub(rev,'\w*','')
                              elseif s:cpath(self.spec()[0 : len(self.repo().dir())]) ==# s:cpath(self.repo().dir() . '/')
                                let rev = '/.git'.self.spec()[strlen(self.repo().dir()) : -1]
                              elseif !self.repo().bare() && s:cpath(self.spec()[0 : len(self.repo().tree())]) ==# s:cpath(self.repo().tree() . '/')
    1   0.000343   0.000031     let rev = self.spec()[strlen(self.repo().tree()) : -1]
    1              0.000003   endif
    1   0.000080   0.000021   return s:sub(s:sub(rev,'.\zs/$',''),'^/',a:0 ? a:1 : '')

FUNCTION  emmet#lang#css#findTokens()
Called 1 time
Total time:   0.000068
 Self time:   0.000068

count  total (s)   self (s)
    1              0.000028   let tmp = substitute(substitute(a:str, '^.*[;{]\s*', '', ''), '}\s*$', '', '')
    1              0.000008   if tmp =~ '/' && tmp =~ '^[a-zA-Z0-9/_.]\+$'
                                " maybe path or something
                                return ''
                              endif
    1              0.000017   return substitute(substitute(a:str, '^.*[;{]\s*', '', ''), '}\s*$', '', '')

FUNCTION  <SNR>28_repo_dir()
Called 9 times
Total time:   0.000129
 Self time:   0.000129

count  total (s)   self (s)
    9              0.000101   return join([self.git_dir]+a:000,'/')

FUNCTION  <SNR>15_fzf_expand()
Called 1 time
Total time:   0.000050
 Self time:   0.000025

count  total (s)   self (s)
    1   0.000046   0.000021   return s:fzf_call('expand', a:fmt, 1)

FUNCTION  emmet#getFilters()
Called 1 time
Total time:   0.000351
 Self time:   0.000040

count  total (s)   self (s)
    1   0.000334   0.000023   let filterstr = emmet#getResource(a:type, 'filters', '')
    1              0.000011   return split(filterstr, '\s*,\s*')

FUNCTION  <SNR>15_validate_layout()
Called 1 time
Total time:   0.000061
 Self time:   0.000061

count  total (s)   self (s)
    2              0.000012   for key in keys(a:layout)
    1              0.000007     if index(s:layout_keys, key) < 0
                                  throw printf('Invalid entry in g:fzf_layout: %s (allowed: %s)%s', key, join(s:layout_keys, ', '), key == 'options' ? '. Use $FZF_DEFAULT_OPTS.' : '')
                                endif
    1              0.000002   endfor
    1              0.000004   return a:layout

FUNCTION  gitgutter#utility#stringify()
Called 6 times
Total time:   0.000089
 Self time:   0.000089

count  total (s)   self (s)
    6              0.000059   return join(a:list, "\n")."\n"

FUNCTION  <SNR>15_collect()
Called 1 time
Total time:   0.000354
 Self time:   0.000354

count  total (s)   self (s)
    1              0.000005   try
    1              0.000098     return filereadable(a:temps.result) ? readfile(a:temps.result) : []
                              finally
    3              0.000025     for tf in values(a:temps)
    2              0.000167       silent! call delete(tf)
    2              0.000020     endfor
    1              0.000005   endtry

FUNCTION  lightline#update_once()
Called 20 times
Total time:   0.000690
 Self time:   0.000690

count  total (s)   self (s)
   20              0.000366   if !exists('w:lightline') || w:lightline
                                call lightline#update()
                              endif

FUNCTION  syntastic#util#fname2buf()
Called 11 times
Total time:   0.004632
 Self time:   0.004632

count  total (s)   self (s)
   11              0.000161     if exists('+shellslash')
                                    " bufnr() can't cope with backslashes
                                    let old_shellslash = &shellslash
                                    let &shellslash = 1
                                endif
                            
                                " this is a best-effort attempt to escape file patterns (cf. :h file-pattern)
                                " XXX it fails for filenames containing something like \{2,3}
   11              0.000065     let buf = -1
   20              0.000127     for md in [':~:.', ':~', ':p']
   17              0.000066         try
                                        " Older versions of Vim can throw E94 here
   17              0.002247             let buf = bufnr('^' . escape(fnamemodify(a:fname, md), '\*?,{}[') . '$')
   17              0.000073         catch
                                        " catch everything
                                    endtry
   17              0.000082         if buf != -1
    8              0.000027             break
                                    endif
    9              0.000027     endfor
   11              0.000047     if buf == -1
                                    " XXX definitely wrong, but hope is the last thing to die :)
    3              0.000436         let buf = bufnr(fnamemodify(a:fname, ':p'))
    3              0.000012     endif
                            
   11              0.000081     if exists('+shellslash')
                                    let &shellslash = old_shellslash
                                endif
                            
   11              0.000046     return buf

FUNCTION  emmet#reExpandDollarExpr()
Called 1 time
Total time:   0.000747
 Self time:   0.000081

count  total (s)   self (s)
    1              0.000006   let expand = a:expand
    1   0.000684   0.000018   let dollar_exprs = emmet#getDollarExprs(expand)
    1              0.000005   if len(dollar_exprs) > 0
                                if a:times < 9
                                  for n in range(len(dollar_exprs))
                                    let pair = get(dollar_exprs, n)
                                    let pat = get(pair, 'expr')
                                    let sub = get(pair, 'value')
                                    let expand = substitute(expand, pat, sub, '')
                                  endfor
                                  return emmet#reExpandDollarExpr(expand, a:times + 1)
                                endif
                              endif
    1              0.000003   return expand

FUNCTION  <SNR>27_abbrev()
Called 2 times
Total time:   0.000057
 Self time:   0.000057

count  total (s)   self (s)
    2              0.000016   if exists('g:endwise_abbreviations')
                                for word in split(get(b:, 'endwise_words', ''), ',')
                                  execute 'iabbrev <buffer><script>' word word.'<CR><SID>DiscretionaryEnd<Space><C-U><BS>'
                                endfor
                              endif

FUNCTION  gitgutter#hunk#increment_lines_added()
Called 3 times
Total time:   0.000420
 Self time:   0.000167

count  total (s)   self (s)
    3   0.000062   0.000039   let bufnr = gitgutter#utility#bufnr()
    3   0.000188   0.000043   let summary = gitgutter#hunk#summary(bufnr)
    3              0.000017   let summary[0] += a:count
    3   0.000126   0.000041   call gitgutter#utility#setbufvar(bufnr, 'summary', summary)

FUNCTION  deoplete#util#get_simple_buffer_config()
Called 18 times
Total time:   0.000409
 Self time:   0.000409

count  total (s)   self (s)
   18              0.000340   return exists(a:buffer_var) ? {a:buffer_var} : {a:user_var}

FUNCTION  gitgutter#utility#has_unsaved_changes()
Called 6 times
Total time:   0.000116
 Self time:   0.000116

count  total (s)   self (s)
    6              0.000095   return getbufvar(s:bufnr, "&mod")

FUNCTION  emmet#lang#css#parseIntoTree()
Called 1 time
Total time:   0.060024
 Self time:   0.001094

count  total (s)   self (s)
    1              0.000007   let abbr = a:abbr
    1              0.000004   let type = a:type
    1              0.000004   let prefix = 0
    1              0.000004   let value = ''
                            
    1   0.000115   0.000017   let indent = emmet#getIndentation(type)
    1   0.000496   0.000017   let aliases = emmet#getResource(type, 'aliases', {})
    1   0.055727   0.000130   let snippets = emmet#getResource(type, 'snippets', {})
    1   0.000339   0.000029   let use_pipe_for_cursor = emmet#getResource(type, 'use_pipe_for_cursor', 1)
                            
    1   0.000051   0.000026   let root = emmet#newNode()
                            
                              " emmet
    1              0.000014   let tokens = split(abbr, '+\ze[^+)!]')
    1   0.002293   0.000022   let block = emmet#util#searchRegion('{', '}')
    1   0.000161   0.000036   if abbr !~# '^@' && emmet#getBaseType(type) ==# 'css' && type !=# 'sass' && block[0] ==# [0,0] && block[1] ==# [0,0]
    1   0.000036   0.000013     let current = emmet#newNode()
    1              0.000017     let current.snippet = substitute(abbr, '\s\+$', '', '') . " {\n" . indent . "${cursor}\n}"
    1              0.000005     let current.name = ''
    1              0.000014     call add(root.child, deepcopy(current))
    1              0.000003   else
                                for n in range(len(tokens))
                                  let token = tokens[n]
                                  let prop = matchlist(token, '^\(-\{0,1}[a-zA-Z]\+\|[a-zA-Z0-9]\++\{0,1}\|([a-zA-Z0-9]\++\{0,1})\)\(\%([0-9.-]\+\%(p\|e\|em\|vh\|vw\|re\|rem\|%\)\{0,1}-\{0,1}\|-auto\)*\)$')
                                  if len(prop)
                                    let token = substitute(prop[1], '^(\(.*\))', '\1', '')
                                    if token =~# '^-'
                                      let prefix = 1
                                      let token = token[1:]
                                    endif
                                    let value = ''
                                    for v in split(prop[2], '\d\zs-')
                                      if len(value) > 0
                                        let value .= ' '
                                      endif
                                      if token =~# '^[z]'
                                        " TODO
                                        let value .= substitute(v, '[^0-9.]*$', '', '')
                                      elseif v =~# 'p$'
                                        let value .= substitute(v, 'p$', '%', '')
                                      elseif v =~# '%$'
                                        let value .= v
                                      elseif v =~# 'e$'
                                        let value .= substitute(v, 'e$', 'em', '')
                                      elseif v =~# 'em$'
                                        let value .= v
                                      elseif v =~# 'vh$'
                                        let value .= v
                                      elseif v =~# 'vw$'
                                        let value .= v
                                      elseif v =~# 're$'
                                        let value .= substitute(v, 're$', 'rem', '')
                                      elseif v =~# 'rem$'
                                        let value .= v
                                      elseif v =~# '\.'
                                        let value .= v . 'em'
                                      elseif v ==# 'auto'
                                        let value .= v
                                      elseif v ==# '0'
                                        let value .= '0'
                                      else
                                        let value .= v . 'px'
                                      endif
                                    endfor
                                  endif
                            
                                  let tag_name = token
                                  if tag_name =~# '.!$'
                                    let tag_name = tag_name[:-2]
                                    let important = 1
                                  else
                                    let important = 0
                                  endif
                                  " make default node
                                  let current = emmet#newNode()
                                  let current.important = important
                                  let current.name = tag_name
                            
                                  " aliases
                                  if has_key(aliases, tag_name)
                                    let current.name = aliases[tag_name]
                                  endif
                            
                                  " snippets
                                  if !empty(snippets)
                                    let snippet_name = tag_name
                                    if !has_key(snippets, snippet_name)
                                      let pat = '^' . join(split(tag_name, '\zs'), '\%(\|[^:-]\+-\)')
                                      let vv = filter(sort(keys(snippets)), 'snippets[v:val] =~ pat')
                                      if len(vv) == 0
                                        let vv = filter(sort(keys(snippets)), 'substitute(v:val, ":", "", "g") == snippet_name')
                                      endif
                                      if len(vv) > 0
                                        let snippet_name = vv[0]
                                      else
                                        let pat = '^' . join(split(tag_name, '\zs'), '\%(\|[^:-]\+-*\)')
                                        let vv = filter(sort(keys(snippets)), 'snippets[v:val] =~ pat')
                                        if len(vv) == 0
                                          let pat = '^' . join(split(tag_name, '\zs'), '[^:]\{-}')
                                          let vv = filter(sort(keys(snippets)), 'snippets[v:val] =~ pat')
                                          if len(vv) == 0
                                            let pat = '^' . join(split(tag_name, '\zs'), '.\{-}')
                                            let vv = filter(sort(keys(snippets)), 'snippets[v:val] =~ pat')
                                          endif
                                        endif
                                        let minl = -1
                                        for vk in vv
                                          let vvs = snippets[vk]
                                          if minl == -1 || len(vvs) < minl
                                            let snippet_name = vk
                                            let minl = len(vvs)
                                          endif
                                        endfor
                                      endif
                                    endif
                                    if has_key(snippets, snippet_name)
                                      let snippet = snippets[snippet_name]
                                      if use_pipe_for_cursor
                                        let snippet = substitute(snippet, '|', '${cursor}', 'g')
                                      endif
                                      let lines = split(snippet, "\n")
                                      call map(lines, 'substitute(v:val, "\\(    \\|\\t\\)", escape(indent, "\\\\"), "g")')
                                      let current.snippet = join(lines, "\n")
                                      let current.name = ''
                                      let current.snippet = substitute(current.snippet, ';', value . ';', '')
                                      if use_pipe_for_cursor && len(value) > 0
                                        let current.snippet = substitute(current.snippet, '\${cursor}', '', 'g')
                                      endif
                                      if n < len(tokens) - 1
                                        let current.snippet .= "\n"
                                      endif
                                    endif
                                  endif
                            
                                  let current.pos = 0
                                  let lg = matchlist(token, '^\%(linear-gradient\|lg\)(\s*\(\S\+\)\s*,\s*\([^,]\+\)\s*,\s*\([^)]\+\)\s*)$')
                                  if len(lg) == 0
                                    let lg = matchlist(token, '^\%(linear-gradient\|lg\)(\s*\(\S\+\)\s*,\s*\([^,]\+\)\s*)$')
                                    if len(lg)
                                      let [lg[1], lg[2], lg[3]] = ['linear', lg[1], lg[2]]
                                    endif
                                  endif
                                  if len(lg)
                                    let current.name = ''
                                    let current.snippet = printf("background-image:-webkit-gradient(%s, 0 0, 0 100%, from(%s), to(%s));\n", lg[1], lg[2], lg[3])
                                    call add(root.child, deepcopy(current))
                                    let current.snippet = printf("background-image:-webkit-linear-gradient(%s, %s);\n", lg[2], lg[3])
                                    call add(root.child, deepcopy(current))
                                    let current.snippet = printf("background-image:-moz-linear-gradient(%s, %s);\n", lg[2], lg[3])
                                    call add(root.child, deepcopy(current))
                                    let current.snippet = printf("background-image:-o-linear-gradient(%s, %s);\n", lg[2], lg[3])
                                    call add(root.child, deepcopy(current))
                                    let current.snippet = printf("background-image:linear-gradient(%s, %s);\n", lg[2], lg[3])
                                    call add(root.child, deepcopy(current))
                                  elseif prefix
                                    let snippet = current.snippet
                                    let current.snippet = '-webkit-' . snippet . "\n"
                                    call add(root.child, deepcopy(current))
                                    let current.snippet = '-moz-' . snippet . "\n"
                                    call add(root.child, deepcopy(current))
                                    let current.snippet = '-o-' . snippet . "\n"
                                    call add(root.child, deepcopy(current))
                                    let current.snippet = '-ms-' . snippet . "\n"
                                    call add(root.child, deepcopy(current))
                                    let current.snippet = snippet
                                    call add(root.child, current)
                                  elseif token =~# '^c#\([0-9a-fA-F]\{3}\|[0-9a-fA-F]\{6}\)\(\.[0-9]\+\)\?'
                                    let cs = split(token, '\.')
                                    let current.name = ''
                                    let [r,g,b] = [0,0,0]
                                    if len(cs[0]) == 5
                                      let rgb = matchlist(cs[0], 'c#\(.\)\(.\)\(.\)')
                                      let r = eval('0x'.rgb[1].rgb[1])
                                      let g = eval('0x'.rgb[2].rgb[2])
                                      let b = eval('0x'.rgb[3].rgb[3])
                                    elseif len(cs[0]) == 8
                                      let rgb = matchlist(cs[0], 'c#\(..\)\(..\)\(..\)')
                                      let r = eval('0x'.rgb[1])
                                      let g = eval('0x'.rgb[2])
                                      let b = eval('0x'.rgb[3])
                                    endif
                                    if len(cs) == 1
                                      let current.snippet = printf('color:rgb(%d, %d, %d);', r, g, b)
                                    else
                                      let current.snippet = printf('color:rgb(%d, %d, %d, %s);', r, g, b, string(str2float('0.'.cs[1])))
                                    endif
                                    call add(root.child, current)
                                  elseif token =~# '^c#'
                                    let current.name = ''
                                    let current.snippet = 'color:\${cursor};'
                                    call add(root.child, current)
                                  else
                                    call add(root.child, current)
                                  endif
                                endfor
                              endif
    1              0.000004   return root

FUNCTION  SyntasticMake()
Called 6 times
Total time:   7.209082
 Self time:   0.006753

count  total (s)   self (s)
    6   0.000306   0.000116     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_TRACE, 'SyntasticMake: called with options:', a:options)
                            
                                " save options and locale env variables {{{3
    6              0.000052     let old_local_errorformat = &l:errorformat
    6              0.000069     let old_errorformat = &errorformat
    6              0.000044     let old_cwd = getcwd()
                                " }}}3
                            
    6              0.000040     if has_key(a:options, 'errorformat')
    6              0.000164         let &errorformat = a:options['errorformat']
    6              0.000056         set errorformat<
    6              0.000016     endif
                            
    6              0.000039     if has_key(a:options, 'cwd')
                                    execute 'lcd ' . fnameescape(a:options['cwd'])
                                endif
                            
                                " set environment variables {{{3
    6              0.000031     let env_save = {}
    6              0.000045     if has_key(a:options, 'env') && len(a:options['env'])
                                    for key in keys(a:options['env'])
                                        if key =~? '\m^[a-z_][a-z0-9_]*$'
                                            execute 'let env_save[' . string(key) . '] = $' . key
                                            execute 'let $' . key . ' = ' . string(a:options['env'][key])
                                        endif
                                    endfor
                                endif
                                " }}}3
                            
    6   7.199473   0.000250     let err_lines = split(syntastic#util#system(a:options['makeprg']), "\n", 1)
                            
                                " restore environment variables {{{3
    6              0.000056     if len(env_save)
                                    for key in keys(env_save)
                                        execute 'let $' . key . ' = ' . string(env_save[key])
                                    endfor
                                endif
                                " }}}3
                            
    6   0.000275   0.000097     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_LOCLIST, 'checker output:', err_lines)
                            
                                " Does it still make sense to go on?
    6   0.000388   0.000134     let bailout = syntastic#util#var('exit_checks') && has_key(a:options, 'returns') && index(a:options['returns'], v:shell_error) == -1
                            
    6              0.000024     if !bailout
    6              0.000032         if has_key(a:options, 'Preprocess')
                                        let err_lines = call(a:options['Preprocess'], [err_lines])
                                        call syntastic#log#debug(g:_SYNTASTIC_DEBUG_LOCLIST, 'preprocess (external):', err_lines)
                                    elseif has_key(a:options, 'preprocess')
                                        let err_lines = call('syntastic#preprocess#' . a:options['preprocess'], [err_lines])
                                        call syntastic#log#debug(g:_SYNTASTIC_DEBUG_LOCLIST, 'preprocess:', err_lines)
                                    endif
    6              0.000734         noautocmd lgetexpr err_lines
                            
    6              0.000145         let errors = deepcopy(getloclist(0))
                            
    6              0.000038         if has_key(a:options, 'cwd')
                                        execute 'lcd ' . fnameescape(old_cwd)
                                    endif
                            
    6              0.000020         try
    6              0.000205             silent lolder
    5              0.000025         catch /\m^Vim\%((\a\+)\)\=:E380/
                                        " E380: At bottom of quickfix stack
    1              0.000011             call setloclist(0, [], 'r')
    1              0.000003             try
                                            " Vim 7.4.2200 or later
    1              0.000010                 call setloclist(0, [], 'r', { 'title': '' })
    1              0.000003             catch /\m^Vim\%((\a\+)\)\=:E\%(118\|731\)/
                                            " do nothing
                                        endtry
    1              0.000003         catch /\m^Vim\%((\a\+)\)\=:E776/
                                        " E776: No location list
                                        " do nothing
                                    endtry
    6              0.000014     else
                                    let errors = []
                                endif
                            
                                " restore options {{{3
    6              0.000122     let &errorformat = old_errorformat
    6              0.000065     let &l:errorformat = old_local_errorformat
                                " }}}3
                            
    6   0.000357   0.000250     if !s:_running_windows && (s:_os_name() =~? 'FreeBSD' || s:_os_name() =~? 'OpenBSD')
                                    call syntastic#util#redraw(g:syntastic_full_redraws)
                                endif
                            
    6              0.000019     if bailout
                                    call syntastic#log#ndebug(g:_SYNTASTIC_DEBUG_LOCLIST, 'checker output:', err_lines)
                                    throw 'Syntastic: checker error'
                                endif
                            
    6   0.000274   0.000087     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_LOCLIST, 'raw loclist:', errors)
                            
    6              0.000035     if has_key(a:options, 'defaults')
                                    call s:_add_to_errors(errors, a:options['defaults'])
                                endif
                            
                                " Add subtype info if present.
    6              0.000034     if has_key(a:options, 'subtype')
                                    call s:_add_to_errors(errors, { 'subtype': a:options['subtype'] })
                                endif
                            
    6              0.000043     if has_key(a:options, 'Postprocess') && !empty(a:options['Postprocess'])
                                    for rule in a:options['Postprocess']
                                        let errors = call(rule, [errors])
                                    endfor
                                    call syntastic#log#debug(g:_SYNTASTIC_DEBUG_LOCLIST, 'postprocess (external):', errors)
                                elseif has_key(a:options, 'postprocess') && !empty(a:options['postprocess'])
   12              0.000059         for rule in a:options['postprocess']
    6   0.002789   0.000785             let errors = call('syntastic#postprocess#' . rule, [errors])
    6              0.000017         endfor
    6   0.000278   0.000093         call syntastic#log#debug(g:_SYNTASTIC_DEBUG_LOCLIST, 'postprocess:', errors)
    6              0.000015     endif
                            
    6              0.000040     return errors

FUNCTION  <SNR>43_define_commands()
Called 2 times
Total time:   0.000431
 Self time:   0.000431

count  total (s)   self (s)
   16              0.000065   for command in s:commands
   14              0.000263     exe 'command! -buffer '.command
   14              0.000034   endfor

FUNCTION  gitgutter#hunk#reset()
Called 8 times
Total time:   0.001309
 Self time:   0.000407

count  total (s)   self (s)
    8   0.000588   0.000205   call gitgutter#utility#setbufvar(gitgutter#utility#bufnr(), 'hunks', [])
    8   0.000683   0.000164   call s:reset_summary()

FUNCTION  gitgutter#utility#exists_file()
Called 20 times
Total time:   0.000513
 Self time:   0.000513

count  total (s)   self (s)
   20              0.000447   return filereadable(s:file)

FUNCTION  fugitive#reload_status()
Called 1 time
Total time:   0.000561
 Self time:   0.000561

count  total (s)   self (s)
    1              0.000011   if exists('s:reloading_status')
                                return
                              endif
    1              0.000005   try
    1              0.000010     let s:reloading_status = 1
    1              0.000007     let mytab = tabpagenr()
    3              0.000019     for tab in [mytab] + range(1,tabpagenr('$'))
    6              0.000030       for winnr in range(1,tabpagewinnr(tab,'$'))
    4              0.000044         if getbufvar(tabpagebuflist(tab)[winnr-1],'fugitive_type') ==# 'index'
                                      execute 'tabnext '.tab
                                      if winnr != winnr()
                                        execute winnr.'wincmd w'
                                        let restorewinnr = 1
                                      endif
                                      try
                                        if !&modified
                                          call s:BufReadIndex()
                                        endif
                                      finally
                                        if exists('restorewinnr')
                                          wincmd p
                                        endif
                                        execute 'tabnext '.mytab
                                      endtry
                                    endif
    4              0.000011       endfor
    2              0.000005     endfor
    1              0.000003   finally
    1              0.000005     unlet! s:reloading_status
    1              0.000003   endtry

FUNCTION  gitgutter#utility#is_file_buffer()
Called 20 times
Total time:   0.000329
 Self time:   0.000329

count  total (s)   self (s)
   20              0.000254   return empty(getbufvar(s:bufnr, '&buftype'))

FUNCTION  <SNR>28_buffer_getvar()
Called 12 times
Total time:   0.000142
 Self time:   0.000142

count  total (s)   self (s)
   12              0.000104   return getbufvar(self['#'],a:var)

FUNCTION  <SNR>34__remove_shadowed_items()
Called 6 times
Total time:   0.000711
 Self time:   0.000711

count  total (s)   self (s)
                                " keep only the first message at a given column
    6              0.000037     let i = 0
    6              0.000051     while i < len(a:errors) - 1
                                    let j = i + 1
                                    let dupes = 0
                                    while j < len(a:errors) && a:errors[j].scol == a:errors[i].scol
                                        let dupes = 1
                                        let j += 1
                                    endwhile
                                    if dupes
                                        call remove(a:errors, i + 1, j - 1)
                                    endif
                                    let i += 1
                                endwhile
                            
                                " merge messages with the same text
    6              0.000024     let i = 0
    6              0.000038     while i < len(a:errors) - 1
                                    let j = i + 1
                                    let dupes = 0
                                    while j < len(a:errors) && a:errors[j].text == a:errors[i].text
                                        let dupes = 1
                                        let j += 1
                                    endwhile
                                    if dupes
                                        call remove(a:errors, i + 1, j - 1)
                                    endif
                                    let i += 1
                                endwhile

FUNCTION  syntastic#util#unique()
Called 36 times
Total time:   0.004666
 Self time:   0.004666

count  total (s)   self (s)
   36              0.000246     let seen = {}
   36              0.000170     let uniques = []
  101              0.000430     for e in a:list
   65              0.000522         let k = string(e)
   65              0.000418         if !has_key(seen, k)
   53              0.000324             let seen[k] = 1
   53              0.000351             call add(uniques, e)
   53              0.000142         endif
   65              0.000190     endfor
   36              0.000146     return uniques

FUNCTION  <SNR>61_LocalBrowse()
Called 3 times
Total time:   0.000483
 Self time:   0.000483

count  total (s)   self (s)
                              " Unfortunate interaction -- only DechoMsg debugging calls can be safely used here.
                              " Otherwise, the BufEnter event gets triggered when attempts to write to
                              " the DBG buffer are made.
                              
    3              0.000029   if !exists("s:vimentered")
                               " If s:vimentered doesn't exist, then the VimEnter event hasn't fired.  It will,
                               " and so s:VimEnter() will then be calling this routine, but this time with s:vimentered defined.
                            "   call Dfunc("s:LocalBrowse(dirname<".a:dirname.">)  (s:vimentered doesn't exist)")
                            "   call Dret("s:LocalBrowse")
                               return
                              endif
                            
                            "  call Dfunc("s:LocalBrowse(dirname<".a:dirname.">)  (s:vimentered=".s:vimentered.")")
                            
    3              0.000039   if has("amiga")
                               " The check against '' is made for the Amiga, where the empty
                               " string is the current directory and not checking would break
                               " things such as the help command.
                            "   call Decho("(LocalBrowse) dirname<".a:dirname.">  (isdirectory, amiga)")
                               if a:dirname != '' && isdirectory(a:dirname)
                                sil! call netrw#LocalBrowseCheck(a:dirname)
                                if exists("w:netrw_bannercnt") && line('.') < w:netrw_bannercnt
                                 exe w:netrw_bannercnt
                                endif
                               endif
                            
                              elseif isdirectory(a:dirname)
                            "   call Decho("(LocalBrowse) dirname<".a:dirname."> ft=".&ft."  (isdirectory, not amiga)")
                            "   call Dredir("LocalBrowse ft last set: ","verbose set ft")
                            "   call Decho("(s:LocalBrowse) COMBAK#23: buf#".bufnr("%")." file<".expand("%")."> line#".line(".")." col#".col("."))
                               sil! call netrw#LocalBrowseCheck(a:dirname)
                            "   call Decho("(s:LocalBrowse) COMBAK#24: buf#".bufnr("%")." file<".expand("%")."> line#".line(".")." col#".col("."))
                               if exists("w:netrw_bannercnt") && line('.') < w:netrw_bannercnt
                                exe w:netrw_bannercnt
                            "    call Decho("(s:LocalBrowse) COMBAK#25: buf#".bufnr("%")." file<".expand("%")."> line#".line(".")." col#".col("."))
                               endif
                            
                              else
                               " not a directory, ignore it
                            "   call Decho("(LocalBrowse) dirname<".a:dirname."> not a directory, ignoring...")
    3              0.000008   endif
                            "  call Decho("(s:LocalBrowse) COMBAK#26: buf#".bufnr("%")." file<".expand("%")."> line#".line(".")." col#".col("."))
                            
                            "  call Dret("s:LocalBrowse")

FUNCTION  gitgutter#utility#is_active()
Called 20 times
Total time:   0.003663
 Self time:   0.000782

count  total (s)   self (s)
   20   0.003587   0.000706   return g:gitgutter_enabled && !pumvisible() && gitgutter#utility#is_file_buffer() && gitgutter#utility#exists_file() && gitgutter#utility#not_git_dir()

FUNCTION  gitgutter#utility#save_last_seen_change()
Called 6 times
Total time:   0.000288
 Self time:   0.000114

count  total (s)   self (s)
    6   0.000268   0.000093   call gitgutter#utility#setbufvar(s:bufnr, 'last_tick', getbufvar(s:bufnr, 'changedtick'))

FUNCTION  <SNR>85_extend_opts()
Called 2 times
Total time:   0.000043
 Self time:   0.000043

count  total (s)   self (s)
    2              0.000022   if empty(a:eopts)
    2              0.000009     return
                              endif
                              if has_key(a:dict, 'options')
                                if type(a:dict.options) == s:TYPE.list && type(a:eopts) == s:TYPE.list
                                  if a:prepend
                                    let a:dict.options = extend(copy(a:eopts), a:dict.options)
                                  else
                                    call extend(a:dict.options, a:eopts)
                                  endif
                                else
                                  let all_opts = a:prepend ? [a:eopts, a:dict.options] : [a:dict.options, a:eopts]
                                  let a:dict.options = join(map(all_opts, 'type(v:val) == s:TYPE.list ? join(map(copy(v:val), "fzf#shellescape(v:val)")) : v:val'))
                                endif
                              else
                                let a:dict.options = a:eopts
                              endif

FUNCTION  syntastic#util#setLastTick()
Called 12 times
Total time:   0.000198
 Self time:   0.000198

count  total (s)   self (s)
   12              0.000156     call setbufvar(a:buf, 'syntastic_lasttick', getbufvar(a:buf, 'changedtick'))

FUNCTION  emmet#toString()
Called 1 time
Total time:   0.001529
 Self time:   0.000774

count  total (s)   self (s)
    1              0.000007   let current = a:1
    1              0.000004   if a:0 > 1
    1              0.000004     let type = a:2
    1              0.000002   else
                                let type = &filetype
                              endif
    1              0.000009   if len(type) ==# 0 | let type = 'html' | endif
    1              0.000003   if a:0 > 2
    1              0.000004     let inline = a:3
    1              0.000002   else
                                let inline = 0
                              endif
    1              0.000003   if a:0 > 3
    1              0.000005     if type(a:4) ==# 1
                                  let filters = split(a:4, '\s*,\s*')
                                else
    1              0.000004       let filters = a:4
    1              0.000002     endif
    1              0.000002   else
                                let filters = ['html']
                              endif
    1              0.000003   if a:0 > 4
    1              0.000005     let group_itemno = a:5
    1              0.000002   else
                                let group_itemno = 0
                              endif
    1              0.000003   if a:0 > 5
    1              0.000004     let indent = a:6
    1              0.000002   else
                                let indent = ''
                              endif
                            
    1   0.000308   0.000015   let dollar_expr = emmet#getResource(type, 'dollar_expr', 1)
    1              0.000004   let itemno = 0
    1              0.000003   let str = ''
    1   0.000109   0.000012   let rtype = emmet#lang#type(type)
    2              0.000009   while itemno < current.multiplier
    1              0.000005     if len(current.name)
                                  if current.multiplier ==# 1
                                    let inner = emmet#lang#{rtype}#toString(s:emmet_settings, current, type, inline, filters, s:itemno(group_itemno, current), indent)
                                  else
                                    let inner = emmet#lang#{rtype}#toString(s:emmet_settings, current, type, inline, filters, s:itemno(itemno, current), indent)
                                  endif
                                  if current.multiplier > 1
                                    let inner = substitute(inner, '\$#', '$line'.(itemno+1).'$', 'g')
                                  endif
                                  let str .= inner
                                else
    1              0.000005       let snippet = current.snippet
    1              0.000005       if len(snippet) ==# 0
                                    let snippets = emmet#getResource(type, 'snippets', {})
                                    if !empty(snippets) && has_key(snippets, 'emmet_snippet')
                                      let snippet = snippets['emmet_snippet']
                                    endif
                                  endif
    1              0.000005       if len(snippet) > 0
    1              0.000005         let tmp = snippet
    1              0.000015         let tmp = substitute(tmp, '\${emmet_name}', current.name, 'g')
    1   0.000033   0.000012         let snippet_node = emmet#newNode()
    1              0.000007         let snippet_node.value = '{'.tmp.'}'
    1              0.000005         let snippet_node.important = current.important
    1              0.000005         let snippet_node.multiplier = current.multiplier
    1   0.000391   0.000047         let str .= emmet#lang#{rtype}#toString(s:emmet_settings, snippet_node, type, inline, filters, s:itemno(group_itemno, current), indent)
    1              0.000005         if current.multiplier > 1
                                      let str .= "\n"
                                    endif
    1              0.000003       else
                                    if len(current.name)
                                      let str .= current.name
                                    endif
                                    if len(current.value)
                                      let text = current.value[1:-2]
                                      if dollar_expr
                                        " TODO: regexp engine specified
                                        if exists('&regexpengine')
                                          let text = substitute(text, '\%#=1\%(\\\)\@\<!\(\$\+\)\([^{#]\|$\)', '\=printf("%0".len(submatch(1))."d", max([itemno, group_itemno])+1).submatch(2)', 'g')
                                        else
                                          let text = substitute(text, '\%(\\\)\@\<!\(\$\+\)\([^{#]\|$\)', '\=printf("%0".len(submatch(1))."d", max([itemno, group_itemno])+1).submatch(2)', 'g')
                                        endif
                                        let text = substitute(text, '\${nr}', "\n", 'g')
                                        let text = substitute(text, '\\\$', '$', 'g')
                                      endif
                                      let str .= text
                                    endif
                                  endif
    1              0.000004       let inner = ''
    1              0.000006       if len(current.child)
                                    for n in current.child
                                      let inner .= emmet#toString(n, type, inline, filters, s:itemno(group_itemno, n), indent)
                                    endfor
                                  else
    1              0.000011         let inner = current.value[1:-2]
    1              0.000002       endif
    1              0.000011       let inner = substitute(inner, "\n", "\n" . indent, 'g')
    1              0.000011       let str = substitute(str, '\${child}', inner, '')
    1              0.000003     endif
    1              0.000005     let itemno = itemno + 1
    1              0.000003   endwhile
    1              0.000004   return str

FUNCTION  deoplete#util#has_yarp()
Called 19 times
Total time:   0.000362
 Self time:   0.000362

count  total (s)   self (s)
   19              0.000295   return !has('nvim') || get(g:, 'deoplete#enable_yarp', 0)

FUNCTION  <SNR>84_is_exiting()
Called 8 times
Total time:   0.000192
 Self time:   0.000192

count  total (s)   self (s)
    8              0.000153   return exists('v:exiting') && v:exiting != v:null

FUNCTION  lightline#highlight()
Called 3 times
Total time:   0.041315
 Self time:   0.040243

count  total (s)   self (s)
    3              0.000031   let [c, f] = [s:lightline.palette, s:lightline.mode_fallback]
    3              0.000057   let [s:lightline.llen, s:lightline.rlen] = [len(c.normal.left), len(c.normal.right)]
    3              0.000089   let [s:lightline.tab_llen, s:lightline.tab_rlen] = [len(has_key(get(c, 'tabline', {}), 'left') ? c.tabline.left : c.normal.left), len(has_key(get(c, 'tabline', {}), 'right') ? c.tabline.right : c.normal.right)]
    3              0.000079   let types = map(s:uniq(sort(filter(values(s:lightline.component_type), 'v:val !=# "raw"'))), '[v:val, 1]')
    3              0.000042   let modes = a:0 ? [a:1] : extend(['normal', 'insert', 'replace', 'visual', 'inactive', 'command', 'select', 'tabline'], exists(':terminal') == 2 ? ['terminal'] : [])
   14              0.000063   for mode in modes
   11              0.000077     let s:highlight[mode] = 1
   11              0.000144     let d = has_key(c, mode) ? mode : has_key(f, mode) && has_key(c, f[mode]) ? f[mode] : 'normal'
   11              0.000116     let left = d ==# 'tabline' ? s:lightline.tabline.left : d ==# 'inactive' ? s:lightline.inactive.left : s:lightline.active.left
   11              0.000103     let right = d ==# 'tabline' ? s:lightline.tabline.right : d ==# 'inactive' ? s:lightline.inactive.right : s:lightline.active.right
   11              0.000188     let ls = has_key(get(c, d, {}), 'left') ? c[d].left : has_key(f, d) && has_key(get(c, f[d], {}), 'left') ? c[f[d]].left : c.normal.left
   11              0.000209     let ms = has_key(get(c, d, {}), 'middle') ? c[d].middle[0] : has_key(f, d) && has_key(get(c, f[d], {}), 'middle') ? c[f[d]].middle[0] : c.normal.middle[0]
   11              0.000179     let rs = has_key(get(c, d, {}), 'right') ? c[d].right : has_key(f, d) && has_key(get(c, f[d], {}), 'right') ? c[f[d]].right : c.normal.right
   33              0.000238     for [p, l, zs] in [['Left', len(left), ls], ['Right', len(right), rs]]
  114              0.000702       for [i, t] in map(range(0, l), '[v:val, 0]') + types
   92              0.000387         if i < l || i < 1
   70              0.001555           let r = t ? (has_key(get(c, d, []), i) ? c[d][i][0] : has_key(get(c, 'tabline', {}), i) ? c.tabline[i][0] : get(c.normal, i, zs)[0]) : get(zs, i, ms)
   70   0.003881   0.002955           exec printf('hi Lightline%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s %s', p, mode, i, r[0], r[1], r[2], r[3], s:term(r))
   70              0.000182         endif
  488              0.002986         for [j, s] in map(range(0, l), '[v:val, 0]') + types
  396              0.002071           if i + 1 == j || t || s && i != l
  188              0.003740             let q = s ? (has_key(get(c, d, []), j) ? c[d][j][0] : has_key(get(c, 'tabline', {}), j) ? c.tabline[j][0] : get(c.normal, j, zs)[0]) : (j != l ? get(zs, j, ms) :ms)
  188              0.006506             exec printf('hi Lightline%s_%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s', p, mode, i, j, r[1], q[1], r[3], q[3])
  188              0.000489           endif
  396              0.001001         endfor
   92              0.000229       endfor
   22              0.000051     endfor
   11   0.000584   0.000438     exec printf('hi LightlineMiddle_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s %s', mode, ms[0], ms[1], ms[2], ms[3], s:term(ms))
   11              0.000030   endfor

FUNCTION  emmet#lang#type()
Called 3 times
Total time:   0.003105
 Self time:   0.000268

count  total (s)   self (s)
    3              0.000023   let type = a:type
    3              0.000016   let base = type
    3   0.000097   0.000065   let settings = emmet#getSettings()
    3              0.000019   while base != ''
    3              0.000050     for b in split(base, '\.')
    3   0.002849   0.000045       if emmet#lang#exists(b)
    3              0.000011         return b
                                  endif
                                  if has_key(settings, b) && has_key(settings[b], 'extends')
                                    let base = settings[b].extends
                                    break
                                  else
                                    let base = ''
                                  endif
                                endfor
                              endwhile
                              return 'html'

FUNCTION  <SNR>43_Setup()
Called 2 times
Total time:   0.003950
 Self time:   0.000094

count  total (s)   self (s)
    2   0.002795   0.000032   if s:Detect(a:path)
    2   0.001138   0.000045     silent doautocmd User Bundler
    2              0.000005   endif

FUNCTION  <SNR>28_cpath()
Called 5 times
Total time:   0.000118
 Self time:   0.000118

count  total (s)   self (s)
    5              0.000038   if exists('+fileignorecase') && &fileignorecase
                                return tolower(a:path)
                              else
    5              0.000018     return a:path
                              endif

FUNCTION  <SNR>28_repo_bare()
Called 1 time
Total time:   0.000047
 Self time:   0.000033

count  total (s)   self (s)
    1   0.000038   0.000025   if self.dir() =~# '/\.git$'
    1              0.000004     return 0
                              else
                                return s:configured_tree(self.git_dir) ==# ''
                              endif

FUNCTION  provider#pythonx#Require()
Called 1 time
Total time:   0.199169
 Self time:   0.199135

count  total (s)   self (s)
    1              0.000008   let ver = (a:host.orig_name ==# 'python') ? 2 : 3
                            
                              " Python host arguments
    1   0.000034   0.000025   let prog = (ver == '2' ?  provider#python#Prog() : provider#python3#Prog())
    1              0.000009   let args = [prog, '-c', 'import sys; sys.path.remove(""); import neovim; neovim.start_host()']
                            
                              " Collect registered Python plugins into args
    1   0.000050   0.000025   let python_plugins = remote#host#PluginsForHost(a:host.name)
    2              0.000008   for plugin in python_plugins
    1              0.000007     call add(args, plugin.path)
    1              0.000003   endfor
                            
    1              0.000003   try
    1              0.000008     let job = copy(s:job_opts)
    1              0.006610     let channel_id = jobstart(args, job)
    1              0.192322     if rpcrequest(channel_id, 'poll') ==# 'ok'
    1              0.000021       return channel_id
                                endif
                              catch
                                echomsg v:throwpoint
                                echomsg v:exception
                                for row in job.stderr
                                  echomsg row
                                endfor
                              endtry
                              throw remote#host#LoadErrorForHost(a:host.orig_name, '$NVIM_PYTHON_LOG_FILE')

FUNCTION  <SNR>34__translate()
Called 12 times
Total time:   0.000179
 Self time:   0.000179

count  total (s)   self (s)
   12              0.000138     return 'get(v:val, ' . string(a:key) . ', "") ==? ' . string(a:val)

FUNCTION  gitgutter#utility#using_xolox_shell()
Called 6 times
Total time:   0.000344
 Self time:   0.000344

count  total (s)   self (s)
    6              0.000034   if s:using_xolox_shell == -1
    1              0.000005     if !g:gitgutter_avoid_cmd_prompt_on_windows
                                  let s:using_xolox_shell = 0
                                " Although xolox/vim-shell works on both windows and unix we only want to use
                                " it on windows.
                                elseif has('win32') || has('win64') || has('win32unix')
                                  let s:using_xolox_shell = exists('g:xolox#misc#version') && exists('g:xolox#shell#version')
                                else
    1              0.000008       let s:using_xolox_shell = 0
    1              0.000003     endif
    1              0.000002   endif
    6              0.000025   return s:using_xolox_shell

FUNCTION  deoplete#util#vimoption2python_not()
Called 10 times
Total time:   0.017360
 Self time:   0.000234

count  total (s)   self (s)
   10   0.017323   0.000197   return '[^a-zA-Z' . s:vimoption2python(a:option) . ']'

FUNCTION  syntastic#util#bufRawVar()
Called 6 times
Total time:   0.000135
 Self time:   0.000135

count  total (s)   self (s)
    6              0.000113     return s:_getbufvar(a:buf, a:name, get(g:, a:name, a:0 ? a:1 : ''))

FUNCTION  gitgutter#diff#process_added()
Called 3 times
Total time:   0.000408
 Self time:   0.000408

count  total (s)   self (s)
    3              0.000016   let offset = 0
   14              0.000058   while offset < a:to_count
   11              0.000058     let line_number = a:to_line + offset
   11              0.000077     call add(a:modifications, [line_number, 'added'])
   11              0.000046     let offset += 1
   11              0.000029   endwhile

FUNCTION  58()
Called 12 times
Total time:   0.000802
 Self time:   0.000360

count  total (s)   self (s)
   12              0.000080     if !exists('self._cachedErrors')
    6   0.000535   0.000094         let self._cachedErrors = self.filter({'type': 'E'})
    6              0.000018     endif
   12              0.000044     return self._cachedErrors

FUNCTION  <SNR>28_can_diffoff()
Called 3 times
Total time:   0.000074
 Self time:   0.000074

count  total (s)   self (s)
    3              0.000062   return getwinvar(bufwinnr(a:buf), '&diff') && !empty(getbufvar(a:buf, 'git_dir')) && !empty(getwinvar(bufwinnr(a:buf), 'fugitive_diff_restore'))

FUNCTION  <SNR>130_build_command()
Called 6 times
Total time:   0.000105
 Self time:   0.000105

count  total (s)   self (s)
    6              0.000035   if has('unix')
    6              0.000035     return ['sh', '-c', a:cmd]
                              endif
                            
                              if has('win32')
                                return has('nvim') ? ['cmd.exe', '/c', a:cmd] : 'cmd.exe /c '.a:cmd
                              endif
                            
                              throw 'unknown os'

FUNCTION  syntastic#util#shexpand()
Called 6 times
Total time:   0.000449
 Self time:   0.000148

count  total (s)   self (s)
    6   0.000428   0.000127     return syntastic#util#shescape(a:0 ? expand(a:string, a:1) : expand(a:string, 1))

FUNCTION  emmet#getBaseType()
Called 2 times
Total time:   0.000155
 Self time:   0.000126

count  total (s)   self (s)
    2              0.000015   if !has_key(s:emmet_settings, a:type)
                                return ''
                              endif
    2              0.000013   if !has_key(s:emmet_settings[a:type], 'extends')
    1              0.000004     return a:type
                              endif
    1              0.000007   let extends = s:emmet_settings[a:type].extends
    1              0.000005   if type(extends) ==# 1
    1              0.000013     let tmp = split(extends, '\s*,\s*')
    1              0.000006     let ext = tmp[0]
    1              0.000003   else
                                let ext = extends[0]
                              endif
    1              0.000004   if a:type !=# ext
    1              0.000010     return emmet#getBaseType(ext)
                              endif
                              return ''

FUNCTION  <SNR>81_reset_summary()
Called 14 times
Total time:   0.000884
 Self time:   0.000338

count  total (s)   self (s)
   14   0.000839   0.000293   call gitgutter#utility#setbufvar(gitgutter#utility#bufnr(), 'summary', [0,0,0])

FUNCTION  gitgutter#utility#getbufvar()
Called 50 times
Total time:   0.001442
 Self time:   0.001442

count  total (s)   self (s)
   50              0.000541   let dict = get(getbufvar(a:buffer, ''), 'gitgutter', {})
   50              0.000315   if has_key(dict, a:varname)
   49              0.000250     return dict[a:varname]
                              else
    1              0.000003     if a:0
    1              0.000003       return a:1
                                endif
                              endif

FUNCTION  syntastic#util#argsescape()
Called 90 times
Total time:   0.003075
 Self time:   0.003075

count  total (s)   self (s)
   90              0.000852     if type(a:opt) == type('') && a:opt !=# ''
   18              0.000087         return [a:opt]
                                elseif type(a:opt) == type([])
                                    return map(copy(a:opt), 'syntastic#util#shescape(v:val)')
                                endif
                            
   72              0.000216     return []

FUNCTION  <SNR>43_Detect()
Called 2 times
Total time:   0.002763
 Self time:   0.000219

count  total (s)   self (s)
    2              0.000013   if !exists('b:bundler_lock')
    2   0.002587   0.000043     let lock = s:FindBundlerLock(a:path)
    2              0.000014     if !empty(lock)
    2              0.000011       let b:bundler_lock = lock
    2              0.000008       unlet! b:bundler_gem
    2              0.000011     elseif !empty(getbufvar('#', 'bundler_lock'))
                                  let lock = getbufvar('#', 'bundler_lock')
                                  for [gem, path] in items(s:project(lock).paths())
                                    if strpart(a:path, 0, len(path)) ==# path
                                      let b:bundler_lock = lock
                                      let b:bundler_gem = gem
                                      break
                                    endif
                                  endfor
                                endif
    2              0.000005   endif
    2              0.000013   return exists('b:bundler_lock')

FUNCTION  <SNR>28_buffer_getline()
Called 3 times
Total time:   0.000044
 Self time:   0.000044

count  total (s)   self (s)
    3              0.000035   return get(getbufline(self['#'], a:lnum), 0, '')

FUNCTION  <SNR>74_term()
Called 81 times
Total time:   0.001072
 Self time:   0.001072

count  total (s)   self (s)
   81              0.000796   return get(a:p, 4) !=# '' ? 'term='.a:p[4].' cterm='.a:p[4].' gui='.a:p[4] : ''

FUNCTION  <SNR>72_IndentLinesDisable()
Called 2 times
Total time:   0.000105
 Self time:   0.000105

count  total (s)   self (s)
    2              0.000011     if g:indentLine_newVersion
    2              0.000017         if exists("w:indentLine_indentLineId") && ! empty(w:indentLine_indentLineId)
                                        for id in w:indentLine_indentLineId
                                            try
                                                call matchdelete(id)
                                            catch /^Vim\%((\a\+)\)\=:E80[23]/
                                            endtry
                                        endfor
                                        let w:indentLine_indentLineId = []
                                    endif
                            
    2              0.000005         return
                                endif
                            
                                let b:indentLine_enabled = 0
                                try
                                    syntax clear IndentLine
                                    syntax clear IndentLineSpace
                                catch /^Vim\%((\a\+)\)\=:E28/	" catch error E28
                                endtry

FUNCTION  <SNR>20_IsModified()
Called 6 times
Total time:   0.000274
 Self time:   0.000274

count  total (s)   self (s)
    6              0.000047   if g:auto_save_write_all_buffers >= 1
                                let buffers = filter(range(1, bufnr('$')), 'bufexists(v:val)')
                                call filter(buffers, 'getbufvar(v:val, "&modified")')
                                return len(buffers) > 0
                              else
    6              0.000036     return &modified
                              endif

FUNCTION  gitgutter#diff#is_removed()
Called 1 time
Total time:   0.000011
 Self time:   0.000011

count  total (s)   self (s)
    1              0.000007   return a:from_count > 0 && a:to_count == 0

FUNCTION  <SNR>84_completion_begin()
Called 9 times
Total time:   0.051012
 Self time:   0.002468

count  total (s)   self (s)
    9   0.041243   0.000220   let context = deoplete#init#_context(a:event, [])
    9   0.004359   0.000178   if s:is_skip(a:event, context)
                                call deoplete#mapping#_restore_completeopt()
                                let g:deoplete#_context.candidates = []
                                return
                              endif
                            
    9              0.000093   if exists('s:prev_completion') && s:prev_completion.event !=# 'Manual'
                                " Call omni completion
   14              0.000082     for filetype in context.filetypes
   14   0.000991   0.000265       for pattern in deoplete#util#convert2list( deoplete#util#get_buffer_config(filetype, 'b:deoplete_omni_patterns', 'g:deoplete#omni_patterns', 'g:deoplete#_omni_patterns'))
    7              0.000054         let blacklist = ['LanguageClient#complete']
    7              0.000078         if pattern !=# '' && &l:omnifunc !=# '' && context.input =~# '\%('.pattern.'\)$' && index(blacklist, &l:omnifunc) < 0
                                      let g:deoplete#_context.candidates = []
                                      call deoplete#mapping#_set_completeopt()
                                      call feedkeys("\<C-x>\<C-o>", 'in')
                                      return
                                    endif
    7              0.000021       endfor
    7              0.000027     endfor
    7              0.000020   endif
                            
    9   0.002767   0.000153   call deoplete#util#rpcnotify( 'deoplete_auto_completion_begin', context)

FUNCTION  gitgutter#handle_diff()
Called 6 times
Total time:   0.128917
 Self time:   0.001654

count  total (s)   self (s)
    6   0.001532   0.000422   call gitgutter#debug#log(a:diff)
                            
    6   0.000372   0.000127   call gitgutter#utility#setbufvar(gitgutter#utility#bufnr(), 'tracked', 1)
                            
    6   0.002435   0.000161   call gitgutter#hunk#set_hunks(gitgutter#diff#parse_diff(a:diff))
    6   0.002663   0.000152   let modified_lines = gitgutter#diff#process_hunks(gitgutter#hunk#hunks())
                            
    6              0.000039   if len(modified_lines) > g:gitgutter_max_signs
                                call gitgutter#utility#warn_once('exceeded maximum number of signs (configured by g:gitgutter_max_signs).', 'max_signs')
                                call gitgutter#sign#clear_signs()
                                return
                              endif
                            
    6              0.000029   if g:gitgutter_signs || g:gitgutter_highlight_lines
    6   0.121218   0.000383     call gitgutter#sign#update_signs(modified_lines)
    6              0.000013   endif
                            
    6   0.000370   0.000082   call gitgutter#utility#save_last_seen_change()

FUNCTION  deoplete#mapping#_complete()
Called 2 times
Total time:   0.001043
 Self time:   0.001043

count  total (s)   self (s)
    2              0.001016   call complete(g:deoplete#_context.complete_position + 1, g:deoplete#_context.candidates)
                            
    2              0.000011   return ''

FUNCTION  <SNR>15_present()
Called 5 times
Total time:   0.000201
 Self time:   0.000201

count  total (s)   self (s)
    7              0.000051   for key in a:000
    6              0.000063     if !empty(get(a:dict, key, ''))
    4              0.000016       return 1
                                endif
    2              0.000005   endfor
    1              0.000003   return 0

FUNCTION  fzf#run()
Called 1 time
Total time:   0.067803
 Self time:   0.007882

count  total (s)   self (s)
    1              0.000004 try
    1   0.000076   0.000023   let [shell, shellslash] = s:use_sh()
                            
    1   0.000078   0.000021   let dict   = exists('a:1') ? s:upgrade(a:1) : {}
    1   0.000050   0.000023   let temps  = { 'result': s:fzf_tempname() }
    1   0.000033   0.000017   let optstr = s:evaluate_opts(get(dict, 'options', ''))
    1              0.000004   try
    1   0.000198   0.000020     let fzf_exec = s:fzf_exec()
    1              0.000003   catch
                                throw v:exception
                              endtry
                            
    1              0.000010   if has('nvim') && !has_key(dict, 'dir')
    1   0.000043   0.000017     let dict.dir = s:fzf_getcwd()
    1              0.000003   endif
    1              0.000009   if has('win32unix') && has_key(dict, 'dir')
                                let dict.dir = fnamemodify(dict.dir, ':p')
                              endif
                            
    1              0.000010   if !has_key(dict, 'source') && !empty($FZF_DEFAULT_COMMAND) && !s:is_win
    1   0.000035   0.000012     let temps.source = s:fzf_tempname()
    1   0.007251   0.007242     call writefile(s:wrap_cmds(split($FZF_DEFAULT_COMMAND, "\n")), temps.source)
    1   0.000155   0.000073     let dict.source = (empty($SHELL) ? &shell : $SHELL).' '.fzf#shellescape(temps.source)
    1              0.000003   endif
                            
    1              0.000006   if has_key(dict, 'source')
    1              0.000005     let source = dict.source
    1              0.000006     let type = type(source)
    1              0.000004     if type == 1
    1              0.000006       let prefix = '( '.source.' )|'
    1              0.000003     elseif type == 3
                                  let temps.input = s:fzf_tempname()
                                  call writefile(source, temps.input)
                                  let prefix = (s:is_win ? 'type ' : 'cat ').fzf#shellescape(temps.input).'|'
                                else
                                  throw 'Invalid source type'
                                endif
    1              0.000002   else
                                let prefix = ''
                              endif
                            
    1              0.000008   let prefer_tmux = get(g:, 'fzf_prefer_tmux', 0)
    1              0.000027   let use_height = has_key(dict, 'down') && !has('gui_running') && !(has('nvim') || s:is_win || has('win32unix') || s:present(dict, 'up', 'left', 'right', 'window')) && executable('tput') && filereadable('/dev/tty')
    1              0.000010   let has_vim8_term = has('terminal') && has('patch-8.0.995')
    1              0.000012   let has_nvim_term = has('nvim-0.2.1') || has('nvim') && !s:is_win
    1              0.000015   let use_term = has_nvim_term || has_vim8_term && !has('win32unix') && (has('gui_running') || s:is_win || !use_height && s:present(dict, 'down', 'up', 'left', 'right', 'window'))
    1              0.000013   let use_tmux = (!use_height && !use_term || prefer_tmux) && !has('win32unix') && s:tmux_enabled() && s:splittable(dict)
    1              0.000004   if prefer_tmux && use_tmux
                                let use_height = 0
                                let use_term = 0
                              endif
    1              0.000003   if use_height
                                let height = s:calc_size(&lines, dict.down, dict)
                                let optstr .= ' --height='.height
                              elseif use_term
    1              0.000007     let optstr .= ' --no-height'
    1              0.000002   endif
    1              0.000016   let command = prefix.(use_tmux ? s:fzf_tmux(dict) : fzf_exec).' '.optstr.' > '.temps.result
                            
    1              0.000003   if use_term
    1   0.059494   0.000044     return s:execute_term(dict, command, temps)
                              endif
                            
                              let lines = use_tmux ? s:execute_tmux(dict, command, temps) : s:execute(dict, command, use_height, temps)
                              call s:callback(dict, lines)
                              return lines
                            finally
    1              0.000014   let [&shell, &shellslash] = [shell, shellslash]
    1              0.000007 endtry

FUNCTION  gitgutter#diff#process_hunks()
Called 6 times
Total time:   0.002162
 Self time:   0.000320

count  total (s)   self (s)
    6              0.000046   let modified_lines = []
   10              0.000045   for hunk in a:hunks
    4   0.001924   0.000082     call extend(modified_lines, gitgutter#diff#process_hunk(hunk))
    4              0.000011   endfor
    6              0.000021   return modified_lines

FUNCTION  <SNR>89_count_braces()
Called 2 times
Total time:   0.000558
 Self time:   0.000558

count  total (s)   self (s)
    2              0.000026   let n_open = 0
    2              0.000013   let n_close = 0
    2              0.000026   let line = getline(a:lnum)
    2              0.000015   let pattern = '[{}]'
    2              0.000055   let i = match(line, pattern)
    3              0.000026   while i != -1
    1              0.000087     if synIDattr(synID(a:lnum, i + 1, 0), 'name') !~ 'css\%(Comment\|StringQ\{1,2}\)'
    1              0.000016       if line[i] == '{'
                                    let n_open += 1
                                  elseif line[i] == '}'
    1              0.000006         if n_open > 0
                                      let n_open -= 1
                                    else
    1              0.000009           let n_close += 1
    1              0.000003         endif
    1              0.000004       endif
    1              0.000003     endif
    1              0.000028     let i = match(line, pattern, i + 1)
    1              0.000006   endwhile
    2              0.000022   return a:count_open ? n_open : n_close

FUNCTION  <SNR>43_buffer_alter_paths()
Called 2 times
Total time:   0.000258
 Self time:   0.000228

count  total (s)   self (s)
    2   0.000066   0.000037   if self.getvar('&suffixesadd') =~# '\.rb\>'
                                let gem = self.getvar('bundler_gem')
                                if empty(gem)
                                  let new = self.project().sorted()
                                else
                                  let new = sort(values(self.project().dependencies(gem)))
                                endif
                                let old = type(self.getvar('bundler_paths')) == type([]) ? self.getvar('bundler_paths') : []
                                for [option, suffix] in [['path', 'lib'], ['tags', 'tags']]
                                  let value = self.getvar('&'.option)
                                  if !empty(old)
                                    let drop = s:build_path_option(old,suffix)
                                    let index = stridx(value,drop)
                                    if index > 0
                                      let value = value[0:index-1] . value[index+strlen(drop):-1]
                                    endif
                                  endif
                                  call self.setvar('&'.option,value.s:build_path_option(new,suffix))
                                endfor
                                call self.setvar('bundler_paths',new)
                              endif

FUNCTION  emmet#lang#css#toString()
Called 1 time
Total time:   0.000099
 Self time:   0.000099

count  total (s)   self (s)
    1              0.000007   let current = a:current
    1              0.000006   let value = current.value[1:-2]
    1              0.000013   let tmp = substitute(value, '\${cursor}', '', 'g')
    1              0.000026   if tmp !~ '.*{[ \t\r\n]*}$'
                                if emmet#useFilter(a:filters, 'fc')
                                  let value = substitute(value, '\([^:]\+\):\([^;]*\)', '\1: \2', 'g')
                                else
                                  let value = substitute(value, '\([^:]\+\):\([^;]*\)', '\1:\2', 'g')
                                endif
                                if current.important
                                  let value = substitute(value, ';', ' !important;', '')
                                endif
                              endif
    1              0.000004   return value

FUNCTION  gitgutter#hunk#set_hunks()
Called 6 times
Total time:   0.000816
 Self time:   0.000227

count  total (s)   self (s)
    6   0.000341   0.000118   call gitgutter#utility#setbufvar(gitgutter#utility#bufnr(), 'hunks', a:hunks)
    6   0.000435   0.000069   call s:reset_summary()

FUNCTION  <SNR>9_SynSet()
Called 2 times
Total time:   0.032129
 Self time:   0.002674

count  total (s)   self (s)
                              " clear syntax for :set syntax=OFF  and any syntax name that doesn't exist
    2              0.000021   syn clear
    2              0.000014   if exists("b:current_syntax")
                                unlet b:current_syntax
                              endif
                            
    2              0.000015   let s = expand("<amatch>")
    2              0.000008   if s == "ON"
                                " :set syntax=ON
                                if &filetype == ""
                                  echohl ErrorMsg
                                  echo "filetype unknown"
                                  echohl None
                                endif
                                let s = &filetype
                              elseif s == "OFF"
                                let s = ""
                              endif
                            
    2              0.000006   if s != ""
                                " Load the syntax file(s).  When there are several, separated by dots,
                                " load each in sequence.
    4              0.000032     for name in split(s, '\.')
    2   0.031815   0.002360       exe "runtime! syntax/" . name . ".vim syntax/" . name . "/*.vim"
    2              0.000009     endfor
    2              0.000005   endif

FUNCTION  emmet#lang#scss#toString()
Called 1 time
Total time:   0.000318
 Self time:   0.000219

count  total (s)   self (s)
    1              0.000006   let settings = a:settings
    1              0.000004   let current = a:current
    1              0.000004   let type = a:type
    1              0.000004   let inline = a:inline
    1              0.000004   let filters = a:filters
    1              0.000004   let itemno = a:itemno
    1              0.000004   let indent = a:indent
    1              0.000003   let str = ''
                            
    1              0.000014   let current_name = substitute(current.name, '\$$', itemno+1, '')
    1              0.000006   if len(current.name) > 0
                                let str .= current_name
                                let tmp = ''
                                for attr in keys(current.attr)
                                  let val = current.attr[attr]
                                  while val =~# '\$\([^#{]\|$\)'
                                    let val = substitute(val, '\(\$\+\)\([^{]\|$\)', '\=printf("%0".len(submatch(1))."d", itemno+1).submatch(2)', 'g')
                                  endwhile
                                  let attr = substitute(attr, '\$$', itemno+1, '')
                                  if attr ==# 'id'
                                    let str .= '#' . val
                                  elseif attr ==# 'class'
                                    let str .= '.' . val
                                  else
                                    let tmp .= attr . ': ' . val . ';'
                                  endif
                                endfor
                                if len(tmp) > 0
                                  let str .= " {\n"
                                  for line in split(tmp, "\n")
                                    let str .= indent . line . "\n"
                                  endfor
                                else
                                  let str .= " {\n"
                                endif
                            
                                let inner = ''
                                for child in current.child
                                  let inner .= emmet#toString(child, type, inline, filters, itemno)
                                endfor
                                let inner = substitute(inner, "\n", "\n" . escape(indent, '\'), 'g')
                                let inner = substitute(inner, "\n" . escape(indent, '\') . '$', '', 'g')
                                let str .= indent . inner . "${cursor}\n}\n"
                              else
    1   0.000127   0.000028     return emmet#lang#css#toString(settings, current, type, inline, filters, itemno, indent)
                              endif
                              return str

FUNCTION  SyntaxCheckers_sass_sass_GetLocList()
Called 6 times
Total time:   7.219279
 Self time:   0.001140

count  total (s)   self (s)
    6              0.000053     let buf = bufnr('')
    6   0.000483   0.000149     if !syntastic#util#bufVar(buf, 'sass_check_partials') && fnamemodify(bufname(buf), ':t')[0] ==# '_'
                                    return []
                                endif
                            
    6   0.008886   0.000163     let makeprg = self.makeprgBuild({ 'args_before': '--cache-location ' . s:sass_cache_location . ' ' . s:imports . ' --check' })
                            
    6              0.000251     let errorformat = '%E%\m%\%%(Syntax %\)%\?%trror: %m,' . '%+C              %.%#,' . '%C        on line %l of %f\, %.%#,' . '%C        on line %l of %f,' . '%-G %\+from line %.%#,' . '%-G %\+Use --trace for backtrace.,' . '%W%>DEPRECATION WARNING on line %l of %f:,' . '%+C%>  %.%#,' . '%W%>WARNING: on line %l of %f:,' . '%+C%>  %.%#,' . '%W%>WARNING on line %l of %f: %m,' . '%+C%>  %.%#,' . '%W%>WARNING on line %l of %f:,' . '%Z%m,' . '%W%>WARNING: %m,' . '%C         on line %l of %f\, %.%#,' . '%C         on line %l of %f,' . '%-G %\+from line %.%#,' . 'Syntax %trror on line %l: %m,' . '%-G%.%#'
                            
    6   7.209440   0.000358     return SyntasticMake({ 'makeprg': makeprg, 'errorformat': errorformat, 'postprocess': ['compressWhitespace'] })

FUNCTIONS SORTED ON TOTAL TIME
count  total (s)   self (s)  function
    6   7.348317   0.002647  <SNR>39_UpdateErrors()
    6   7.317931   0.005444  <SNR>39_CacheErrors()
    6   7.224745   0.000251  16()
    6   7.223615   0.001945  15()
    6   7.219279   0.001140  SyntaxCheckers_sass_sass_GetLocList()
    6   7.209082   0.006753  SyntasticMake()
    7   7.208172   7.207476  syntastic#util#system()
    6   6.168437   0.003120  AutoSave()
    5   6.165042   0.035422  DoSave()
    5   6.056573   0.000507  <SNR>39_BufWritePostHook()
    1   1.440466   0.000674  102()
    1   1.425674   0.000230  <SNR>15_callback()
    1   1.421469   0.000050  100()
    1   1.421420   0.008759  <SNR>15_common_sink()
    3   1.296857   0.000635  <SNR>39_BufEnterHook()
   24   0.473563   0.274273  provider#python3#Call()
    1   0.199290   0.000121  remote#host#Require()
    1   0.199169   0.199135  provider#pythonx#Require()
   21   0.159648             UltiSnips#TrackChange()
   15   0.140228   0.046219  91()

FUNCTIONS SORTED ON SELF TIME
count  total (s)   self (s)  function
    7   7.208172   7.207476  syntastic#util#system()
   24   0.473563   0.274273  provider#python3#Call()
    1   0.199169   0.199135  provider#pythonx#Require()
   21              0.159648  UltiSnips#TrackChange()
    6   0.070895   0.070588  gitgutter#sign#remove_signs()
    1              0.067420  UltiSnips#SnippetsInCurrentScope()
    1              0.054727  emmet#mergeConfig()
   15   0.140228   0.046219  91()
   19   0.081700   0.045650  deoplete#init#_context()
    6   0.041082   0.040927  gitgutter#async#execute()
    3   0.041315   0.040243  lightline#highlight()
    5   6.165042   0.035422  DoSave()
    3   0.034550   0.034343  gitgutter#sign#add_dummy_sign()
  149   0.030592   0.026237  lightline#link()
    5              0.025976  csscomplete#CompleteCSS()
   29   0.034814   0.018756  <SNR>82_vimoption2python()
   40              0.018319  deoplete#util#uniq()
   10   0.036298   0.015902  <SNR>74_line()
   38              0.015161  <SNR>60_Highlight_Matching_Pair()
    1   0.059449   0.008953  <SNR>15_execute_term()

